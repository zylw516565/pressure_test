// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: zna_protocol_message.proto

#ifndef PROTOBUF_zna_5fprotocol_5fmessage_2eproto__INCLUDED
#define PROTOBUF_zna_5fprotocol_5fmessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace zna {
namespace protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

class UpgradeInfo;
class LoginReq;
class LoginRsp;
class HeartbeatReq;
class HeartbeatRsp;
class SendRSAReq;
class SendRC4Rsp;
class SetParameterRsp;
class SetParameterReq;
class GetParameterRsp;
class GetParameterReq;
class ECM_Info;
class METER_Info;
class BCM_Info;
class ACU_Info;
class ECO_Info;
class ALARM_Info;
class PEPS_Info;
class ESP_Info;
class EPB_Info;
class TCU_Info;
class AWD_Info;
class AC_Info;
class SAS_Info;
class Basic_Info;
class Vehicle_Info;
class Vehicle_InfoRsp;
class Location_Info;
class Location_InfoRsp;
class RemoteControlResultRsp;
class RemoteControlReq;
class FlowCountRsp;
class FlowCountLimitReq;
class OtaUpgradeReq;
class OtaUpgradeRsp;
class CancelOtaUpgradeRsp;
class OtaUpgradeProgressReq;
class CertCom;
class TCUCertApply_Req;
class TCUCertApply_Rsp;
class CertIssue_Req;
class CertIssue_Rsp;
class RSALoginReq;
class SendRSARsp;
class SendRC4Req;
class SendRC4Resp;
class WakeUpDVRRsp;
class WakeUpDVRReq;
class RmtDiagRsp;
class RmtDiagReq;
class Fault_List_info;
class FourGExtendCmdRsp;
class FourGExtendCmdReq;
class TCUExtendCmdReq;
class TCUExtendCmdRsp;
class FCM_Info;
class EPS_Info;
class ELD_Info;
class ECU_Info;

enum RspCode {
  FAILED = 0,
  SUCCESS = 1
};
bool RspCode_IsValid(int value);
const RspCode RspCode_MIN = FAILED;
const RspCode RspCode_MAX = SUCCESS;
const int RspCode_ARRAYSIZE = RspCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* RspCode_descriptor();
inline const ::std::string& RspCode_Name(RspCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    RspCode_descriptor(), value);
}
inline bool RspCode_Parse(
    const ::std::string& name, RspCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RspCode>(
    RspCode_descriptor(), name, value);
}
enum UpgradeProgressCodeType {
  DOWNLOADING_UPGRADE_PACK = 0,
  DOWNLOAD_UPGRADE_PACK_RESULT = 1,
  BACKUPING_MCU_APP = 2,
  BACKUP_MCU_APP_RESULT = 3,
  START_UPGRADE = 4,
  UPGRADE_RESULT = 5,
  WAITING_UPDATE_CONDITION_SLEEP = 6
};
bool UpgradeProgressCodeType_IsValid(int value);
const UpgradeProgressCodeType UpgradeProgressCodeType_MIN = DOWNLOADING_UPGRADE_PACK;
const UpgradeProgressCodeType UpgradeProgressCodeType_MAX = WAITING_UPDATE_CONDITION_SLEEP;
const int UpgradeProgressCodeType_ARRAYSIZE = UpgradeProgressCodeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UpgradeProgressCodeType_descriptor();
inline const ::std::string& UpgradeProgressCodeType_Name(UpgradeProgressCodeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UpgradeProgressCodeType_descriptor(), value);
}
inline bool UpgradeProgressCodeType_Parse(
    const ::std::string& name, UpgradeProgressCodeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UpgradeProgressCodeType>(
    UpgradeProgressCodeType_descriptor(), name, value);
}
enum RmtDiagRspCode {
  RMT_FAILED = 0,
  RMT_SUCCESS = 1,
  RMT_DIAGNOSING = 2,
  RMT_DIAGNOSED = 3
};
bool RmtDiagRspCode_IsValid(int value);
const RmtDiagRspCode RmtDiagRspCode_MIN = RMT_FAILED;
const RmtDiagRspCode RmtDiagRspCode_MAX = RMT_DIAGNOSED;
const int RmtDiagRspCode_ARRAYSIZE = RmtDiagRspCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* RmtDiagRspCode_descriptor();
inline const ::std::string& RmtDiagRspCode_Name(RmtDiagRspCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    RmtDiagRspCode_descriptor(), value);
}
inline bool RmtDiagRspCode_Parse(
    const ::std::string& name, RmtDiagRspCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RmtDiagRspCode>(
    RmtDiagRspCode_descriptor(), name, value);
}
// ===================================================================

class UpgradeInfo : public ::google::protobuf::Message {
 public:
  UpgradeInfo();
  virtual ~UpgradeInfo();

  UpgradeInfo(const UpgradeInfo& from);

  inline UpgradeInfo& operator=(const UpgradeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpgradeInfo& default_instance();

  void Swap(UpgradeInfo* other);

  // implements Message ----------------------------------------------

  UpgradeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpgradeInfo& from);
  void MergeFrom(const UpgradeInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string filetype = 1;
  inline bool has_filetype() const;
  inline void clear_filetype();
  static const int kFiletypeFieldNumber = 1;
  inline const ::std::string& filetype() const;
  inline void set_filetype(const ::std::string& value);
  inline void set_filetype(const char* value);
  inline void set_filetype(const char* value, size_t size);
  inline ::std::string* mutable_filetype();
  inline ::std::string* release_filetype();
  inline void set_allocated_filetype(::std::string* filetype);

  // required string filepath = 2;
  inline bool has_filepath() const;
  inline void clear_filepath();
  static const int kFilepathFieldNumber = 2;
  inline const ::std::string& filepath() const;
  inline void set_filepath(const ::std::string& value);
  inline void set_filepath(const char* value);
  inline void set_filepath(const char* value, size_t size);
  inline ::std::string* mutable_filepath();
  inline ::std::string* release_filepath();
  inline void set_allocated_filepath(::std::string* filepath);

  // required string version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // required uint32 filesize = 4;
  inline bool has_filesize() const;
  inline void clear_filesize();
  static const int kFilesizeFieldNumber = 4;
  inline ::google::protobuf::uint32 filesize() const;
  inline void set_filesize(::google::protobuf::uint32 value);

  // required bytes md5 = 5;
  inline bool has_md5() const;
  inline void clear_md5();
  static const int kMd5FieldNumber = 5;
  inline const ::std::string& md5() const;
  inline void set_md5(const ::std::string& value);
  inline void set_md5(const char* value);
  inline void set_md5(const void* value, size_t size);
  inline ::std::string* mutable_md5();
  inline ::std::string* release_md5();
  inline void set_allocated_md5(::std::string* md5);

  // optional string rc4 = 6;
  inline bool has_rc4() const;
  inline void clear_rc4();
  static const int kRc4FieldNumber = 6;
  inline const ::std::string& rc4() const;
  inline void set_rc4(const ::std::string& value);
  inline void set_rc4(const char* value);
  inline void set_rc4(const char* value, size_t size);
  inline ::std::string* mutable_rc4();
  inline ::std::string* release_rc4();
  inline void set_allocated_rc4(::std::string* rc4);

  // optional bytes sign_md5 = 7;
  inline bool has_sign_md5() const;
  inline void clear_sign_md5();
  static const int kSignMd5FieldNumber = 7;
  inline const ::std::string& sign_md5() const;
  inline void set_sign_md5(const ::std::string& value);
  inline void set_sign_md5(const char* value);
  inline void set_sign_md5(const void* value, size_t size);
  inline ::std::string* mutable_sign_md5();
  inline ::std::string* release_sign_md5();
  inline void set_allocated_sign_md5(::std::string* sign_md5);

  // optional bytes sha2 = 8;
  inline bool has_sha2() const;
  inline void clear_sha2();
  static const int kSha2FieldNumber = 8;
  inline const ::std::string& sha2() const;
  inline void set_sha2(const ::std::string& value);
  inline void set_sha2(const char* value);
  inline void set_sha2(const void* value, size_t size);
  inline ::std::string* mutable_sha2();
  inline ::std::string* release_sha2();
  inline void set_allocated_sha2(::std::string* sha2);

  // optional string aes128 = 9;
  inline bool has_aes128() const;
  inline void clear_aes128();
  static const int kAes128FieldNumber = 9;
  inline const ::std::string& aes128() const;
  inline void set_aes128(const ::std::string& value);
  inline void set_aes128(const char* value);
  inline void set_aes128(const char* value, size_t size);
  inline ::std::string* mutable_aes128();
  inline ::std::string* release_aes128();
  inline void set_allocated_aes128(::std::string* aes128);

  // optional bytes sign_sha2 = 10;
  inline bool has_sign_sha2() const;
  inline void clear_sign_sha2();
  static const int kSignSha2FieldNumber = 10;
  inline const ::std::string& sign_sha2() const;
  inline void set_sign_sha2(const ::std::string& value);
  inline void set_sign_sha2(const char* value);
  inline void set_sign_sha2(const void* value, size_t size);
  inline ::std::string* mutable_sign_sha2();
  inline ::std::string* release_sign_sha2();
  inline void set_allocated_sign_sha2(::std::string* sign_sha2);

  // optional uint32 prefilesize = 11;
  inline bool has_prefilesize() const;
  inline void clear_prefilesize();
  static const int kPrefilesizeFieldNumber = 11;
  inline ::google::protobuf::uint32 prefilesize() const;
  inline void set_prefilesize(::google::protobuf::uint32 value);

  // optional uint32 encrypt_type = 12;
  inline bool has_encrypt_type() const;
  inline void clear_encrypt_type();
  static const int kEncryptTypeFieldNumber = 12;
  inline ::google::protobuf::uint32 encrypt_type() const;
  inline void set_encrypt_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.UpgradeInfo)
 private:
  inline void set_has_filetype();
  inline void clear_has_filetype();
  inline void set_has_filepath();
  inline void clear_has_filepath();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_filesize();
  inline void clear_has_filesize();
  inline void set_has_md5();
  inline void clear_has_md5();
  inline void set_has_rc4();
  inline void clear_has_rc4();
  inline void set_has_sign_md5();
  inline void clear_has_sign_md5();
  inline void set_has_sha2();
  inline void clear_has_sha2();
  inline void set_has_aes128();
  inline void clear_has_aes128();
  inline void set_has_sign_sha2();
  inline void clear_has_sign_sha2();
  inline void set_has_prefilesize();
  inline void clear_has_prefilesize();
  inline void set_has_encrypt_type();
  inline void clear_has_encrypt_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* filetype_;
  ::std::string* filepath_;
  ::std::string* version_;
  ::std::string* md5_;
  ::std::string* rc4_;
  ::std::string* sign_md5_;
  ::google::protobuf::uint32 filesize_;
  ::google::protobuf::uint32 prefilesize_;
  ::std::string* sha2_;
  ::std::string* aes128_;
  ::std::string* sign_sha2_;
  ::google::protobuf::uint32 encrypt_type_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static UpgradeInfo* default_instance_;
};
// -------------------------------------------------------------------

class LoginReq : public ::google::protobuf::Message {
 public:
  LoginReq();
  virtual ~LoginReq();

  LoginReq(const LoginReq& from);

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginReq& default_instance();

  void Swap(LoginReq* other);

  // implements Message ----------------------------------------------

  LoginReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginReq& from);
  void MergeFrom(const LoginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string tcu_device_sn = 1;
  inline bool has_tcu_device_sn() const;
  inline void clear_tcu_device_sn();
  static const int kTcuDeviceSnFieldNumber = 1;
  inline const ::std::string& tcu_device_sn() const;
  inline void set_tcu_device_sn(const ::std::string& value);
  inline void set_tcu_device_sn(const char* value);
  inline void set_tcu_device_sn(const char* value, size_t size);
  inline ::std::string* mutable_tcu_device_sn();
  inline ::std::string* release_tcu_device_sn();
  inline void set_allocated_tcu_device_sn(::std::string* tcu_device_sn);

  // required string da_device_sn = 2;
  inline bool has_da_device_sn() const;
  inline void clear_da_device_sn();
  static const int kDaDeviceSnFieldNumber = 2;
  inline const ::std::string& da_device_sn() const;
  inline void set_da_device_sn(const ::std::string& value);
  inline void set_da_device_sn(const char* value);
  inline void set_da_device_sn(const char* value, size_t size);
  inline ::std::string* mutable_da_device_sn();
  inline ::std::string* release_da_device_sn();
  inline void set_allocated_da_device_sn(::std::string* da_device_sn);

  // required string vin = 3;
  inline bool has_vin() const;
  inline void clear_vin();
  static const int kVinFieldNumber = 3;
  inline const ::std::string& vin() const;
  inline void set_vin(const ::std::string& value);
  inline void set_vin(const char* value);
  inline void set_vin(const char* value, size_t size);
  inline ::std::string* mutable_vin();
  inline ::std::string* release_vin();
  inline void set_allocated_vin(::std::string* vin);

  // required string iccid = 4;
  inline bool has_iccid() const;
  inline void clear_iccid();
  static const int kIccidFieldNumber = 4;
  inline const ::std::string& iccid() const;
  inline void set_iccid(const ::std::string& value);
  inline void set_iccid(const char* value);
  inline void set_iccid(const char* value, size_t size);
  inline ::std::string* mutable_iccid();
  inline ::std::string* release_iccid();
  inline void set_allocated_iccid(::std::string* iccid);

  // required string imsi = 5;
  inline bool has_imsi() const;
  inline void clear_imsi();
  static const int kImsiFieldNumber = 5;
  inline const ::std::string& imsi() const;
  inline void set_imsi(const ::std::string& value);
  inline void set_imsi(const char* value);
  inline void set_imsi(const char* value, size_t size);
  inline ::std::string* mutable_imsi();
  inline ::std::string* release_imsi();
  inline void set_allocated_imsi(::std::string* imsi);

  // required string imei = 6;
  inline bool has_imei() const;
  inline void clear_imei();
  static const int kImeiFieldNumber = 6;
  inline const ::std::string& imei() const;
  inline void set_imei(const ::std::string& value);
  inline void set_imei(const char* value);
  inline void set_imei(const char* value, size_t size);
  inline ::std::string* mutable_imei();
  inline ::std::string* release_imei();
  inline void set_allocated_imei(::std::string* imei);

  // required string software_version = 7;
  inline bool has_software_version() const;
  inline void clear_software_version();
  static const int kSoftwareVersionFieldNumber = 7;
  inline const ::std::string& software_version() const;
  inline void set_software_version(const ::std::string& value);
  inline void set_software_version(const char* value);
  inline void set_software_version(const char* value, size_t size);
  inline ::std::string* mutable_software_version();
  inline ::std::string* release_software_version();
  inline void set_allocated_software_version(::std::string* software_version);

  // required string hardware_version = 8;
  inline bool has_hardware_version() const;
  inline void clear_hardware_version();
  static const int kHardwareVersionFieldNumber = 8;
  inline const ::std::string& hardware_version() const;
  inline void set_hardware_version(const ::std::string& value);
  inline void set_hardware_version(const char* value);
  inline void set_hardware_version(const char* value, size_t size);
  inline ::std::string* mutable_hardware_version();
  inline ::std::string* release_hardware_version();
  inline void set_allocated_hardware_version(::std::string* hardware_version);

  // required uint32 time_stamp = 9;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 9;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // optional string g4_version = 10;
  inline bool has_g4_version() const;
  inline void clear_g4_version();
  static const int kG4VersionFieldNumber = 10;
  inline const ::std::string& g4_version() const;
  inline void set_g4_version(const ::std::string& value);
  inline void set_g4_version(const char* value);
  inline void set_g4_version(const char* value, size_t size);
  inline ::std::string* mutable_g4_version();
  inline ::std::string* release_g4_version();
  inline void set_allocated_g4_version(::std::string* g4_version);

  // optional string vehicle_type = 11;
  inline bool has_vehicle_type() const;
  inline void clear_vehicle_type();
  static const int kVehicleTypeFieldNumber = 11;
  inline const ::std::string& vehicle_type() const;
  inline void set_vehicle_type(const ::std::string& value);
  inline void set_vehicle_type(const char* value);
  inline void set_vehicle_type(const char* value, size_t size);
  inline ::std::string* mutable_vehicle_type();
  inline ::std::string* release_vehicle_type();
  inline void set_allocated_vehicle_type(::std::string* vehicle_type);

  // optional bool upgrading = 12;
  inline bool has_upgrading() const;
  inline void clear_upgrading();
  static const int kUpgradingFieldNumber = 12;
  inline bool upgrading() const;
  inline void set_upgrading(bool value);

  // optional bool bcm_reg_status = 13;
  inline bool has_bcm_reg_status() const;
  inline void clear_bcm_reg_status();
  static const int kBcmRegStatusFieldNumber = 13;
  inline bool bcm_reg_status() const;
  inline void set_bcm_reg_status(bool value);

  // optional uint32 ota_algrithom = 14;
  inline bool has_ota_algrithom() const;
  inline void clear_ota_algrithom();
  static const int kOtaAlgrithomFieldNumber = 14;
  inline ::google::protobuf::uint32 ota_algrithom() const;
  inline void set_ota_algrithom(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.LoginReq)
 private:
  inline void set_has_tcu_device_sn();
  inline void clear_has_tcu_device_sn();
  inline void set_has_da_device_sn();
  inline void clear_has_da_device_sn();
  inline void set_has_vin();
  inline void clear_has_vin();
  inline void set_has_iccid();
  inline void clear_has_iccid();
  inline void set_has_imsi();
  inline void clear_has_imsi();
  inline void set_has_imei();
  inline void clear_has_imei();
  inline void set_has_software_version();
  inline void clear_has_software_version();
  inline void set_has_hardware_version();
  inline void clear_has_hardware_version();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_g4_version();
  inline void clear_has_g4_version();
  inline void set_has_vehicle_type();
  inline void clear_has_vehicle_type();
  inline void set_has_upgrading();
  inline void clear_has_upgrading();
  inline void set_has_bcm_reg_status();
  inline void clear_has_bcm_reg_status();
  inline void set_has_ota_algrithom();
  inline void clear_has_ota_algrithom();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* tcu_device_sn_;
  ::std::string* da_device_sn_;
  ::std::string* vin_;
  ::std::string* iccid_;
  ::std::string* imsi_;
  ::std::string* imei_;
  ::std::string* software_version_;
  ::std::string* hardware_version_;
  ::std::string* g4_version_;
  ::std::string* vehicle_type_;
  ::google::protobuf::uint32 time_stamp_;
  bool upgrading_;
  bool bcm_reg_status_;
  ::google::protobuf::uint32 ota_algrithom_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static LoginReq* default_instance_;
};
// -------------------------------------------------------------------

class LoginRsp : public ::google::protobuf::Message {
 public:
  LoginRsp();
  virtual ~LoginRsp();

  LoginRsp(const LoginRsp& from);

  inline LoginRsp& operator=(const LoginRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRsp& default_instance();

  void Swap(LoginRsp* other);

  // implements Message ----------------------------------------------

  LoginRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRsp& from);
  void MergeFrom(const LoginRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errcode() const;
  inline void set_errcode(::google::protobuf::uint32 value);

  // required uint32 time_stamp = 2;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 2;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // repeated .zna.protocol.UpgradeInfo upgradeinfo = 3;
  inline int upgradeinfo_size() const;
  inline void clear_upgradeinfo();
  static const int kUpgradeinfoFieldNumber = 3;
  inline const ::zna::protocol::UpgradeInfo& upgradeinfo(int index) const;
  inline ::zna::protocol::UpgradeInfo* mutable_upgradeinfo(int index);
  inline ::zna::protocol::UpgradeInfo* add_upgradeinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::zna::protocol::UpgradeInfo >&
      upgradeinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::zna::protocol::UpgradeInfo >*
      mutable_upgradeinfo();

  // @@protoc_insertion_point(class_scope:zna.protocol.LoginRsp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 errcode_;
  ::google::protobuf::uint32 time_stamp_;
  ::google::protobuf::RepeatedPtrField< ::zna::protocol::UpgradeInfo > upgradeinfo_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static LoginRsp* default_instance_;
};
// -------------------------------------------------------------------

class HeartbeatReq : public ::google::protobuf::Message {
 public:
  HeartbeatReq();
  virtual ~HeartbeatReq();

  HeartbeatReq(const HeartbeatReq& from);

  inline HeartbeatReq& operator=(const HeartbeatReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatReq& default_instance();

  void Swap(HeartbeatReq* other);

  // implements Message ----------------------------------------------

  HeartbeatReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartbeatReq& from);
  void MergeFrom(const HeartbeatReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 time_stamp = 1;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 1;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.HeartbeatReq)
 private:
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 time_stamp_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static HeartbeatReq* default_instance_;
};
// -------------------------------------------------------------------

class HeartbeatRsp : public ::google::protobuf::Message {
 public:
  HeartbeatRsp();
  virtual ~HeartbeatRsp();

  HeartbeatRsp(const HeartbeatRsp& from);

  inline HeartbeatRsp& operator=(const HeartbeatRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatRsp& default_instance();

  void Swap(HeartbeatRsp* other);

  // implements Message ----------------------------------------------

  HeartbeatRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartbeatRsp& from);
  void MergeFrom(const HeartbeatRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errcode() const;
  inline void set_errcode(::google::protobuf::uint32 value);

  // required uint32 time_stamp = 2;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 2;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.HeartbeatRsp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 errcode_;
  ::google::protobuf::uint32 time_stamp_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static HeartbeatRsp* default_instance_;
};
// -------------------------------------------------------------------

class SendRSAReq : public ::google::protobuf::Message {
 public:
  SendRSAReq();
  virtual ~SendRSAReq();

  SendRSAReq(const SendRSAReq& from);

  inline SendRSAReq& operator=(const SendRSAReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendRSAReq& default_instance();

  void Swap(SendRSAReq* other);

  // implements Message ----------------------------------------------

  SendRSAReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendRSAReq& from);
  void MergeFrom(const SendRSAReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 N_len = 1;
  inline bool has_n_len() const;
  inline void clear_n_len();
  static const int kNLenFieldNumber = 1;
  inline ::google::protobuf::uint32 n_len() const;
  inline void set_n_len(::google::protobuf::uint32 value);

  // required string N_string = 2;
  inline bool has_n_string() const;
  inline void clear_n_string();
  static const int kNStringFieldNumber = 2;
  inline const ::std::string& n_string() const;
  inline void set_n_string(const ::std::string& value);
  inline void set_n_string(const char* value);
  inline void set_n_string(const char* value, size_t size);
  inline ::std::string* mutable_n_string();
  inline ::std::string* release_n_string();
  inline void set_allocated_n_string(::std::string* n_string);

  // required uint32 E1_len = 3;
  inline bool has_e1_len() const;
  inline void clear_e1_len();
  static const int kE1LenFieldNumber = 3;
  inline ::google::protobuf::uint32 e1_len() const;
  inline void set_e1_len(::google::protobuf::uint32 value);

  // required string E1_string = 4;
  inline bool has_e1_string() const;
  inline void clear_e1_string();
  static const int kE1StringFieldNumber = 4;
  inline const ::std::string& e1_string() const;
  inline void set_e1_string(const ::std::string& value);
  inline void set_e1_string(const char* value);
  inline void set_e1_string(const char* value, size_t size);
  inline ::std::string* mutable_e1_string();
  inline ::std::string* release_e1_string();
  inline void set_allocated_e1_string(::std::string* e1_string);

  // required uint32 time_stamp = 5;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 5;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.SendRSAReq)
 private:
  inline void set_has_n_len();
  inline void clear_has_n_len();
  inline void set_has_n_string();
  inline void clear_has_n_string();
  inline void set_has_e1_len();
  inline void clear_has_e1_len();
  inline void set_has_e1_string();
  inline void clear_has_e1_string();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* n_string_;
  ::google::protobuf::uint32 n_len_;
  ::google::protobuf::uint32 e1_len_;
  ::std::string* e1_string_;
  ::google::protobuf::uint32 time_stamp_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static SendRSAReq* default_instance_;
};
// -------------------------------------------------------------------

class SendRC4Rsp : public ::google::protobuf::Message {
 public:
  SendRC4Rsp();
  virtual ~SendRC4Rsp();

  SendRC4Rsp(const SendRC4Rsp& from);

  inline SendRC4Rsp& operator=(const SendRC4Rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendRC4Rsp& default_instance();

  void Swap(SendRC4Rsp* other);

  // implements Message ----------------------------------------------

  SendRC4Rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendRC4Rsp& from);
  void MergeFrom(const SendRC4Rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errcode() const;
  inline void set_errcode(::google::protobuf::uint32 value);

  // required uint32 serial_number = 2;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 2;
  inline ::google::protobuf::uint32 serial_number() const;
  inline void set_serial_number(::google::protobuf::uint32 value);

  // required uint32 time_stamp = 3;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 3;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.SendRC4Rsp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_serial_number();
  inline void clear_has_serial_number();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 errcode_;
  ::google::protobuf::uint32 serial_number_;
  ::google::protobuf::uint32 time_stamp_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static SendRC4Rsp* default_instance_;
};
// -------------------------------------------------------------------

class SetParameterRsp : public ::google::protobuf::Message {
 public:
  SetParameterRsp();
  virtual ~SetParameterRsp();

  SetParameterRsp(const SetParameterRsp& from);

  inline SetParameterRsp& operator=(const SetParameterRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetParameterRsp& default_instance();

  void Swap(SetParameterRsp* other);

  // implements Message ----------------------------------------------

  SetParameterRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetParameterRsp& from);
  void MergeFrom(const SetParameterRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errcode() const;
  inline void set_errcode(::google::protobuf::uint32 value);

  // required uint32 time_stamp = 2;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 2;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.SetParameterRsp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 errcode_;
  ::google::protobuf::uint32 time_stamp_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static SetParameterRsp* default_instance_;
};
// -------------------------------------------------------------------

class SetParameterReq : public ::google::protobuf::Message {
 public:
  SetParameterReq();
  virtual ~SetParameterReq();

  SetParameterReq(const SetParameterReq& from);

  inline SetParameterReq& operator=(const SetParameterReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetParameterReq& default_instance();

  void Swap(SetParameterReq* other);

  // implements Message ----------------------------------------------

  SetParameterReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SetParameterReq& from);
  void MergeFrom(const SetParameterReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 local_storage_cycle = 1;
  inline bool has_local_storage_cycle() const;
  inline void clear_local_storage_cycle();
  static const int kLocalStorageCycleFieldNumber = 1;
  inline ::google::protobuf::uint32 local_storage_cycle() const;
  inline void set_local_storage_cycle(::google::protobuf::uint32 value);

  // required uint32 upload_data_cycle_normal = 2;
  inline bool has_upload_data_cycle_normal() const;
  inline void clear_upload_data_cycle_normal();
  static const int kUploadDataCycleNormalFieldNumber = 2;
  inline ::google::protobuf::uint32 upload_data_cycle_normal() const;
  inline void set_upload_data_cycle_normal(::google::protobuf::uint32 value);

  // required uint32 upload_GPS_cycle_normal = 3;
  inline bool has_upload_gps_cycle_normal() const;
  inline void clear_upload_gps_cycle_normal();
  static const int kUploadGPSCycleNormalFieldNumber = 3;
  inline ::google::protobuf::uint32 upload_gps_cycle_normal() const;
  inline void set_upload_gps_cycle_normal(::google::protobuf::uint32 value);

  // required uint32 upload_data_cycle_alarm = 4;
  inline bool has_upload_data_cycle_alarm() const;
  inline void clear_upload_data_cycle_alarm();
  static const int kUploadDataCycleAlarmFieldNumber = 4;
  inline ::google::protobuf::uint32 upload_data_cycle_alarm() const;
  inline void set_upload_data_cycle_alarm(::google::protobuf::uint32 value);

  // required uint32 upload_GPS_cycle_alarm = 5;
  inline bool has_upload_gps_cycle_alarm() const;
  inline void clear_upload_gps_cycle_alarm();
  static const int kUploadGPSCycleAlarmFieldNumber = 5;
  inline ::google::protobuf::uint32 upload_gps_cycle_alarm() const;
  inline void set_upload_gps_cycle_alarm(::google::protobuf::uint32 value);

  // optional uint32 heartbeat_cycle = 6;
  inline bool has_heartbeat_cycle() const;
  inline void clear_heartbeat_cycle();
  static const int kHeartbeatCycleFieldNumber = 6;
  inline ::google::protobuf::uint32 heartbeat_cycle() const;
  inline void set_heartbeat_cycle(::google::protobuf::uint32 value);

  // optional uint32 server_response_timeout = 7;
  inline bool has_server_response_timeout() const;
  inline void clear_server_response_timeout();
  static const int kServerResponseTimeoutFieldNumber = 7;
  inline ::google::protobuf::uint32 server_response_timeout() const;
  inline void set_server_response_timeout(::google::protobuf::uint32 value);

  // optional uint32 box_response_timeout = 8;
  inline bool has_box_response_timeout() const;
  inline void clear_box_response_timeout();
  static const int kBoxResponseTimeoutFieldNumber = 8;
  inline ::google::protobuf::uint32 box_response_timeout() const;
  inline void set_box_response_timeout(::google::protobuf::uint32 value);

  // optional bool FlowControlSwitch = 9;
  inline bool has_flowcontrolswitch() const;
  inline void clear_flowcontrolswitch();
  static const int kFlowControlSwitchFieldNumber = 9;
  inline bool flowcontrolswitch() const;
  inline void set_flowcontrolswitch(bool value);

  // optional uint32 GPSconversion = 10;
  inline bool has_gpsconversion() const;
  inline void clear_gpsconversion();
  static const int kGPSconversionFieldNumber = 10;
  inline ::google::protobuf::uint32 gpsconversion() const;
  inline void set_gpsconversion(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.SetParameterReq)
 private:
  inline void set_has_local_storage_cycle();
  inline void clear_has_local_storage_cycle();
  inline void set_has_upload_data_cycle_normal();
  inline void clear_has_upload_data_cycle_normal();
  inline void set_has_upload_gps_cycle_normal();
  inline void clear_has_upload_gps_cycle_normal();
  inline void set_has_upload_data_cycle_alarm();
  inline void clear_has_upload_data_cycle_alarm();
  inline void set_has_upload_gps_cycle_alarm();
  inline void clear_has_upload_gps_cycle_alarm();
  inline void set_has_heartbeat_cycle();
  inline void clear_has_heartbeat_cycle();
  inline void set_has_server_response_timeout();
  inline void clear_has_server_response_timeout();
  inline void set_has_box_response_timeout();
  inline void clear_has_box_response_timeout();
  inline void set_has_flowcontrolswitch();
  inline void clear_has_flowcontrolswitch();
  inline void set_has_gpsconversion();
  inline void clear_has_gpsconversion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 local_storage_cycle_;
  ::google::protobuf::uint32 upload_data_cycle_normal_;
  ::google::protobuf::uint32 upload_gps_cycle_normal_;
  ::google::protobuf::uint32 upload_data_cycle_alarm_;
  ::google::protobuf::uint32 upload_gps_cycle_alarm_;
  ::google::protobuf::uint32 heartbeat_cycle_;
  ::google::protobuf::uint32 server_response_timeout_;
  ::google::protobuf::uint32 box_response_timeout_;
  bool flowcontrolswitch_;
  ::google::protobuf::uint32 gpsconversion_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static SetParameterReq* default_instance_;
};
// -------------------------------------------------------------------

class GetParameterRsp : public ::google::protobuf::Message {
 public:
  GetParameterRsp();
  virtual ~GetParameterRsp();

  GetParameterRsp(const GetParameterRsp& from);

  inline GetParameterRsp& operator=(const GetParameterRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetParameterRsp& default_instance();

  void Swap(GetParameterRsp* other);

  // implements Message ----------------------------------------------

  GetParameterRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetParameterRsp& from);
  void MergeFrom(const GetParameterRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errcode() const;
  inline void set_errcode(::google::protobuf::uint32 value);

  // required uint32 local_storage_cycle = 2;
  inline bool has_local_storage_cycle() const;
  inline void clear_local_storage_cycle();
  static const int kLocalStorageCycleFieldNumber = 2;
  inline ::google::protobuf::uint32 local_storage_cycle() const;
  inline void set_local_storage_cycle(::google::protobuf::uint32 value);

  // required uint32 upload_data_cycle_normal = 3;
  inline bool has_upload_data_cycle_normal() const;
  inline void clear_upload_data_cycle_normal();
  static const int kUploadDataCycleNormalFieldNumber = 3;
  inline ::google::protobuf::uint32 upload_data_cycle_normal() const;
  inline void set_upload_data_cycle_normal(::google::protobuf::uint32 value);

  // required uint32 upload_GPS_cycle_normal = 4;
  inline bool has_upload_gps_cycle_normal() const;
  inline void clear_upload_gps_cycle_normal();
  static const int kUploadGPSCycleNormalFieldNumber = 4;
  inline ::google::protobuf::uint32 upload_gps_cycle_normal() const;
  inline void set_upload_gps_cycle_normal(::google::protobuf::uint32 value);

  // required uint32 upload_data_cycle_alarm = 5;
  inline bool has_upload_data_cycle_alarm() const;
  inline void clear_upload_data_cycle_alarm();
  static const int kUploadDataCycleAlarmFieldNumber = 5;
  inline ::google::protobuf::uint32 upload_data_cycle_alarm() const;
  inline void set_upload_data_cycle_alarm(::google::protobuf::uint32 value);

  // required uint32 upload_GPS_cycle_alarm = 6;
  inline bool has_upload_gps_cycle_alarm() const;
  inline void clear_upload_gps_cycle_alarm();
  static const int kUploadGPSCycleAlarmFieldNumber = 6;
  inline ::google::protobuf::uint32 upload_gps_cycle_alarm() const;
  inline void set_upload_gps_cycle_alarm(::google::protobuf::uint32 value);

  // required uint32 heartbeat_cycle = 7;
  inline bool has_heartbeat_cycle() const;
  inline void clear_heartbeat_cycle();
  static const int kHeartbeatCycleFieldNumber = 7;
  inline ::google::protobuf::uint32 heartbeat_cycle() const;
  inline void set_heartbeat_cycle(::google::protobuf::uint32 value);

  // required uint32 server_response_timeout = 8;
  inline bool has_server_response_timeout() const;
  inline void clear_server_response_timeout();
  static const int kServerResponseTimeoutFieldNumber = 8;
  inline ::google::protobuf::uint32 server_response_timeout() const;
  inline void set_server_response_timeout(::google::protobuf::uint32 value);

  // required uint32 box_response_timeout = 9;
  inline bool has_box_response_timeout() const;
  inline void clear_box_response_timeout();
  static const int kBoxResponseTimeoutFieldNumber = 9;
  inline ::google::protobuf::uint32 box_response_timeout() const;
  inline void set_box_response_timeout(::google::protobuf::uint32 value);

  // required string firmware_version = 10;
  inline bool has_firmware_version() const;
  inline void clear_firmware_version();
  static const int kFirmwareVersionFieldNumber = 10;
  inline const ::std::string& firmware_version() const;
  inline void set_firmware_version(const ::std::string& value);
  inline void set_firmware_version(const char* value);
  inline void set_firmware_version(const char* value, size_t size);
  inline ::std::string* mutable_firmware_version();
  inline ::std::string* release_firmware_version();
  inline void set_allocated_firmware_version(::std::string* firmware_version);

  // required string hardware_version = 11;
  inline bool has_hardware_version() const;
  inline void clear_hardware_version();
  static const int kHardwareVersionFieldNumber = 11;
  inline const ::std::string& hardware_version() const;
  inline void set_hardware_version(const ::std::string& value);
  inline void set_hardware_version(const char* value);
  inline void set_hardware_version(const char* value, size_t size);
  inline ::std::string* mutable_hardware_version();
  inline ::std::string* release_hardware_version();
  inline void set_allocated_hardware_version(::std::string* hardware_version);

  // required uint32 time_stamp = 12;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 12;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.GetParameterRsp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_local_storage_cycle();
  inline void clear_has_local_storage_cycle();
  inline void set_has_upload_data_cycle_normal();
  inline void clear_has_upload_data_cycle_normal();
  inline void set_has_upload_gps_cycle_normal();
  inline void clear_has_upload_gps_cycle_normal();
  inline void set_has_upload_data_cycle_alarm();
  inline void clear_has_upload_data_cycle_alarm();
  inline void set_has_upload_gps_cycle_alarm();
  inline void clear_has_upload_gps_cycle_alarm();
  inline void set_has_heartbeat_cycle();
  inline void clear_has_heartbeat_cycle();
  inline void set_has_server_response_timeout();
  inline void clear_has_server_response_timeout();
  inline void set_has_box_response_timeout();
  inline void clear_has_box_response_timeout();
  inline void set_has_firmware_version();
  inline void clear_has_firmware_version();
  inline void set_has_hardware_version();
  inline void clear_has_hardware_version();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 errcode_;
  ::google::protobuf::uint32 local_storage_cycle_;
  ::google::protobuf::uint32 upload_data_cycle_normal_;
  ::google::protobuf::uint32 upload_gps_cycle_normal_;
  ::google::protobuf::uint32 upload_data_cycle_alarm_;
  ::google::protobuf::uint32 upload_gps_cycle_alarm_;
  ::google::protobuf::uint32 heartbeat_cycle_;
  ::google::protobuf::uint32 server_response_timeout_;
  ::std::string* firmware_version_;
  ::google::protobuf::uint32 box_response_timeout_;
  ::google::protobuf::uint32 time_stamp_;
  ::std::string* hardware_version_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static GetParameterRsp* default_instance_;
};
// -------------------------------------------------------------------

class GetParameterReq : public ::google::protobuf::Message {
 public:
  GetParameterReq();
  virtual ~GetParameterReq();

  GetParameterReq(const GetParameterReq& from);

  inline GetParameterReq& operator=(const GetParameterReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetParameterReq& default_instance();

  void Swap(GetParameterReq* other);

  // implements Message ----------------------------------------------

  GetParameterReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetParameterReq& from);
  void MergeFrom(const GetParameterReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 time_stamp = 1;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 1;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.GetParameterReq)
 private:
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 time_stamp_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static GetParameterReq* default_instance_;
};
// -------------------------------------------------------------------

class ECM_Info : public ::google::protobuf::Message {
 public:
  ECM_Info();
  virtual ~ECM_Info();

  ECM_Info(const ECM_Info& from);

  inline ECM_Info& operator=(const ECM_Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ECM_Info& default_instance();

  void Swap(ECM_Info* other);

  // implements Message ----------------------------------------------

  ECM_Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ECM_Info& from);
  void MergeFrom(const ECM_Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 EngineRPM = 1;
  inline bool has_enginerpm() const;
  inline void clear_enginerpm();
  static const int kEngineRPMFieldNumber = 1;
  inline ::google::protobuf::uint32 enginerpm() const;
  inline void set_enginerpm(::google::protobuf::uint32 value);

  // optional uint32 EngineStatus = 4;
  inline bool has_enginestatus() const;
  inline void clear_enginestatus();
  static const int kEngineStatusFieldNumber = 4;
  inline ::google::protobuf::uint32 enginestatus() const;
  inline void set_enginestatus(::google::protobuf::uint32 value);

  // optional uint32 EngineCoolantTemp = 5;
  inline bool has_enginecoolanttemp() const;
  inline void clear_enginecoolanttemp();
  static const int kEngineCoolantTempFieldNumber = 5;
  inline ::google::protobuf::uint32 enginecoolanttemp() const;
  inline void set_enginecoolanttemp(::google::protobuf::uint32 value);

  // optional uint32 MILLamp = 21;
  inline bool has_millamp() const;
  inline void clear_millamp();
  static const int kMILLampFieldNumber = 21;
  inline ::google::protobuf::uint32 millamp() const;
  inline void set_millamp(::google::protobuf::uint32 value);

  // optional uint32 SVSLamp = 22;
  inline bool has_svslamp() const;
  inline void clear_svslamp();
  static const int kSVSLampFieldNumber = 22;
  inline ::google::protobuf::uint32 svslamp() const;
  inline void set_svslamp(::google::protobuf::uint32 value);

  // optional uint32 OilPress_Lamp = 23;
  inline bool has_oilpress_lamp() const;
  inline void clear_oilpress_lamp();
  static const int kOilPressLampFieldNumber = 23;
  inline ::google::protobuf::uint32 oilpress_lamp() const;
  inline void set_oilpress_lamp(::google::protobuf::uint32 value);

  // optional uint32 UreaLamp = 24;
  inline bool has_urealamp() const;
  inline void clear_urealamp();
  static const int kUreaLampFieldNumber = 24;
  inline ::google::protobuf::uint32 urealamp() const;
  inline void set_urealamp(::google::protobuf::uint32 value);

  // optional bool Filterwater_Det = 25;
  inline bool has_filterwater_det() const;
  inline void clear_filterwater_det();
  static const int kFilterwaterDetFieldNumber = 25;
  inline bool filterwater_det() const;
  inline void set_filterwater_det(bool value);

  // optional bool BatteryCharge_Sts = 26;
  inline bool has_batterycharge_sts() const;
  inline void clear_batterycharge_sts();
  static const int kBatteryChargeStsFieldNumber = 26;
  inline bool batterycharge_sts() const;
  inline void set_batterycharge_sts(bool value);

  // @@protoc_insertion_point(class_scope:zna.protocol.ECM_Info)
 private:
  inline void set_has_enginerpm();
  inline void clear_has_enginerpm();
  inline void set_has_enginestatus();
  inline void clear_has_enginestatus();
  inline void set_has_enginecoolanttemp();
  inline void clear_has_enginecoolanttemp();
  inline void set_has_millamp();
  inline void clear_has_millamp();
  inline void set_has_svslamp();
  inline void clear_has_svslamp();
  inline void set_has_oilpress_lamp();
  inline void clear_has_oilpress_lamp();
  inline void set_has_urealamp();
  inline void clear_has_urealamp();
  inline void set_has_filterwater_det();
  inline void clear_has_filterwater_det();
  inline void set_has_batterycharge_sts();
  inline void clear_has_batterycharge_sts();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 enginerpm_;
  ::google::protobuf::uint32 enginestatus_;
  ::google::protobuf::uint32 enginecoolanttemp_;
  ::google::protobuf::uint32 millamp_;
  ::google::protobuf::uint32 svslamp_;
  ::google::protobuf::uint32 oilpress_lamp_;
  ::google::protobuf::uint32 urealamp_;
  bool filterwater_det_;
  bool batterycharge_sts_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static ECM_Info* default_instance_;
};
// -------------------------------------------------------------------

class METER_Info : public ::google::protobuf::Message {
 public:
  METER_Info();
  virtual ~METER_Info();

  METER_Info(const METER_Info& from);

  inline METER_Info& operator=(const METER_Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const METER_Info& default_instance();

  void Swap(METER_Info* other);

  // implements Message ----------------------------------------------

  METER_Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const METER_Info& from);
  void MergeFrom(const METER_Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 Average_Fuel_Economy = 2;
  inline bool has_average_fuel_economy() const;
  inline void clear_average_fuel_economy();
  static const int kAverageFuelEconomyFieldNumber = 2;
  inline ::google::protobuf::uint32 average_fuel_economy() const;
  inline void set_average_fuel_economy(::google::protobuf::uint32 value);

  // optional uint32 Distance_to_empty = 3;
  inline bool has_distance_to_empty() const;
  inline void clear_distance_to_empty();
  static const int kDistanceToEmptyFieldNumber = 3;
  inline ::google::protobuf::uint32 distance_to_empty() const;
  inline void set_distance_to_empty(::google::protobuf::uint32 value);

  // optional uint32 Distance_Totalizer = 4;
  inline bool has_distance_totalizer() const;
  inline void clear_distance_totalizer();
  static const int kDistanceTotalizerFieldNumber = 4;
  inline ::google::protobuf::uint32 distance_totalizer() const;
  inline void set_distance_totalizer(::google::protobuf::uint32 value);

  // optional uint32 Fuel_Remain = 5;
  inline bool has_fuel_remain() const;
  inline void clear_fuel_remain();
  static const int kFuelRemainFieldNumber = 5;
  inline ::google::protobuf::uint32 fuel_remain() const;
  inline void set_fuel_remain(::google::protobuf::uint32 value);

  // optional bool TotalOdo_Valid = 13;
  inline bool has_totalodo_valid() const;
  inline void clear_totalodo_valid();
  static const int kTotalOdoValidFieldNumber = 13;
  inline bool totalodo_valid() const;
  inline void set_totalodo_valid(bool value);

  // optional bool OilPres = 14;
  inline bool has_oilpres() const;
  inline void clear_oilpres();
  static const int kOilPresFieldNumber = 14;
  inline bool oilpres() const;
  inline void set_oilpres(bool value);

  // optional uint32 BrakeFailure = 15;
  inline bool has_brakefailure() const;
  inline void clear_brakefailure();
  static const int kBrakeFailureFieldNumber = 15;
  inline ::google::protobuf::uint32 brakefailure() const;
  inline void set_brakefailure(::google::protobuf::uint32 value);

  // optional uint32 InstandFuel = 16;
  inline bool has_instandfuel() const;
  inline void clear_instandfuel();
  static const int kInstandFuelFieldNumber = 16;
  inline ::google::protobuf::uint32 instandfuel() const;
  inline void set_instandfuel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.METER_Info)
 private:
  inline void set_has_average_fuel_economy();
  inline void clear_has_average_fuel_economy();
  inline void set_has_distance_to_empty();
  inline void clear_has_distance_to_empty();
  inline void set_has_distance_totalizer();
  inline void clear_has_distance_totalizer();
  inline void set_has_fuel_remain();
  inline void clear_has_fuel_remain();
  inline void set_has_totalodo_valid();
  inline void clear_has_totalodo_valid();
  inline void set_has_oilpres();
  inline void clear_has_oilpres();
  inline void set_has_brakefailure();
  inline void clear_has_brakefailure();
  inline void set_has_instandfuel();
  inline void clear_has_instandfuel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 average_fuel_economy_;
  ::google::protobuf::uint32 distance_to_empty_;
  ::google::protobuf::uint32 distance_totalizer_;
  ::google::protobuf::uint32 fuel_remain_;
  bool totalodo_valid_;
  bool oilpres_;
  ::google::protobuf::uint32 brakefailure_;
  ::google::protobuf::uint32 instandfuel_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static METER_Info* default_instance_;
};
// -------------------------------------------------------------------

class BCM_Info : public ::google::protobuf::Message {
 public:
  BCM_Info();
  virtual ~BCM_Info();

  BCM_Info(const BCM_Info& from);

  inline BCM_Info& operator=(const BCM_Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BCM_Info& default_instance();

  void Swap(BCM_Info* other);

  // implements Message ----------------------------------------------

  BCM_Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BCM_Info& from);
  void MergeFrom(const BCM_Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool front_left_door_status = 3;
  inline bool has_front_left_door_status() const;
  inline void clear_front_left_door_status();
  static const int kFrontLeftDoorStatusFieldNumber = 3;
  inline bool front_left_door_status() const;
  inline void set_front_left_door_status(bool value);

  // optional bool front_right_door_status = 4;
  inline bool has_front_right_door_status() const;
  inline void clear_front_right_door_status();
  static const int kFrontRightDoorStatusFieldNumber = 4;
  inline bool front_right_door_status() const;
  inline void set_front_right_door_status(bool value);

  // optional bool rear_left_door_status = 5;
  inline bool has_rear_left_door_status() const;
  inline void clear_rear_left_door_status();
  static const int kRearLeftDoorStatusFieldNumber = 5;
  inline bool rear_left_door_status() const;
  inline void set_rear_left_door_status(bool value);

  // optional bool rear_right_door_status = 6;
  inline bool has_rear_right_door_status() const;
  inline void clear_rear_right_door_status();
  static const int kRearRightDoorStatusFieldNumber = 6;
  inline bool rear_right_door_status() const;
  inline void set_rear_right_door_status(bool value);

  // optional bool back_door_status = 7;
  inline bool has_back_door_status() const;
  inline void clear_back_door_status();
  static const int kBackDoorStatusFieldNumber = 7;
  inline bool back_door_status() const;
  inline void set_back_door_status(bool value);

  // optional bool back_door_locked_status = 9;
  inline bool has_back_door_locked_status() const;
  inline void clear_back_door_locked_status();
  static const int kBackDoorLockedStatusFieldNumber = 9;
  inline bool back_door_locked_status() const;
  inline void set_back_door_locked_status(bool value);

  // optional bool LowBeamRequest = 10;
  inline bool has_lowbeamrequest() const;
  inline void clear_lowbeamrequest();
  static const int kLowBeamRequestFieldNumber = 10;
  inline bool lowbeamrequest() const;
  inline void set_lowbeamrequest(bool value);

  // optional bool HighBeamRequest = 12;
  inline bool has_highbeamrequest() const;
  inline void clear_highbeamrequest();
  static const int kHighBeamRequestFieldNumber = 12;
  inline bool highbeamrequest() const;
  inline void set_highbeamrequest(bool value);

  // optional bool SWIIGK = 51;
  inline bool has_swiigk() const;
  inline void clear_swiigk();
  static const int kSWIIGKFieldNumber = 51;
  inline bool swiigk() const;
  inline void set_swiigk(bool value);

  // optional bool DoorOpen_Warning = 52;
  inline bool has_dooropen_warning() const;
  inline void clear_dooropen_warning();
  static const int kDoorOpenWarningFieldNumber = 52;
  inline bool dooropen_warning() const;
  inline void set_dooropen_warning(bool value);

  // optional bool LightOn_Warning = 53;
  inline bool has_lighton_warning() const;
  inline void clear_lighton_warning();
  static const int kLightOnWarningFieldNumber = 53;
  inline bool lighton_warning() const;
  inline void set_lighton_warning(bool value);

  // optional uint32 TPMSMIL_Req = 54;
  inline bool has_tpmsmil_req() const;
  inline void clear_tpmsmil_req();
  static const int kTPMSMILReqFieldNumber = 54;
  inline ::google::protobuf::uint32 tpmsmil_req() const;
  inline void set_tpmsmil_req(::google::protobuf::uint32 value);

  // optional bool StopLampFailSts = 55;
  inline bool has_stoplampfailsts() const;
  inline void clear_stoplampfailsts();
  static const int kStopLampFailStsFieldNumber = 55;
  inline bool stoplampfailsts() const;
  inline void set_stoplampfailsts(bool value);

  // optional bool RemoteVecSearchSts = 56;
  inline bool has_remotevecsearchsts() const;
  inline void clear_remotevecsearchsts();
  static const int kRemoteVecSearchStsFieldNumber = 56;
  inline bool remotevecsearchsts() const;
  inline void set_remotevecsearchsts(bool value);

  // optional bool DriverDoorLockSts = 57;
  inline bool has_driverdoorlocksts() const;
  inline void clear_driverdoorlocksts();
  static const int kDriverDoorLockStsFieldNumber = 57;
  inline bool driverdoorlocksts() const;
  inline void set_driverdoorlocksts(bool value);

  // optional uint32 KeyAlarmSts = 58;
  inline bool has_keyalarmsts() const;
  inline void clear_keyalarmsts();
  static const int kKeyAlarmStsFieldNumber = 58;
  inline ::google::protobuf::uint32 keyalarmsts() const;
  inline void set_keyalarmsts(::google::protobuf::uint32 value);

  // optional bool HoodStatus = 59;
  inline bool has_hoodstatus() const;
  inline void clear_hoodstatus();
  static const int kHoodStatusFieldNumber = 59;
  inline bool hoodstatus() const;
  inline void set_hoodstatus(bool value);

  // optional bool AccStatus = 60;
  inline bool has_accstatus() const;
  inline void clear_accstatus();
  static const int kAccStatusFieldNumber = 60;
  inline bool accstatus() const;
  inline void set_accstatus(bool value);

  // optional bool remote_enging_run_flag = 61;
  inline bool has_remote_enging_run_flag() const;
  inline void clear_remote_enging_run_flag();
  static const int kRemoteEngingRunFlagFieldNumber = 61;
  inline bool remote_enging_run_flag() const;
  inline void set_remote_enging_run_flag(bool value);

  // @@protoc_insertion_point(class_scope:zna.protocol.BCM_Info)
 private:
  inline void set_has_front_left_door_status();
  inline void clear_has_front_left_door_status();
  inline void set_has_front_right_door_status();
  inline void clear_has_front_right_door_status();
  inline void set_has_rear_left_door_status();
  inline void clear_has_rear_left_door_status();
  inline void set_has_rear_right_door_status();
  inline void clear_has_rear_right_door_status();
  inline void set_has_back_door_status();
  inline void clear_has_back_door_status();
  inline void set_has_back_door_locked_status();
  inline void clear_has_back_door_locked_status();
  inline void set_has_lowbeamrequest();
  inline void clear_has_lowbeamrequest();
  inline void set_has_highbeamrequest();
  inline void clear_has_highbeamrequest();
  inline void set_has_swiigk();
  inline void clear_has_swiigk();
  inline void set_has_dooropen_warning();
  inline void clear_has_dooropen_warning();
  inline void set_has_lighton_warning();
  inline void clear_has_lighton_warning();
  inline void set_has_tpmsmil_req();
  inline void clear_has_tpmsmil_req();
  inline void set_has_stoplampfailsts();
  inline void clear_has_stoplampfailsts();
  inline void set_has_remotevecsearchsts();
  inline void clear_has_remotevecsearchsts();
  inline void set_has_driverdoorlocksts();
  inline void clear_has_driverdoorlocksts();
  inline void set_has_keyalarmsts();
  inline void clear_has_keyalarmsts();
  inline void set_has_hoodstatus();
  inline void clear_has_hoodstatus();
  inline void set_has_accstatus();
  inline void clear_has_accstatus();
  inline void set_has_remote_enging_run_flag();
  inline void clear_has_remote_enging_run_flag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool front_left_door_status_;
  bool front_right_door_status_;
  bool rear_left_door_status_;
  bool rear_right_door_status_;
  bool back_door_status_;
  bool back_door_locked_status_;
  bool lowbeamrequest_;
  bool highbeamrequest_;
  bool swiigk_;
  bool dooropen_warning_;
  bool lighton_warning_;
  bool stoplampfailsts_;
  ::google::protobuf::uint32 tpmsmil_req_;
  ::google::protobuf::uint32 keyalarmsts_;
  bool remotevecsearchsts_;
  bool driverdoorlocksts_;
  bool hoodstatus_;
  bool accstatus_;
  bool remote_enging_run_flag_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static BCM_Info* default_instance_;
};
// -------------------------------------------------------------------

class ACU_Info : public ::google::protobuf::Message {
 public:
  ACU_Info();
  virtual ~ACU_Info();

  ACU_Info(const ACU_Info& from);

  inline ACU_Info& operator=(const ACU_Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ACU_Info& default_instance();

  void Swap(ACU_Info* other);

  // implements Message ----------------------------------------------

  ACU_Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ACU_Info& from);
  void MergeFrom(const ACU_Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 Airbag_Crash_Order = 1;
  inline bool has_airbag_crash_order() const;
  inline void clear_airbag_crash_order();
  static const int kAirbagCrashOrderFieldNumber = 1;
  inline ::google::protobuf::uint32 airbag_crash_order() const;
  inline void set_airbag_crash_order(::google::protobuf::uint32 value);

  // optional uint32 AirbagFail_Sts = 12;
  inline bool has_airbagfail_sts() const;
  inline void clear_airbagfail_sts();
  static const int kAirbagFailStsFieldNumber = 12;
  inline ::google::protobuf::uint32 airbagfail_sts() const;
  inline void set_airbagfail_sts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.ACU_Info)
 private:
  inline void set_has_airbag_crash_order();
  inline void clear_has_airbag_crash_order();
  inline void set_has_airbagfail_sts();
  inline void clear_has_airbagfail_sts();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 airbag_crash_order_;
  ::google::protobuf::uint32 airbagfail_sts_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static ACU_Info* default_instance_;
};
// -------------------------------------------------------------------

class ECO_Info : public ::google::protobuf::Message {
 public:
  ECO_Info();
  virtual ~ECO_Info();

  ECO_Info(const ECO_Info& from);

  inline ECO_Info& operator=(const ECO_Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ECO_Info& default_instance();

  void Swap(ECO_Info* other);

  // implements Message ----------------------------------------------

  ECO_Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ECO_Info& from);
  void MergeFrom(const ECO_Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 rapid_acceleration_count = 1;
  inline bool has_rapid_acceleration_count() const;
  inline void clear_rapid_acceleration_count();
  static const int kRapidAccelerationCountFieldNumber = 1;
  inline ::google::protobuf::uint32 rapid_acceleration_count() const;
  inline void set_rapid_acceleration_count(::google::protobuf::uint32 value);

  // optional uint32 rapid_deceleration_count = 2;
  inline bool has_rapid_deceleration_count() const;
  inline void clear_rapid_deceleration_count();
  static const int kRapidDecelerationCountFieldNumber = 2;
  inline ::google::protobuf::uint32 rapid_deceleration_count() const;
  inline void set_rapid_deceleration_count(::google::protobuf::uint32 value);

  // optional uint32 sharp_turn_count = 3;
  inline bool has_sharp_turn_count() const;
  inline void clear_sharp_turn_count();
  static const int kSharpTurnCountFieldNumber = 3;
  inline ::google::protobuf::uint32 sharp_turn_count() const;
  inline void set_sharp_turn_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.ECO_Info)
 private:
  inline void set_has_rapid_acceleration_count();
  inline void clear_has_rapid_acceleration_count();
  inline void set_has_rapid_deceleration_count();
  inline void clear_has_rapid_deceleration_count();
  inline void set_has_sharp_turn_count();
  inline void clear_has_sharp_turn_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 rapid_acceleration_count_;
  ::google::protobuf::uint32 rapid_deceleration_count_;
  ::google::protobuf::uint32 sharp_turn_count_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static ECO_Info* default_instance_;
};
// -------------------------------------------------------------------

class ALARM_Info : public ::google::protobuf::Message {
 public:
  ALARM_Info();
  virtual ~ALARM_Info();

  ALARM_Info(const ALARM_Info& from);

  inline ALARM_Info& operator=(const ALARM_Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ALARM_Info& default_instance();

  void Swap(ALARM_Info* other);

  // implements Message ----------------------------------------------

  ALARM_Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ALARM_Info& from);
  void MergeFrom(const ALARM_Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 alarm_type = 1;
  inline bool has_alarm_type() const;
  inline void clear_alarm_type();
  static const int kAlarmTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 alarm_type() const;
  inline void set_alarm_type(::google::protobuf::uint32 value);

  // optional bytes alarm_typeEx = 2;
  inline bool has_alarm_typeex() const;
  inline void clear_alarm_typeex();
  static const int kAlarmTypeExFieldNumber = 2;
  inline const ::std::string& alarm_typeex() const;
  inline void set_alarm_typeex(const ::std::string& value);
  inline void set_alarm_typeex(const char* value);
  inline void set_alarm_typeex(const void* value, size_t size);
  inline ::std::string* mutable_alarm_typeex();
  inline ::std::string* release_alarm_typeex();
  inline void set_allocated_alarm_typeex(::std::string* alarm_typeex);

  // optional uint32 Transmitter_Fail = 3;
  inline bool has_transmitter_fail() const;
  inline void clear_transmitter_fail();
  static const int kTransmitterFailFieldNumber = 3;
  inline ::google::protobuf::uint32 transmitter_fail() const;
  inline void set_transmitter_fail(::google::protobuf::uint32 value);

  // optional uint32 LowTirePressure = 4;
  inline bool has_lowtirepressure() const;
  inline void clear_lowtirepressure();
  static const int kLowTirePressureFieldNumber = 4;
  inline ::google::protobuf::uint32 lowtirepressure() const;
  inline void set_lowtirepressure(::google::protobuf::uint32 value);

  // optional uint32 ZNA_P15MC = 5;
  inline bool has_zna_p15mc() const;
  inline void clear_zna_p15mc();
  static const int kZNAP15MCFieldNumber = 5;
  inline ::google::protobuf::uint32 zna_p15mc() const;
  inline void set_zna_p15mc(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.ALARM_Info)
 private:
  inline void set_has_alarm_type();
  inline void clear_has_alarm_type();
  inline void set_has_alarm_typeex();
  inline void clear_has_alarm_typeex();
  inline void set_has_transmitter_fail();
  inline void clear_has_transmitter_fail();
  inline void set_has_lowtirepressure();
  inline void clear_has_lowtirepressure();
  inline void set_has_zna_p15mc();
  inline void clear_has_zna_p15mc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* alarm_typeex_;
  ::google::protobuf::uint32 alarm_type_;
  ::google::protobuf::uint32 transmitter_fail_;
  ::google::protobuf::uint32 lowtirepressure_;
  ::google::protobuf::uint32 zna_p15mc_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static ALARM_Info* default_instance_;
};
// -------------------------------------------------------------------

class PEPS_Info : public ::google::protobuf::Message {
 public:
  PEPS_Info();
  virtual ~PEPS_Info();

  PEPS_Info(const PEPS_Info& from);

  inline PEPS_Info& operator=(const PEPS_Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PEPS_Info& default_instance();

  void Swap(PEPS_Info* other);

  // implements Message ----------------------------------------------

  PEPS_Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PEPS_Info& from);
  void MergeFrom(const PEPS_Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 RemoteFeedback_Sts = 1;
  inline bool has_remotefeedback_sts() const;
  inline void clear_remotefeedback_sts();
  static const int kRemoteFeedbackStsFieldNumber = 1;
  inline ::google::protobuf::uint32 remotefeedback_sts() const;
  inline void set_remotefeedback_sts(::google::protobuf::uint32 value);

  // optional uint32 RemotePEPS_Mode = 2;
  inline bool has_remotepeps_mode() const;
  inline void clear_remotepeps_mode();
  static const int kRemotePEPSModeFieldNumber = 2;
  inline ::google::protobuf::uint32 remotepeps_mode() const;
  inline void set_remotepeps_mode(::google::protobuf::uint32 value);

  // optional uint32 RemoteEngineRun_Cnt = 3;
  inline bool has_remoteenginerun_cnt() const;
  inline void clear_remoteenginerun_cnt();
  static const int kRemoteEngineRunCntFieldNumber = 3;
  inline ::google::protobuf::uint32 remoteenginerun_cnt() const;
  inline void set_remoteenginerun_cnt(::google::protobuf::uint32 value);

  // optional uint32 PEPS_PDU = 4;
  inline bool has_peps_pdu() const;
  inline void clear_peps_pdu();
  static const int kPEPSPDUFieldNumber = 4;
  inline ::google::protobuf::uint32 peps_pdu() const;
  inline void set_peps_pdu(::google::protobuf::uint32 value);

  // optional bool PEPS_Bluetooth = 5;
  inline bool has_peps_bluetooth() const;
  inline void clear_peps_bluetooth();
  static const int kPEPSBluetoothFieldNumber = 5;
  inline bool peps_bluetooth() const;
  inline void set_peps_bluetooth(bool value);

  // optional uint32 PEPS_MeterAlarm = 6;
  inline bool has_peps_meteralarm() const;
  inline void clear_peps_meteralarm();
  static const int kPEPSMeterAlarmFieldNumber = 6;
  inline ::google::protobuf::uint32 peps_meteralarm() const;
  inline void set_peps_meteralarm(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.PEPS_Info)
 private:
  inline void set_has_remotefeedback_sts();
  inline void clear_has_remotefeedback_sts();
  inline void set_has_remotepeps_mode();
  inline void clear_has_remotepeps_mode();
  inline void set_has_remoteenginerun_cnt();
  inline void clear_has_remoteenginerun_cnt();
  inline void set_has_peps_pdu();
  inline void clear_has_peps_pdu();
  inline void set_has_peps_bluetooth();
  inline void clear_has_peps_bluetooth();
  inline void set_has_peps_meteralarm();
  inline void clear_has_peps_meteralarm();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 remotefeedback_sts_;
  ::google::protobuf::uint32 remotepeps_mode_;
  ::google::protobuf::uint32 remoteenginerun_cnt_;
  ::google::protobuf::uint32 peps_pdu_;
  bool peps_bluetooth_;
  ::google::protobuf::uint32 peps_meteralarm_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static PEPS_Info* default_instance_;
};
// -------------------------------------------------------------------

class ESP_Info : public ::google::protobuf::Message {
 public:
  ESP_Info();
  virtual ~ESP_Info();

  ESP_Info(const ESP_Info& from);

  inline ESP_Info& operator=(const ESP_Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ESP_Info& default_instance();

  void Swap(ESP_Info* other);

  // implements Message ----------------------------------------------

  ESP_Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ESP_Info& from);
  void MergeFrom(const ESP_Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ESP_Lamp = 1;
  inline bool has_esp_lamp() const;
  inline void clear_esp_lamp();
  static const int kESPLampFieldNumber = 1;
  inline ::google::protobuf::uint32 esp_lamp() const;
  inline void set_esp_lamp(::google::protobuf::uint32 value);

  // optional uint32 ABS_Lamp = 2;
  inline bool has_abs_lamp() const;
  inline void clear_abs_lamp();
  static const int kABSLampFieldNumber = 2;
  inline ::google::protobuf::uint32 abs_lamp() const;
  inline void set_abs_lamp(::google::protobuf::uint32 value);

  // optional bool HAZ_Active = 3;
  inline bool has_haz_active() const;
  inline void clear_haz_active();
  static const int kHAZActiveFieldNumber = 3;
  inline bool haz_active() const;
  inline void set_haz_active(bool value);

  // optional bool VehicleSpeed_Valid = 4;
  inline bool has_vehiclespeed_valid() const;
  inline void clear_vehiclespeed_valid();
  static const int kVehicleSpeedValidFieldNumber = 4;
  inline bool vehiclespeed_valid() const;
  inline void set_vehiclespeed_valid(bool value);

  // optional uint32 LongAccel = 5;
  inline bool has_longaccel() const;
  inline void clear_longaccel();
  static const int kLongAccelFieldNumber = 5;
  inline ::google::protobuf::uint32 longaccel() const;
  inline void set_longaccel(::google::protobuf::uint32 value);

  // optional uint32 VehicleSpeed = 6;
  inline bool has_vehiclespeed() const;
  inline void clear_vehiclespeed();
  static const int kVehicleSpeedFieldNumber = 6;
  inline ::google::protobuf::uint32 vehiclespeed() const;
  inline void set_vehiclespeed(::google::protobuf::uint32 value);

  // optional uint32 EBD_Lamp = 7;
  inline bool has_ebd_lamp() const;
  inline void clear_ebd_lamp();
  static const int kEBDLampFieldNumber = 7;
  inline ::google::protobuf::uint32 ebd_lamp() const;
  inline void set_ebd_lamp(::google::protobuf::uint32 value);

  // optional bool ABS_Acitve = 8;
  inline bool has_abs_acitve() const;
  inline void clear_abs_acitve();
  static const int kABSAcitveFieldNumber = 8;
  inline bool abs_acitve() const;
  inline void set_abs_acitve(bool value);

  // @@protoc_insertion_point(class_scope:zna.protocol.ESP_Info)
 private:
  inline void set_has_esp_lamp();
  inline void clear_has_esp_lamp();
  inline void set_has_abs_lamp();
  inline void clear_has_abs_lamp();
  inline void set_has_haz_active();
  inline void clear_has_haz_active();
  inline void set_has_vehiclespeed_valid();
  inline void clear_has_vehiclespeed_valid();
  inline void set_has_longaccel();
  inline void clear_has_longaccel();
  inline void set_has_vehiclespeed();
  inline void clear_has_vehiclespeed();
  inline void set_has_ebd_lamp();
  inline void clear_has_ebd_lamp();
  inline void set_has_abs_acitve();
  inline void clear_has_abs_acitve();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 esp_lamp_;
  ::google::protobuf::uint32 abs_lamp_;
  ::google::protobuf::uint32 longaccel_;
  bool haz_active_;
  bool vehiclespeed_valid_;
  bool abs_acitve_;
  ::google::protobuf::uint32 vehiclespeed_;
  ::google::protobuf::uint32 ebd_lamp_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static ESP_Info* default_instance_;
};
// -------------------------------------------------------------------

class EPB_Info : public ::google::protobuf::Message {
 public:
  EPB_Info();
  virtual ~EPB_Info();

  EPB_Info(const EPB_Info& from);

  inline EPB_Info& operator=(const EPB_Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EPB_Info& default_instance();

  void Swap(EPB_Info* other);

  // implements Message ----------------------------------------------

  EPB_Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EPB_Info& from);
  void MergeFrom(const EPB_Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 EPB_FailStatus = 1;
  inline bool has_epb_failstatus() const;
  inline void clear_epb_failstatus();
  static const int kEPBFailStatusFieldNumber = 1;
  inline ::google::protobuf::uint32 epb_failstatus() const;
  inline void set_epb_failstatus(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.EPB_Info)
 private:
  inline void set_has_epb_failstatus();
  inline void clear_has_epb_failstatus();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 epb_failstatus_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static EPB_Info* default_instance_;
};
// -------------------------------------------------------------------

class TCU_Info : public ::google::protobuf::Message {
 public:
  TCU_Info();
  virtual ~TCU_Info();

  TCU_Info(const TCU_Info& from);

  inline TCU_Info& operator=(const TCU_Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TCU_Info& default_instance();

  void Swap(TCU_Info* other);

  // implements Message ----------------------------------------------

  TCU_Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TCU_Info& from);
  void MergeFrom(const TCU_Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 TCU_Fault = 1;
  inline bool has_tcu_fault() const;
  inline void clear_tcu_fault();
  static const int kTCUFaultFieldNumber = 1;
  inline ::google::protobuf::uint32 tcu_fault() const;
  inline void set_tcu_fault(::google::protobuf::uint32 value);

  // optional uint32 GearSelect_Pos = 2;
  inline bool has_gearselect_pos() const;
  inline void clear_gearselect_pos();
  static const int kGearSelectPosFieldNumber = 2;
  inline ::google::protobuf::uint32 gearselect_pos() const;
  inline void set_gearselect_pos(::google::protobuf::uint32 value);

  // optional uint32 Driving_Mode = 3;
  inline bool has_driving_mode() const;
  inline void clear_driving_mode();
  static const int kDrivingModeFieldNumber = 3;
  inline ::google::protobuf::uint32 driving_mode() const;
  inline void set_driving_mode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.TCU_Info)
 private:
  inline void set_has_tcu_fault();
  inline void clear_has_tcu_fault();
  inline void set_has_gearselect_pos();
  inline void clear_has_gearselect_pos();
  inline void set_has_driving_mode();
  inline void clear_has_driving_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 tcu_fault_;
  ::google::protobuf::uint32 gearselect_pos_;
  ::google::protobuf::uint32 driving_mode_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static TCU_Info* default_instance_;
};
// -------------------------------------------------------------------

class AWD_Info : public ::google::protobuf::Message {
 public:
  AWD_Info();
  virtual ~AWD_Info();

  AWD_Info(const AWD_Info& from);

  inline AWD_Info& operator=(const AWD_Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AWD_Info& default_instance();

  void Swap(AWD_Info* other);

  // implements Message ----------------------------------------------

  AWD_Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AWD_Info& from);
  void MergeFrom(const AWD_Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 AWD_Mode = 1;
  inline bool has_awd_mode() const;
  inline void clear_awd_mode();
  static const int kAWDModeFieldNumber = 1;
  inline ::google::protobuf::uint32 awd_mode() const;
  inline void set_awd_mode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.AWD_Info)
 private:
  inline void set_has_awd_mode();
  inline void clear_has_awd_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 awd_mode_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static AWD_Info* default_instance_;
};
// -------------------------------------------------------------------

class AC_Info : public ::google::protobuf::Message {
 public:
  AC_Info();
  virtual ~AC_Info();

  AC_Info(const AC_Info& from);

  inline AC_Info& operator=(const AC_Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AC_Info& default_instance();

  void Swap(AC_Info* other);

  // implements Message ----------------------------------------------

  AC_Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AC_Info& from);
  void MergeFrom(const AC_Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool AC_OnState = 1;
  inline bool has_ac_onstate() const;
  inline void clear_ac_onstate();
  static const int kACOnStateFieldNumber = 1;
  inline bool ac_onstate() const;
  inline void set_ac_onstate(bool value);

  // optional uint32 AirDistribution_Mode = 2;
  inline bool has_airdistribution_mode() const;
  inline void clear_airdistribution_mode();
  static const int kAirDistributionModeFieldNumber = 2;
  inline ::google::protobuf::uint32 airdistribution_mode() const;
  inline void set_airdistribution_mode(::google::protobuf::uint32 value);

  // optional uint32 ACInsideSen_Temp = 3;
  inline bool has_acinsidesen_temp() const;
  inline void clear_acinsidesen_temp();
  static const int kACInsideSenTempFieldNumber = 3;
  inline ::google::protobuf::uint32 acinsidesen_temp() const;
  inline void set_acinsidesen_temp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.AC_Info)
 private:
  inline void set_has_ac_onstate();
  inline void clear_has_ac_onstate();
  inline void set_has_airdistribution_mode();
  inline void clear_has_airdistribution_mode();
  inline void set_has_acinsidesen_temp();
  inline void clear_has_acinsidesen_temp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool ac_onstate_;
  ::google::protobuf::uint32 airdistribution_mode_;
  ::google::protobuf::uint32 acinsidesen_temp_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static AC_Info* default_instance_;
};
// -------------------------------------------------------------------

class SAS_Info : public ::google::protobuf::Message {
 public:
  SAS_Info();
  virtual ~SAS_Info();

  SAS_Info(const SAS_Info& from);

  inline SAS_Info& operator=(const SAS_Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SAS_Info& default_instance();

  void Swap(SAS_Info* other);

  // implements Message ----------------------------------------------

  SAS_Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SAS_Info& from);
  void MergeFrom(const SAS_Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 SteeringAngel = 1;
  inline bool has_steeringangel() const;
  inline void clear_steeringangel();
  static const int kSteeringAngelFieldNumber = 1;
  inline ::google::protobuf::uint32 steeringangel() const;
  inline void set_steeringangel(::google::protobuf::uint32 value);

  // optional uint32 SteeringAngel_Velocity = 2;
  inline bool has_steeringangel_velocity() const;
  inline void clear_steeringangel_velocity();
  static const int kSteeringAngelVelocityFieldNumber = 2;
  inline ::google::protobuf::uint32 steeringangel_velocity() const;
  inline void set_steeringangel_velocity(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.SAS_Info)
 private:
  inline void set_has_steeringangel();
  inline void clear_has_steeringangel();
  inline void set_has_steeringangel_velocity();
  inline void clear_has_steeringangel_velocity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 steeringangel_;
  ::google::protobuf::uint32 steeringangel_velocity_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static SAS_Info* default_instance_;
};
// -------------------------------------------------------------------

class Basic_Info : public ::google::protobuf::Message {
 public:
  Basic_Info();
  virtual ~Basic_Info();

  Basic_Info(const Basic_Info& from);

  inline Basic_Info& operator=(const Basic_Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Basic_Info& default_instance();

  void Swap(Basic_Info* other);

  // implements Message ----------------------------------------------

  Basic_Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Basic_Info& from);
  void MergeFrom(const Basic_Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .zna.protocol.ECM_Info ecm_info = 1;
  inline bool has_ecm_info() const;
  inline void clear_ecm_info();
  static const int kEcmInfoFieldNumber = 1;
  inline const ::zna::protocol::ECM_Info& ecm_info() const;
  inline ::zna::protocol::ECM_Info* mutable_ecm_info();
  inline ::zna::protocol::ECM_Info* release_ecm_info();
  inline void set_allocated_ecm_info(::zna::protocol::ECM_Info* ecm_info);

  // optional .zna.protocol.METER_Info meter_info = 3;
  inline bool has_meter_info() const;
  inline void clear_meter_info();
  static const int kMeterInfoFieldNumber = 3;
  inline const ::zna::protocol::METER_Info& meter_info() const;
  inline ::zna::protocol::METER_Info* mutable_meter_info();
  inline ::zna::protocol::METER_Info* release_meter_info();
  inline void set_allocated_meter_info(::zna::protocol::METER_Info* meter_info);

  // optional .zna.protocol.BCM_Info bcm_info = 4;
  inline bool has_bcm_info() const;
  inline void clear_bcm_info();
  static const int kBcmInfoFieldNumber = 4;
  inline const ::zna::protocol::BCM_Info& bcm_info() const;
  inline ::zna::protocol::BCM_Info* mutable_bcm_info();
  inline ::zna::protocol::BCM_Info* release_bcm_info();
  inline void set_allocated_bcm_info(::zna::protocol::BCM_Info* bcm_info);

  // optional .zna.protocol.ACU_Info acu_info = 5;
  inline bool has_acu_info() const;
  inline void clear_acu_info();
  static const int kAcuInfoFieldNumber = 5;
  inline const ::zna::protocol::ACU_Info& acu_info() const;
  inline ::zna::protocol::ACU_Info* mutable_acu_info();
  inline ::zna::protocol::ACU_Info* release_acu_info();
  inline void set_allocated_acu_info(::zna::protocol::ACU_Info* acu_info);

  // optional .zna.protocol.ECO_Info eco_info = 12;
  inline bool has_eco_info() const;
  inline void clear_eco_info();
  static const int kEcoInfoFieldNumber = 12;
  inline const ::zna::protocol::ECO_Info& eco_info() const;
  inline ::zna::protocol::ECO_Info* mutable_eco_info();
  inline ::zna::protocol::ECO_Info* release_eco_info();
  inline void set_allocated_eco_info(::zna::protocol::ECO_Info* eco_info);

  // optional .zna.protocol.ALARM_Info alarm_info = 13;
  inline bool has_alarm_info() const;
  inline void clear_alarm_info();
  static const int kAlarmInfoFieldNumber = 13;
  inline const ::zna::protocol::ALARM_Info& alarm_info() const;
  inline ::zna::protocol::ALARM_Info* mutable_alarm_info();
  inline ::zna::protocol::ALARM_Info* release_alarm_info();
  inline void set_allocated_alarm_info(::zna::protocol::ALARM_Info* alarm_info);

  // optional .zna.protocol.PEPS_Info peps_info = 20;
  inline bool has_peps_info() const;
  inline void clear_peps_info();
  static const int kPepsInfoFieldNumber = 20;
  inline const ::zna::protocol::PEPS_Info& peps_info() const;
  inline ::zna::protocol::PEPS_Info* mutable_peps_info();
  inline ::zna::protocol::PEPS_Info* release_peps_info();
  inline void set_allocated_peps_info(::zna::protocol::PEPS_Info* peps_info);

  // optional .zna.protocol.ESP_Info esp_info = 21;
  inline bool has_esp_info() const;
  inline void clear_esp_info();
  static const int kEspInfoFieldNumber = 21;
  inline const ::zna::protocol::ESP_Info& esp_info() const;
  inline ::zna::protocol::ESP_Info* mutable_esp_info();
  inline ::zna::protocol::ESP_Info* release_esp_info();
  inline void set_allocated_esp_info(::zna::protocol::ESP_Info* esp_info);

  // optional .zna.protocol.EPB_Info epb_info = 22;
  inline bool has_epb_info() const;
  inline void clear_epb_info();
  static const int kEpbInfoFieldNumber = 22;
  inline const ::zna::protocol::EPB_Info& epb_info() const;
  inline ::zna::protocol::EPB_Info* mutable_epb_info();
  inline ::zna::protocol::EPB_Info* release_epb_info();
  inline void set_allocated_epb_info(::zna::protocol::EPB_Info* epb_info);

  // optional .zna.protocol.TCU_Info tcu_info = 23;
  inline bool has_tcu_info() const;
  inline void clear_tcu_info();
  static const int kTcuInfoFieldNumber = 23;
  inline const ::zna::protocol::TCU_Info& tcu_info() const;
  inline ::zna::protocol::TCU_Info* mutable_tcu_info();
  inline ::zna::protocol::TCU_Info* release_tcu_info();
  inline void set_allocated_tcu_info(::zna::protocol::TCU_Info* tcu_info);

  // optional .zna.protocol.AWD_Info awd_info = 24;
  inline bool has_awd_info() const;
  inline void clear_awd_info();
  static const int kAwdInfoFieldNumber = 24;
  inline const ::zna::protocol::AWD_Info& awd_info() const;
  inline ::zna::protocol::AWD_Info* mutable_awd_info();
  inline ::zna::protocol::AWD_Info* release_awd_info();
  inline void set_allocated_awd_info(::zna::protocol::AWD_Info* awd_info);

  // optional .zna.protocol.AC_Info ac_info = 25;
  inline bool has_ac_info() const;
  inline void clear_ac_info();
  static const int kAcInfoFieldNumber = 25;
  inline const ::zna::protocol::AC_Info& ac_info() const;
  inline ::zna::protocol::AC_Info* mutable_ac_info();
  inline ::zna::protocol::AC_Info* release_ac_info();
  inline void set_allocated_ac_info(::zna::protocol::AC_Info* ac_info);

  // optional .zna.protocol.SAS_Info sas_info = 26;
  inline bool has_sas_info() const;
  inline void clear_sas_info();
  static const int kSasInfoFieldNumber = 26;
  inline const ::zna::protocol::SAS_Info& sas_info() const;
  inline ::zna::protocol::SAS_Info* mutable_sas_info();
  inline ::zna::protocol::SAS_Info* release_sas_info();
  inline void set_allocated_sas_info(::zna::protocol::SAS_Info* sas_info);

  // optional .zna.protocol.FCM_Info fcm_info = 27;
  inline bool has_fcm_info() const;
  inline void clear_fcm_info();
  static const int kFcmInfoFieldNumber = 27;
  inline const ::zna::protocol::FCM_Info& fcm_info() const;
  inline ::zna::protocol::FCM_Info* mutable_fcm_info();
  inline ::zna::protocol::FCM_Info* release_fcm_info();
  inline void set_allocated_fcm_info(::zna::protocol::FCM_Info* fcm_info);

  // optional .zna.protocol.EPS_Info eps_info = 28;
  inline bool has_eps_info() const;
  inline void clear_eps_info();
  static const int kEpsInfoFieldNumber = 28;
  inline const ::zna::protocol::EPS_Info& eps_info() const;
  inline ::zna::protocol::EPS_Info* mutable_eps_info();
  inline ::zna::protocol::EPS_Info* release_eps_info();
  inline void set_allocated_eps_info(::zna::protocol::EPS_Info* eps_info);

  // optional .zna.protocol.ELD_Info eld_info = 29;
  inline bool has_eld_info() const;
  inline void clear_eld_info();
  static const int kEldInfoFieldNumber = 29;
  inline const ::zna::protocol::ELD_Info& eld_info() const;
  inline ::zna::protocol::ELD_Info* mutable_eld_info();
  inline ::zna::protocol::ELD_Info* release_eld_info();
  inline void set_allocated_eld_info(::zna::protocol::ELD_Info* eld_info);

  // optional .zna.protocol.ECU_Info ecu_info = 30;
  inline bool has_ecu_info() const;
  inline void clear_ecu_info();
  static const int kEcuInfoFieldNumber = 30;
  inline const ::zna::protocol::ECU_Info& ecu_info() const;
  inline ::zna::protocol::ECU_Info* mutable_ecu_info();
  inline ::zna::protocol::ECU_Info* release_ecu_info();
  inline void set_allocated_ecu_info(::zna::protocol::ECU_Info* ecu_info);

  // @@protoc_insertion_point(class_scope:zna.protocol.Basic_Info)
 private:
  inline void set_has_ecm_info();
  inline void clear_has_ecm_info();
  inline void set_has_meter_info();
  inline void clear_has_meter_info();
  inline void set_has_bcm_info();
  inline void clear_has_bcm_info();
  inline void set_has_acu_info();
  inline void clear_has_acu_info();
  inline void set_has_eco_info();
  inline void clear_has_eco_info();
  inline void set_has_alarm_info();
  inline void clear_has_alarm_info();
  inline void set_has_peps_info();
  inline void clear_has_peps_info();
  inline void set_has_esp_info();
  inline void clear_has_esp_info();
  inline void set_has_epb_info();
  inline void clear_has_epb_info();
  inline void set_has_tcu_info();
  inline void clear_has_tcu_info();
  inline void set_has_awd_info();
  inline void clear_has_awd_info();
  inline void set_has_ac_info();
  inline void clear_has_ac_info();
  inline void set_has_sas_info();
  inline void clear_has_sas_info();
  inline void set_has_fcm_info();
  inline void clear_has_fcm_info();
  inline void set_has_eps_info();
  inline void clear_has_eps_info();
  inline void set_has_eld_info();
  inline void clear_has_eld_info();
  inline void set_has_ecu_info();
  inline void clear_has_ecu_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::zna::protocol::ECM_Info* ecm_info_;
  ::zna::protocol::METER_Info* meter_info_;
  ::zna::protocol::BCM_Info* bcm_info_;
  ::zna::protocol::ACU_Info* acu_info_;
  ::zna::protocol::ECO_Info* eco_info_;
  ::zna::protocol::ALARM_Info* alarm_info_;
  ::zna::protocol::PEPS_Info* peps_info_;
  ::zna::protocol::ESP_Info* esp_info_;
  ::zna::protocol::EPB_Info* epb_info_;
  ::zna::protocol::TCU_Info* tcu_info_;
  ::zna::protocol::AWD_Info* awd_info_;
  ::zna::protocol::AC_Info* ac_info_;
  ::zna::protocol::SAS_Info* sas_info_;
  ::zna::protocol::FCM_Info* fcm_info_;
  ::zna::protocol::EPS_Info* eps_info_;
  ::zna::protocol::ELD_Info* eld_info_;
  ::zna::protocol::ECU_Info* ecu_info_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static Basic_Info* default_instance_;
};
// -------------------------------------------------------------------

class Vehicle_Info : public ::google::protobuf::Message {
 public:
  Vehicle_Info();
  virtual ~Vehicle_Info();

  Vehicle_Info(const Vehicle_Info& from);

  inline Vehicle_Info& operator=(const Vehicle_Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vehicle_Info& default_instance();

  void Swap(Vehicle_Info* other);

  // implements Message ----------------------------------------------

  Vehicle_Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vehicle_Info& from);
  void MergeFrom(const Vehicle_Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool Info_type = 1;
  inline bool has_info_type() const;
  inline void clear_info_type();
  static const int kInfoTypeFieldNumber = 1;
  inline bool info_type() const;
  inline void set_info_type(bool value);

  // required uint32 collect_time = 2;
  inline bool has_collect_time() const;
  inline void clear_collect_time();
  static const int kCollectTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 collect_time() const;
  inline void set_collect_time(::google::protobuf::uint32 value);

  // required .zna.protocol.Basic_Info basic_info = 3;
  inline bool has_basic_info() const;
  inline void clear_basic_info();
  static const int kBasicInfoFieldNumber = 3;
  inline const ::zna::protocol::Basic_Info& basic_info() const;
  inline ::zna::protocol::Basic_Info* mutable_basic_info();
  inline ::zna::protocol::Basic_Info* release_basic_info();
  inline void set_allocated_basic_info(::zna::protocol::Basic_Info* basic_info);

  // required uint32 time_stamp = 4;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 4;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // optional uint32 IgnOnTag = 5;
  inline bool has_ignontag() const;
  inline void clear_ignontag();
  static const int kIgnOnTagFieldNumber = 5;
  inline ::google::protobuf::uint32 ignontag() const;
  inline void set_ignontag(::google::protobuf::uint32 value);

  // optional uint32 EF82 = 6;
  inline bool has_ef82() const;
  inline void clear_ef82();
  static const int kEF82FieldNumber = 6;
  inline ::google::protobuf::uint32 ef82() const;
  inline void set_ef82(::google::protobuf::uint32 value);

  // optional string Version = 7;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 7;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:zna.protocol.Vehicle_Info)
 private:
  inline void set_has_info_type();
  inline void clear_has_info_type();
  inline void set_has_collect_time();
  inline void clear_has_collect_time();
  inline void set_has_basic_info();
  inline void clear_has_basic_info();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_ignontag();
  inline void clear_has_ignontag();
  inline void set_has_ef82();
  inline void clear_has_ef82();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool info_type_;
  ::google::protobuf::uint32 collect_time_;
  ::zna::protocol::Basic_Info* basic_info_;
  ::google::protobuf::uint32 time_stamp_;
  ::google::protobuf::uint32 ignontag_;
  ::std::string* version_;
  ::google::protobuf::uint32 ef82_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static Vehicle_Info* default_instance_;
};
// -------------------------------------------------------------------

class Vehicle_InfoRsp : public ::google::protobuf::Message {
 public:
  Vehicle_InfoRsp();
  virtual ~Vehicle_InfoRsp();

  Vehicle_InfoRsp(const Vehicle_InfoRsp& from);

  inline Vehicle_InfoRsp& operator=(const Vehicle_InfoRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vehicle_InfoRsp& default_instance();

  void Swap(Vehicle_InfoRsp* other);

  // implements Message ----------------------------------------------

  Vehicle_InfoRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vehicle_InfoRsp& from);
  void MergeFrom(const Vehicle_InfoRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errcode() const;
  inline void set_errcode(::google::protobuf::uint32 value);

  // required uint32 time_stamp = 2;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 2;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.Vehicle_InfoRsp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 errcode_;
  ::google::protobuf::uint32 time_stamp_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static Vehicle_InfoRsp* default_instance_;
};
// -------------------------------------------------------------------

class Location_Info : public ::google::protobuf::Message {
 public:
  Location_Info();
  virtual ~Location_Info();

  Location_Info(const Location_Info& from);

  inline Location_Info& operator=(const Location_Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Location_Info& default_instance();

  void Swap(Location_Info* other);

  // implements Message ----------------------------------------------

  Location_Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Location_Info& from);
  void MergeFrom(const Location_Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool Info_type = 1;
  inline bool has_info_type() const;
  inline void clear_info_type();
  static const int kInfoTypeFieldNumber = 1;
  inline bool info_type() const;
  inline void set_info_type(bool value);

  // required uint32 location_status = 3;
  inline bool has_location_status() const;
  inline void clear_location_status();
  static const int kLocationStatusFieldNumber = 3;
  inline ::google::protobuf::uint32 location_status() const;
  inline void set_location_status(::google::protobuf::uint32 value);

  // required uint32 longitude = 4;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 4;
  inline ::google::protobuf::uint32 longitude() const;
  inline void set_longitude(::google::protobuf::uint32 value);

  // required uint32 latitude = 5;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 5;
  inline ::google::protobuf::uint32 latitude() const;
  inline void set_latitude(::google::protobuf::uint32 value);

  // required uint32 time_stamp = 8;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 8;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // optional uint32 isGPSconversion = 9;
  inline bool has_isgpsconversion() const;
  inline void clear_isgpsconversion();
  static const int kIsGPSconversionFieldNumber = 9;
  inline ::google::protobuf::uint32 isgpsconversion() const;
  inline void set_isgpsconversion(::google::protobuf::uint32 value);

  // required uint64 gps_time = 10;
  inline bool has_gps_time() const;
  inline void clear_gps_time();
  static const int kGpsTimeFieldNumber = 10;
  inline ::google::protobuf::uint64 gps_time() const;
  inline void set_gps_time(::google::protobuf::uint64 value);

  // required uint32 height_valid = 11;
  inline bool has_height_valid() const;
  inline void clear_height_valid();
  static const int kHeightValidFieldNumber = 11;
  inline ::google::protobuf::uint32 height_valid() const;
  inline void set_height_valid(::google::protobuf::uint32 value);

  // required uint32 height_data = 12;
  inline bool has_height_data() const;
  inline void clear_height_data();
  static const int kHeightDataFieldNumber = 12;
  inline ::google::protobuf::uint32 height_data() const;
  inline void set_height_data(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.Location_Info)
 private:
  inline void set_has_info_type();
  inline void clear_has_info_type();
  inline void set_has_location_status();
  inline void clear_has_location_status();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_isgpsconversion();
  inline void clear_has_isgpsconversion();
  inline void set_has_gps_time();
  inline void clear_has_gps_time();
  inline void set_has_height_valid();
  inline void clear_has_height_valid();
  inline void set_has_height_data();
  inline void clear_has_height_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool info_type_;
  ::google::protobuf::uint32 location_status_;
  ::google::protobuf::uint32 longitude_;
  ::google::protobuf::uint32 latitude_;
  ::google::protobuf::uint32 time_stamp_;
  ::google::protobuf::uint32 isgpsconversion_;
  ::google::protobuf::uint64 gps_time_;
  ::google::protobuf::uint32 height_valid_;
  ::google::protobuf::uint32 height_data_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static Location_Info* default_instance_;
};
// -------------------------------------------------------------------

class Location_InfoRsp : public ::google::protobuf::Message {
 public:
  Location_InfoRsp();
  virtual ~Location_InfoRsp();

  Location_InfoRsp(const Location_InfoRsp& from);

  inline Location_InfoRsp& operator=(const Location_InfoRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Location_InfoRsp& default_instance();

  void Swap(Location_InfoRsp* other);

  // implements Message ----------------------------------------------

  Location_InfoRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Location_InfoRsp& from);
  void MergeFrom(const Location_InfoRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errcode() const;
  inline void set_errcode(::google::protobuf::uint32 value);

  // required uint32 time_stamp = 2;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 2;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.Location_InfoRsp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 errcode_;
  ::google::protobuf::uint32 time_stamp_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static Location_InfoRsp* default_instance_;
};
// -------------------------------------------------------------------

class RemoteControlResultRsp : public ::google::protobuf::Message {
 public:
  RemoteControlResultRsp();
  virtual ~RemoteControlResultRsp();

  RemoteControlResultRsp(const RemoteControlResultRsp& from);

  inline RemoteControlResultRsp& operator=(const RemoteControlResultRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoteControlResultRsp& default_instance();

  void Swap(RemoteControlResultRsp* other);

  // implements Message ----------------------------------------------

  RemoteControlResultRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoteControlResultRsp& from);
  void MergeFrom(const RemoteControlResultRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 control_type = 1;
  inline bool has_control_type() const;
  inline void clear_control_type();
  static const int kControlTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 control_type() const;
  inline void set_control_type(::google::protobuf::uint32 value);

  // required uint32 control_value = 2;
  inline bool has_control_value() const;
  inline void clear_control_value();
  static const int kControlValueFieldNumber = 2;
  inline ::google::protobuf::uint32 control_value() const;
  inline void set_control_value(::google::protobuf::uint32 value);

  // required uint32 serial_number = 3;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 3;
  inline ::google::protobuf::uint32 serial_number() const;
  inline void set_serial_number(::google::protobuf::uint32 value);

  // required uint32 control_result = 4;
  inline bool has_control_result() const;
  inline void clear_control_result();
  static const int kControlResultFieldNumber = 4;
  inline ::google::protobuf::uint32 control_result() const;
  inline void set_control_result(::google::protobuf::uint32 value);

  // required uint32 time_stamp = 5;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 5;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.RemoteControlResultRsp)
 private:
  inline void set_has_control_type();
  inline void clear_has_control_type();
  inline void set_has_control_value();
  inline void clear_has_control_value();
  inline void set_has_serial_number();
  inline void clear_has_serial_number();
  inline void set_has_control_result();
  inline void clear_has_control_result();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 control_type_;
  ::google::protobuf::uint32 control_value_;
  ::google::protobuf::uint32 serial_number_;
  ::google::protobuf::uint32 control_result_;
  ::google::protobuf::uint32 time_stamp_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static RemoteControlResultRsp* default_instance_;
};
// -------------------------------------------------------------------

class RemoteControlReq : public ::google::protobuf::Message {
 public:
  RemoteControlReq();
  virtual ~RemoteControlReq();

  RemoteControlReq(const RemoteControlReq& from);

  inline RemoteControlReq& operator=(const RemoteControlReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoteControlReq& default_instance();

  void Swap(RemoteControlReq* other);

  // implements Message ----------------------------------------------

  RemoteControlReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoteControlReq& from);
  void MergeFrom(const RemoteControlReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 control_type = 1;
  inline bool has_control_type() const;
  inline void clear_control_type();
  static const int kControlTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 control_type() const;
  inline void set_control_type(::google::protobuf::uint32 value);

  // required uint32 control_value = 2;
  inline bool has_control_value() const;
  inline void clear_control_value();
  static const int kControlValueFieldNumber = 2;
  inline ::google::protobuf::uint32 control_value() const;
  inline void set_control_value(::google::protobuf::uint32 value);

  // required uint32 serial_number = 3;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 3;
  inline ::google::protobuf::uint32 serial_number() const;
  inline void set_serial_number(::google::protobuf::uint32 value);

  // required uint32 time_stamp = 4;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 4;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // optional string signal_data = 5;
  inline bool has_signal_data() const;
  inline void clear_signal_data();
  static const int kSignalDataFieldNumber = 5;
  inline const ::std::string& signal_data() const;
  inline void set_signal_data(const ::std::string& value);
  inline void set_signal_data(const char* value);
  inline void set_signal_data(const char* value, size_t size);
  inline ::std::string* mutable_signal_data();
  inline ::std::string* release_signal_data();
  inline void set_allocated_signal_data(::std::string* signal_data);

  // @@protoc_insertion_point(class_scope:zna.protocol.RemoteControlReq)
 private:
  inline void set_has_control_type();
  inline void clear_has_control_type();
  inline void set_has_control_value();
  inline void clear_has_control_value();
  inline void set_has_serial_number();
  inline void clear_has_serial_number();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_signal_data();
  inline void clear_has_signal_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 control_type_;
  ::google::protobuf::uint32 control_value_;
  ::google::protobuf::uint32 serial_number_;
  ::google::protobuf::uint32 time_stamp_;
  ::std::string* signal_data_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static RemoteControlReq* default_instance_;
};
// -------------------------------------------------------------------

class FlowCountRsp : public ::google::protobuf::Message {
 public:
  FlowCountRsp();
  virtual ~FlowCountRsp();

  FlowCountRsp(const FlowCountRsp& from);

  inline FlowCountRsp& operator=(const FlowCountRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlowCountRsp& default_instance();

  void Swap(FlowCountRsp* other);

  // implements Message ----------------------------------------------

  FlowCountRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlowCountRsp& from);
  void MergeFrom(const FlowCountRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 dataAllowance = 1;
  inline bool has_dataallowance() const;
  inline void clear_dataallowance();
  static const int kDataAllowanceFieldNumber = 1;
  inline ::google::protobuf::uint32 dataallowance() const;
  inline void set_dataallowance(::google::protobuf::uint32 value);

  // required uint32 dataUsage = 2;
  inline bool has_datausage() const;
  inline void clear_datausage();
  static const int kDataUsageFieldNumber = 2;
  inline ::google::protobuf::uint32 datausage() const;
  inline void set_datausage(::google::protobuf::uint32 value);

  // required uint32 dataAvailable = 3;
  inline bool has_dataavailable() const;
  inline void clear_dataavailable();
  static const int kDataAvailableFieldNumber = 3;
  inline ::google::protobuf::uint32 dataavailable() const;
  inline void set_dataavailable(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.FlowCountRsp)
 private:
  inline void set_has_dataallowance();
  inline void clear_has_dataallowance();
  inline void set_has_datausage();
  inline void clear_has_datausage();
  inline void set_has_dataavailable();
  inline void clear_has_dataavailable();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 dataallowance_;
  ::google::protobuf::uint32 datausage_;
  ::google::protobuf::uint32 dataavailable_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static FlowCountRsp* default_instance_;
};
// -------------------------------------------------------------------

class FlowCountLimitReq : public ::google::protobuf::Message {
 public:
  FlowCountLimitReq();
  virtual ~FlowCountLimitReq();

  FlowCountLimitReq(const FlowCountLimitReq& from);

  inline FlowCountLimitReq& operator=(const FlowCountLimitReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlowCountLimitReq& default_instance();

  void Swap(FlowCountLimitReq* other);

  // implements Message ----------------------------------------------

  FlowCountLimitReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlowCountLimitReq& from);
  void MergeFrom(const FlowCountLimitReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 limitVal = 1;
  inline bool has_limitval() const;
  inline void clear_limitval();
  static const int kLimitValFieldNumber = 1;
  inline ::google::protobuf::uint32 limitval() const;
  inline void set_limitval(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.FlowCountLimitReq)
 private:
  inline void set_has_limitval();
  inline void clear_has_limitval();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 limitval_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static FlowCountLimitReq* default_instance_;
};
// -------------------------------------------------------------------

class OtaUpgradeReq : public ::google::protobuf::Message {
 public:
  OtaUpgradeReq();
  virtual ~OtaUpgradeReq();

  OtaUpgradeReq(const OtaUpgradeReq& from);

  inline OtaUpgradeReq& operator=(const OtaUpgradeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OtaUpgradeReq& default_instance();

  void Swap(OtaUpgradeReq* other);

  // implements Message ----------------------------------------------

  OtaUpgradeReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OtaUpgradeReq& from);
  void MergeFrom(const OtaUpgradeReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .zna.protocol.UpgradeInfo upgradeinfo = 1;
  inline int upgradeinfo_size() const;
  inline void clear_upgradeinfo();
  static const int kUpgradeinfoFieldNumber = 1;
  inline const ::zna::protocol::UpgradeInfo& upgradeinfo(int index) const;
  inline ::zna::protocol::UpgradeInfo* mutable_upgradeinfo(int index);
  inline ::zna::protocol::UpgradeInfo* add_upgradeinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::zna::protocol::UpgradeInfo >&
      upgradeinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::zna::protocol::UpgradeInfo >*
      mutable_upgradeinfo();

  // required uint32 serial_number = 2;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 2;
  inline ::google::protobuf::uint32 serial_number() const;
  inline void set_serial_number(::google::protobuf::uint32 value);

  // required uint32 time_stamp = 3;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 3;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.OtaUpgradeReq)
 private:
  inline void set_has_serial_number();
  inline void clear_has_serial_number();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::zna::protocol::UpgradeInfo > upgradeinfo_;
  ::google::protobuf::uint32 serial_number_;
  ::google::protobuf::uint32 time_stamp_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static OtaUpgradeReq* default_instance_;
};
// -------------------------------------------------------------------

class OtaUpgradeRsp : public ::google::protobuf::Message {
 public:
  OtaUpgradeRsp();
  virtual ~OtaUpgradeRsp();

  OtaUpgradeRsp(const OtaUpgradeRsp& from);

  inline OtaUpgradeRsp& operator=(const OtaUpgradeRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OtaUpgradeRsp& default_instance();

  void Swap(OtaUpgradeRsp* other);

  // implements Message ----------------------------------------------

  OtaUpgradeRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OtaUpgradeRsp& from);
  void MergeFrom(const OtaUpgradeRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errcode() const;
  inline void set_errcode(::google::protobuf::uint32 value);

  // required uint32 time_stamp = 2;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 2;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // required uint32 serial_number = 3;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 3;
  inline ::google::protobuf::uint32 serial_number() const;
  inline void set_serial_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.OtaUpgradeRsp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_serial_number();
  inline void clear_has_serial_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 errcode_;
  ::google::protobuf::uint32 time_stamp_;
  ::google::protobuf::uint32 serial_number_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static OtaUpgradeRsp* default_instance_;
};
// -------------------------------------------------------------------

class CancelOtaUpgradeRsp : public ::google::protobuf::Message {
 public:
  CancelOtaUpgradeRsp();
  virtual ~CancelOtaUpgradeRsp();

  CancelOtaUpgradeRsp(const CancelOtaUpgradeRsp& from);

  inline CancelOtaUpgradeRsp& operator=(const CancelOtaUpgradeRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CancelOtaUpgradeRsp& default_instance();

  void Swap(CancelOtaUpgradeRsp* other);

  // implements Message ----------------------------------------------

  CancelOtaUpgradeRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CancelOtaUpgradeRsp& from);
  void MergeFrom(const CancelOtaUpgradeRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errcode() const;
  inline void set_errcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.CancelOtaUpgradeRsp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 errcode_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static CancelOtaUpgradeRsp* default_instance_;
};
// -------------------------------------------------------------------

class OtaUpgradeProgressReq : public ::google::protobuf::Message {
 public:
  OtaUpgradeProgressReq();
  virtual ~OtaUpgradeProgressReq();

  OtaUpgradeProgressReq(const OtaUpgradeProgressReq& from);

  inline OtaUpgradeProgressReq& operator=(const OtaUpgradeProgressReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OtaUpgradeProgressReq& default_instance();

  void Swap(OtaUpgradeProgressReq* other);

  // implements Message ----------------------------------------------

  OtaUpgradeProgressReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OtaUpgradeProgressReq& from);
  void MergeFrom(const OtaUpgradeProgressReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .zna.protocol.UpgradeProgressCodeType UpgradeProgressCode = 1;
  inline bool has_upgradeprogresscode() const;
  inline void clear_upgradeprogresscode();
  static const int kUpgradeProgressCodeFieldNumber = 1;
  inline ::zna::protocol::UpgradeProgressCodeType upgradeprogresscode() const;
  inline void set_upgradeprogresscode(::zna::protocol::UpgradeProgressCodeType value);

  // optional uint32 errcode = 2;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 2;
  inline ::google::protobuf::uint32 errcode() const;
  inline void set_errcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.OtaUpgradeProgressReq)
 private:
  inline void set_has_upgradeprogresscode();
  inline void clear_has_upgradeprogresscode();
  inline void set_has_errcode();
  inline void clear_has_errcode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int upgradeprogresscode_;
  ::google::protobuf::uint32 errcode_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static OtaUpgradeProgressReq* default_instance_;
};
// -------------------------------------------------------------------

class CertCom : public ::google::protobuf::Message {
 public:
  CertCom();
  virtual ~CertCom();

  CertCom(const CertCom& from);

  inline CertCom& operator=(const CertCom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CertCom& default_instance();

  void Swap(CertCom* other);

  // implements Message ----------------------------------------------

  CertCom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CertCom& from);
  void MergeFrom(const CertCom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 serial_number = 1;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 serial_number() const;
  inline void set_serial_number(::google::protobuf::uint32 value);

  // required uint32 cur_cert_id = 2;
  inline bool has_cur_cert_id() const;
  inline void clear_cur_cert_id();
  static const int kCurCertIdFieldNumber = 2;
  inline ::google::protobuf::uint32 cur_cert_id() const;
  inline void set_cur_cert_id(::google::protobuf::uint32 value);

  // required uint32 data_status = 3;
  inline bool has_data_status() const;
  inline void clear_data_status();
  static const int kDataStatusFieldNumber = 3;
  inline ::google::protobuf::uint32 data_status() const;
  inline void set_data_status(::google::protobuf::uint32 value);

  // required uint32 cmd_id = 4;
  inline bool has_cmd_id() const;
  inline void clear_cmd_id();
  static const int kCmdIdFieldNumber = 4;
  inline ::google::protobuf::uint32 cmd_id() const;
  inline void set_cmd_id(::google::protobuf::uint32 value);

  // required string dcm_no = 5;
  inline bool has_dcm_no() const;
  inline void clear_dcm_no();
  static const int kDcmNoFieldNumber = 5;
  inline const ::std::string& dcm_no() const;
  inline void set_dcm_no(const ::std::string& value);
  inline void set_dcm_no(const char* value);
  inline void set_dcm_no(const char* value, size_t size);
  inline ::std::string* mutable_dcm_no();
  inline ::std::string* release_dcm_no();
  inline void set_allocated_dcm_no(::std::string* dcm_no);

  // optional uint32 errcode = 6;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 6;
  inline ::google::protobuf::uint32 errcode() const;
  inline void set_errcode(::google::protobuf::uint32 value);

  // required bytes data_info = 7;
  inline bool has_data_info() const;
  inline void clear_data_info();
  static const int kDataInfoFieldNumber = 7;
  inline const ::std::string& data_info() const;
  inline void set_data_info(const ::std::string& value);
  inline void set_data_info(const char* value);
  inline void set_data_info(const void* value, size_t size);
  inline ::std::string* mutable_data_info();
  inline ::std::string* release_data_info();
  inline void set_allocated_data_info(::std::string* data_info);

  // optional bytes sign_data = 8;
  inline bool has_sign_data() const;
  inline void clear_sign_data();
  static const int kSignDataFieldNumber = 8;
  inline const ::std::string& sign_data() const;
  inline void set_sign_data(const ::std::string& value);
  inline void set_sign_data(const char* value);
  inline void set_sign_data(const void* value, size_t size);
  inline ::std::string* mutable_sign_data();
  inline ::std::string* release_sign_data();
  inline void set_allocated_sign_data(::std::string* sign_data);

  // @@protoc_insertion_point(class_scope:zna.protocol.CertCom)
 private:
  inline void set_has_serial_number();
  inline void clear_has_serial_number();
  inline void set_has_cur_cert_id();
  inline void clear_has_cur_cert_id();
  inline void set_has_data_status();
  inline void clear_has_data_status();
  inline void set_has_cmd_id();
  inline void clear_has_cmd_id();
  inline void set_has_dcm_no();
  inline void clear_has_dcm_no();
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_data_info();
  inline void clear_has_data_info();
  inline void set_has_sign_data();
  inline void clear_has_sign_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 serial_number_;
  ::google::protobuf::uint32 cur_cert_id_;
  ::google::protobuf::uint32 data_status_;
  ::google::protobuf::uint32 cmd_id_;
  ::std::string* dcm_no_;
  ::std::string* data_info_;
  ::std::string* sign_data_;
  ::google::protobuf::uint32 errcode_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static CertCom* default_instance_;
};
// -------------------------------------------------------------------

class TCUCertApply_Req : public ::google::protobuf::Message {
 public:
  TCUCertApply_Req();
  virtual ~TCUCertApply_Req();

  TCUCertApply_Req(const TCUCertApply_Req& from);

  inline TCUCertApply_Req& operator=(const TCUCertApply_Req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TCUCertApply_Req& default_instance();

  void Swap(TCUCertApply_Req* other);

  // implements Message ----------------------------------------------

  TCUCertApply_Req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TCUCertApply_Req& from);
  void MergeFrom(const TCUCertApply_Req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 time_stamp = 1;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 1;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // required string vin = 2;
  inline bool has_vin() const;
  inline void clear_vin();
  static const int kVinFieldNumber = 2;
  inline const ::std::string& vin() const;
  inline void set_vin(const ::std::string& value);
  inline void set_vin(const char* value);
  inline void set_vin(const char* value, size_t size);
  inline ::std::string* mutable_vin();
  inline ::std::string* release_vin();
  inline void set_allocated_vin(::std::string* vin);

  // required uint32 cert_status = 3;
  inline bool has_cert_status() const;
  inline void clear_cert_status();
  static const int kCertStatusFieldNumber = 3;
  inline ::google::protobuf::uint32 cert_status() const;
  inline void set_cert_status(::google::protobuf::uint32 value);

  // required uint32 duration = 4;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 4;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // required bytes p10_csr = 5;
  inline bool has_p10_csr() const;
  inline void clear_p10_csr();
  static const int kP10CsrFieldNumber = 5;
  inline const ::std::string& p10_csr() const;
  inline void set_p10_csr(const ::std::string& value);
  inline void set_p10_csr(const char* value);
  inline void set_p10_csr(const void* value, size_t size);
  inline ::std::string* mutable_p10_csr();
  inline ::std::string* release_p10_csr();
  inline void set_allocated_p10_csr(::std::string* p10_csr);

  // optional bytes cst_sign_data = 6;
  inline bool has_cst_sign_data() const;
  inline void clear_cst_sign_data();
  static const int kCstSignDataFieldNumber = 6;
  inline const ::std::string& cst_sign_data() const;
  inline void set_cst_sign_data(const ::std::string& value);
  inline void set_cst_sign_data(const char* value);
  inline void set_cst_sign_data(const void* value, size_t size);
  inline ::std::string* mutable_cst_sign_data();
  inline ::std::string* release_cst_sign_data();
  inline void set_allocated_cst_sign_data(::std::string* cst_sign_data);

  // optional string cert_format = 7;
  inline bool has_cert_format() const;
  inline void clear_cert_format();
  static const int kCertFormatFieldNumber = 7;
  inline const ::std::string& cert_format() const;
  inline void set_cert_format(const ::std::string& value);
  inline void set_cert_format(const char* value);
  inline void set_cert_format(const char* value, size_t size);
  inline ::std::string* mutable_cert_format();
  inline ::std::string* release_cert_format();
  inline void set_allocated_cert_format(::std::string* cert_format);

  // optional uint32 sign_type = 8;
  inline bool has_sign_type() const;
  inline void clear_sign_type();
  static const int kSignTypeFieldNumber = 8;
  inline ::google::protobuf::uint32 sign_type() const;
  inline void set_sign_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.TCUCertApply_Req)
 private:
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_vin();
  inline void clear_has_vin();
  inline void set_has_cert_status();
  inline void clear_has_cert_status();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_p10_csr();
  inline void clear_has_p10_csr();
  inline void set_has_cst_sign_data();
  inline void clear_has_cst_sign_data();
  inline void set_has_cert_format();
  inline void clear_has_cert_format();
  inline void set_has_sign_type();
  inline void clear_has_sign_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* vin_;
  ::google::protobuf::uint32 time_stamp_;
  ::google::protobuf::uint32 cert_status_;
  ::std::string* p10_csr_;
  ::std::string* cst_sign_data_;
  ::google::protobuf::uint32 duration_;
  ::google::protobuf::uint32 sign_type_;
  ::std::string* cert_format_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static TCUCertApply_Req* default_instance_;
};
// -------------------------------------------------------------------

class TCUCertApply_Rsp : public ::google::protobuf::Message {
 public:
  TCUCertApply_Rsp();
  virtual ~TCUCertApply_Rsp();

  TCUCertApply_Rsp(const TCUCertApply_Rsp& from);

  inline TCUCertApply_Rsp& operator=(const TCUCertApply_Rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TCUCertApply_Rsp& default_instance();

  void Swap(TCUCertApply_Rsp* other);

  // implements Message ----------------------------------------------

  TCUCertApply_Rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TCUCertApply_Rsp& from);
  void MergeFrom(const TCUCertApply_Rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 time_stamp = 1;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 1;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // optional uint32 recv_status = 2;
  inline bool has_recv_status() const;
  inline void clear_recv_status();
  static const int kRecvStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 recv_status() const;
  inline void set_recv_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.TCUCertApply_Rsp)
 private:
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_recv_status();
  inline void clear_has_recv_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 time_stamp_;
  ::google::protobuf::uint32 recv_status_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static TCUCertApply_Rsp* default_instance_;
};
// -------------------------------------------------------------------

class CertIssue_Req : public ::google::protobuf::Message {
 public:
  CertIssue_Req();
  virtual ~CertIssue_Req();

  CertIssue_Req(const CertIssue_Req& from);

  inline CertIssue_Req& operator=(const CertIssue_Req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CertIssue_Req& default_instance();

  void Swap(CertIssue_Req* other);

  // implements Message ----------------------------------------------

  CertIssue_Req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CertIssue_Req& from);
  void MergeFrom(const CertIssue_Req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 time_stamp = 1;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 1;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // required uint32 cert_apply_status = 2;
  inline bool has_cert_apply_status() const;
  inline void clear_cert_apply_status();
  static const int kCertApplyStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 cert_apply_status() const;
  inline void set_cert_apply_status(::google::protobuf::uint32 value);

  // optional uint32 apply_cert_id = 3;
  inline bool has_apply_cert_id() const;
  inline void clear_apply_cert_id();
  static const int kApplyCertIdFieldNumber = 3;
  inline ::google::protobuf::uint32 apply_cert_id() const;
  inline void set_apply_cert_id(::google::protobuf::uint32 value);

  // optional bytes cert_data = 4;
  inline bool has_cert_data() const;
  inline void clear_cert_data();
  static const int kCertDataFieldNumber = 4;
  inline const ::std::string& cert_data() const;
  inline void set_cert_data(const ::std::string& value);
  inline void set_cert_data(const char* value);
  inline void set_cert_data(const void* value, size_t size);
  inline ::std::string* mutable_cert_data();
  inline ::std::string* release_cert_data();
  inline void set_allocated_cert_data(::std::string* cert_data);

  // @@protoc_insertion_point(class_scope:zna.protocol.CertIssue_Req)
 private:
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_cert_apply_status();
  inline void clear_has_cert_apply_status();
  inline void set_has_apply_cert_id();
  inline void clear_has_apply_cert_id();
  inline void set_has_cert_data();
  inline void clear_has_cert_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 time_stamp_;
  ::google::protobuf::uint32 cert_apply_status_;
  ::std::string* cert_data_;
  ::google::protobuf::uint32 apply_cert_id_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static CertIssue_Req* default_instance_;
};
// -------------------------------------------------------------------

class CertIssue_Rsp : public ::google::protobuf::Message {
 public:
  CertIssue_Rsp();
  virtual ~CertIssue_Rsp();

  CertIssue_Rsp(const CertIssue_Rsp& from);

  inline CertIssue_Rsp& operator=(const CertIssue_Rsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CertIssue_Rsp& default_instance();

  void Swap(CertIssue_Rsp* other);

  // implements Message ----------------------------------------------

  CertIssue_Rsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CertIssue_Rsp& from);
  void MergeFrom(const CertIssue_Rsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 time_stamp = 1;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 1;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // required uint32 cert_recv_status = 2;
  inline bool has_cert_recv_status() const;
  inline void clear_cert_recv_status();
  static const int kCertRecvStatusFieldNumber = 2;
  inline ::google::protobuf::uint32 cert_recv_status() const;
  inline void set_cert_recv_status(::google::protobuf::uint32 value);

  // optional uint32 apply_cert_id = 3;
  inline bool has_apply_cert_id() const;
  inline void clear_apply_cert_id();
  static const int kApplyCertIdFieldNumber = 3;
  inline ::google::protobuf::uint32 apply_cert_id() const;
  inline void set_apply_cert_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.CertIssue_Rsp)
 private:
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_cert_recv_status();
  inline void clear_has_cert_recv_status();
  inline void set_has_apply_cert_id();
  inline void clear_has_apply_cert_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 time_stamp_;
  ::google::protobuf::uint32 cert_recv_status_;
  ::google::protobuf::uint32 apply_cert_id_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static CertIssue_Rsp* default_instance_;
};
// -------------------------------------------------------------------

class RSALoginReq : public ::google::protobuf::Message {
 public:
  RSALoginReq();
  virtual ~RSALoginReq();

  RSALoginReq(const RSALoginReq& from);

  inline RSALoginReq& operator=(const RSALoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RSALoginReq& default_instance();

  void Swap(RSALoginReq* other);

  // implements Message ----------------------------------------------

  RSALoginReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RSALoginReq& from);
  void MergeFrom(const RSALoginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string tcu_device_sn = 1;
  inline bool has_tcu_device_sn() const;
  inline void clear_tcu_device_sn();
  static const int kTcuDeviceSnFieldNumber = 1;
  inline const ::std::string& tcu_device_sn() const;
  inline void set_tcu_device_sn(const ::std::string& value);
  inline void set_tcu_device_sn(const char* value);
  inline void set_tcu_device_sn(const char* value, size_t size);
  inline ::std::string* mutable_tcu_device_sn();
  inline ::std::string* release_tcu_device_sn();
  inline void set_allocated_tcu_device_sn(::std::string* tcu_device_sn);

  // required string imsi = 2;
  inline bool has_imsi() const;
  inline void clear_imsi();
  static const int kImsiFieldNumber = 2;
  inline const ::std::string& imsi() const;
  inline void set_imsi(const ::std::string& value);
  inline void set_imsi(const char* value);
  inline void set_imsi(const char* value, size_t size);
  inline ::std::string* mutable_imsi();
  inline ::std::string* release_imsi();
  inline void set_allocated_imsi(::std::string* imsi);

  // required string imei = 3;
  inline bool has_imei() const;
  inline void clear_imei();
  static const int kImeiFieldNumber = 3;
  inline const ::std::string& imei() const;
  inline void set_imei(const ::std::string& value);
  inline void set_imei(const char* value);
  inline void set_imei(const char* value, size_t size);
  inline ::std::string* mutable_imei();
  inline ::std::string* release_imei();
  inline void set_allocated_imei(::std::string* imei);

  // required string software_version = 4;
  inline bool has_software_version() const;
  inline void clear_software_version();
  static const int kSoftwareVersionFieldNumber = 4;
  inline const ::std::string& software_version() const;
  inline void set_software_version(const ::std::string& value);
  inline void set_software_version(const char* value);
  inline void set_software_version(const char* value, size_t size);
  inline ::std::string* mutable_software_version();
  inline ::std::string* release_software_version();
  inline void set_allocated_software_version(::std::string* software_version);

  // required string hardware_version = 5;
  inline bool has_hardware_version() const;
  inline void clear_hardware_version();
  static const int kHardwareVersionFieldNumber = 5;
  inline const ::std::string& hardware_version() const;
  inline void set_hardware_version(const ::std::string& value);
  inline void set_hardware_version(const char* value);
  inline void set_hardware_version(const char* value, size_t size);
  inline ::std::string* mutable_hardware_version();
  inline ::std::string* release_hardware_version();
  inline void set_allocated_hardware_version(::std::string* hardware_version);

  // required uint32 time_stamp = 6;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 6;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // optional string g4_version = 7;
  inline bool has_g4_version() const;
  inline void clear_g4_version();
  static const int kG4VersionFieldNumber = 7;
  inline const ::std::string& g4_version() const;
  inline void set_g4_version(const ::std::string& value);
  inline void set_g4_version(const char* value);
  inline void set_g4_version(const char* value, size_t size);
  inline ::std::string* mutable_g4_version();
  inline ::std::string* release_g4_version();
  inline void set_allocated_g4_version(::std::string* g4_version);

  // optional string vehicle_type = 8;
  inline bool has_vehicle_type() const;
  inline void clear_vehicle_type();
  static const int kVehicleTypeFieldNumber = 8;
  inline const ::std::string& vehicle_type() const;
  inline void set_vehicle_type(const ::std::string& value);
  inline void set_vehicle_type(const char* value);
  inline void set_vehicle_type(const char* value, size_t size);
  inline ::std::string* mutable_vehicle_type();
  inline ::std::string* release_vehicle_type();
  inline void set_allocated_vehicle_type(::std::string* vehicle_type);

  // @@protoc_insertion_point(class_scope:zna.protocol.RSALoginReq)
 private:
  inline void set_has_tcu_device_sn();
  inline void clear_has_tcu_device_sn();
  inline void set_has_imsi();
  inline void clear_has_imsi();
  inline void set_has_imei();
  inline void clear_has_imei();
  inline void set_has_software_version();
  inline void clear_has_software_version();
  inline void set_has_hardware_version();
  inline void clear_has_hardware_version();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_g4_version();
  inline void clear_has_g4_version();
  inline void set_has_vehicle_type();
  inline void clear_has_vehicle_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* tcu_device_sn_;
  ::std::string* imsi_;
  ::std::string* imei_;
  ::std::string* software_version_;
  ::std::string* hardware_version_;
  ::std::string* g4_version_;
  ::std::string* vehicle_type_;
  ::google::protobuf::uint32 time_stamp_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static RSALoginReq* default_instance_;
};
// -------------------------------------------------------------------

class SendRSARsp : public ::google::protobuf::Message {
 public:
  SendRSARsp();
  virtual ~SendRSARsp();

  SendRSARsp(const SendRSARsp& from);

  inline SendRSARsp& operator=(const SendRSARsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendRSARsp& default_instance();

  void Swap(SendRSARsp* other);

  // implements Message ----------------------------------------------

  SendRSARsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendRSARsp& from);
  void MergeFrom(const SendRSARsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errcode() const;
  inline void set_errcode(::google::protobuf::uint32 value);

  // optional uint32 N_len = 2;
  inline bool has_n_len() const;
  inline void clear_n_len();
  static const int kNLenFieldNumber = 2;
  inline ::google::protobuf::uint32 n_len() const;
  inline void set_n_len(::google::protobuf::uint32 value);

  // optional bytes N_string = 3;
  inline bool has_n_string() const;
  inline void clear_n_string();
  static const int kNStringFieldNumber = 3;
  inline const ::std::string& n_string() const;
  inline void set_n_string(const ::std::string& value);
  inline void set_n_string(const char* value);
  inline void set_n_string(const void* value, size_t size);
  inline ::std::string* mutable_n_string();
  inline ::std::string* release_n_string();
  inline void set_allocated_n_string(::std::string* n_string);

  // optional uint32 E1_len = 4;
  inline bool has_e1_len() const;
  inline void clear_e1_len();
  static const int kE1LenFieldNumber = 4;
  inline ::google::protobuf::uint32 e1_len() const;
  inline void set_e1_len(::google::protobuf::uint32 value);

  // optional bytes E1_string = 5;
  inline bool has_e1_string() const;
  inline void clear_e1_string();
  static const int kE1StringFieldNumber = 5;
  inline const ::std::string& e1_string() const;
  inline void set_e1_string(const ::std::string& value);
  inline void set_e1_string(const char* value);
  inline void set_e1_string(const void* value, size_t size);
  inline ::std::string* mutable_e1_string();
  inline ::std::string* release_e1_string();
  inline void set_allocated_e1_string(::std::string* e1_string);

  // @@protoc_insertion_point(class_scope:zna.protocol.SendRSARsp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_n_len();
  inline void clear_has_n_len();
  inline void set_has_n_string();
  inline void clear_has_n_string();
  inline void set_has_e1_len();
  inline void clear_has_e1_len();
  inline void set_has_e1_string();
  inline void clear_has_e1_string();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 errcode_;
  ::google::protobuf::uint32 n_len_;
  ::std::string* n_string_;
  ::std::string* e1_string_;
  ::google::protobuf::uint32 e1_len_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static SendRSARsp* default_instance_;
};
// -------------------------------------------------------------------

class SendRC4Req : public ::google::protobuf::Message {
 public:
  SendRC4Req();
  virtual ~SendRC4Req();

  SendRC4Req(const SendRC4Req& from);

  inline SendRC4Req& operator=(const SendRC4Req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendRC4Req& default_instance();

  void Swap(SendRC4Req* other);

  // implements Message ----------------------------------------------

  SendRC4Req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendRC4Req& from);
  void MergeFrom(const SendRC4Req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string da_device_sn = 1;
  inline bool has_da_device_sn() const;
  inline void clear_da_device_sn();
  static const int kDaDeviceSnFieldNumber = 1;
  inline const ::std::string& da_device_sn() const;
  inline void set_da_device_sn(const ::std::string& value);
  inline void set_da_device_sn(const char* value);
  inline void set_da_device_sn(const char* value, size_t size);
  inline ::std::string* mutable_da_device_sn();
  inline ::std::string* release_da_device_sn();
  inline void set_allocated_da_device_sn(::std::string* da_device_sn);

  // required string vin = 2;
  inline bool has_vin() const;
  inline void clear_vin();
  static const int kVinFieldNumber = 2;
  inline const ::std::string& vin() const;
  inline void set_vin(const ::std::string& value);
  inline void set_vin(const char* value);
  inline void set_vin(const char* value, size_t size);
  inline ::std::string* mutable_vin();
  inline ::std::string* release_vin();
  inline void set_allocated_vin(::std::string* vin);

  // required string iccid = 3;
  inline bool has_iccid() const;
  inline void clear_iccid();
  static const int kIccidFieldNumber = 3;
  inline const ::std::string& iccid() const;
  inline void set_iccid(const ::std::string& value);
  inline void set_iccid(const char* value);
  inline void set_iccid(const char* value, size_t size);
  inline ::std::string* mutable_iccid();
  inline ::std::string* release_iccid();
  inline void set_allocated_iccid(::std::string* iccid);

  // required uint32 serial_number = 4;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 4;
  inline ::google::protobuf::uint32 serial_number() const;
  inline void set_serial_number(::google::protobuf::uint32 value);

  // required uint32 key_len = 5;
  inline bool has_key_len() const;
  inline void clear_key_len();
  static const int kKeyLenFieldNumber = 5;
  inline ::google::protobuf::uint32 key_len() const;
  inline void set_key_len(::google::protobuf::uint32 value);

  // required bytes key = 6;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 6;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bool upgrading = 7;
  inline bool has_upgrading() const;
  inline void clear_upgrading();
  static const int kUpgradingFieldNumber = 7;
  inline bool upgrading() const;
  inline void set_upgrading(bool value);

  // optional bool bcm_reg_status = 8;
  inline bool has_bcm_reg_status() const;
  inline void clear_bcm_reg_status();
  static const int kBcmRegStatusFieldNumber = 8;
  inline bool bcm_reg_status() const;
  inline void set_bcm_reg_status(bool value);

  // @@protoc_insertion_point(class_scope:zna.protocol.SendRC4Req)
 private:
  inline void set_has_da_device_sn();
  inline void clear_has_da_device_sn();
  inline void set_has_vin();
  inline void clear_has_vin();
  inline void set_has_iccid();
  inline void clear_has_iccid();
  inline void set_has_serial_number();
  inline void clear_has_serial_number();
  inline void set_has_key_len();
  inline void clear_has_key_len();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_upgrading();
  inline void clear_has_upgrading();
  inline void set_has_bcm_reg_status();
  inline void clear_has_bcm_reg_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* da_device_sn_;
  ::std::string* vin_;
  ::std::string* iccid_;
  ::google::protobuf::uint32 serial_number_;
  ::google::protobuf::uint32 key_len_;
  ::std::string* key_;
  bool upgrading_;
  bool bcm_reg_status_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static SendRC4Req* default_instance_;
};
// -------------------------------------------------------------------

class SendRC4Resp : public ::google::protobuf::Message {
 public:
  SendRC4Resp();
  virtual ~SendRC4Resp();

  SendRC4Resp(const SendRC4Resp& from);

  inline SendRC4Resp& operator=(const SendRC4Resp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendRC4Resp& default_instance();

  void Swap(SendRC4Resp* other);

  // implements Message ----------------------------------------------

  SendRC4Resp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendRC4Resp& from);
  void MergeFrom(const SendRC4Resp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 errcode = 1;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 1;
  inline ::google::protobuf::uint32 errcode() const;
  inline void set_errcode(::google::protobuf::uint32 value);

  // required uint32 serial_number = 2;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 2;
  inline ::google::protobuf::uint32 serial_number() const;
  inline void set_serial_number(::google::protobuf::uint32 value);

  // required uint32 time_stamp = 3;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 3;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // repeated .zna.protocol.UpgradeInfo upgradeinfo = 4;
  inline int upgradeinfo_size() const;
  inline void clear_upgradeinfo();
  static const int kUpgradeinfoFieldNumber = 4;
  inline const ::zna::protocol::UpgradeInfo& upgradeinfo(int index) const;
  inline ::zna::protocol::UpgradeInfo* mutable_upgradeinfo(int index);
  inline ::zna::protocol::UpgradeInfo* add_upgradeinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::zna::protocol::UpgradeInfo >&
      upgradeinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::zna::protocol::UpgradeInfo >*
      mutable_upgradeinfo();

  // @@protoc_insertion_point(class_scope:zna.protocol.SendRC4Resp)
 private:
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_serial_number();
  inline void clear_has_serial_number();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 errcode_;
  ::google::protobuf::uint32 serial_number_;
  ::google::protobuf::RepeatedPtrField< ::zna::protocol::UpgradeInfo > upgradeinfo_;
  ::google::protobuf::uint32 time_stamp_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static SendRC4Resp* default_instance_;
};
// -------------------------------------------------------------------

class WakeUpDVRRsp : public ::google::protobuf::Message {
 public:
  WakeUpDVRRsp();
  virtual ~WakeUpDVRRsp();

  WakeUpDVRRsp(const WakeUpDVRRsp& from);

  inline WakeUpDVRRsp& operator=(const WakeUpDVRRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WakeUpDVRRsp& default_instance();

  void Swap(WakeUpDVRRsp* other);

  // implements Message ----------------------------------------------

  WakeUpDVRRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WakeUpDVRRsp& from);
  void MergeFrom(const WakeUpDVRRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 serial_number = 1;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 serial_number() const;
  inline void set_serial_number(::google::protobuf::uint32 value);

  // required uint32 control_result = 2;
  inline bool has_control_result() const;
  inline void clear_control_result();
  static const int kControlResultFieldNumber = 2;
  inline ::google::protobuf::uint32 control_result() const;
  inline void set_control_result(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.WakeUpDVRRsp)
 private:
  inline void set_has_serial_number();
  inline void clear_has_serial_number();
  inline void set_has_control_result();
  inline void clear_has_control_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 serial_number_;
  ::google::protobuf::uint32 control_result_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static WakeUpDVRRsp* default_instance_;
};
// -------------------------------------------------------------------

class WakeUpDVRReq : public ::google::protobuf::Message {
 public:
  WakeUpDVRReq();
  virtual ~WakeUpDVRReq();

  WakeUpDVRReq(const WakeUpDVRReq& from);

  inline WakeUpDVRReq& operator=(const WakeUpDVRReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WakeUpDVRReq& default_instance();

  void Swap(WakeUpDVRReq* other);

  // implements Message ----------------------------------------------

  WakeUpDVRReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WakeUpDVRReq& from);
  void MergeFrom(const WakeUpDVRReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 serial_number = 1;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 serial_number() const;
  inline void set_serial_number(::google::protobuf::uint32 value);

  // required uint32 time_stamp = 2;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 2;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.WakeUpDVRReq)
 private:
  inline void set_has_serial_number();
  inline void clear_has_serial_number();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 serial_number_;
  ::google::protobuf::uint32 time_stamp_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static WakeUpDVRReq* default_instance_;
};
// -------------------------------------------------------------------

class RmtDiagRsp : public ::google::protobuf::Message {
 public:
  RmtDiagRsp();
  virtual ~RmtDiagRsp();

  RmtDiagRsp(const RmtDiagRsp& from);

  inline RmtDiagRsp& operator=(const RmtDiagRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RmtDiagRsp& default_instance();

  void Swap(RmtDiagRsp* other);

  // implements Message ----------------------------------------------

  RmtDiagRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RmtDiagRsp& from);
  void MergeFrom(const RmtDiagRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .zna.protocol.RmtDiagRspCode result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::zna::protocol::RmtDiagRspCode result() const;
  inline void set_result(::zna::protocol::RmtDiagRspCode value);

  // required uint32 serial_number = 2;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 2;
  inline ::google::protobuf::uint32 serial_number() const;
  inline void set_serial_number(::google::protobuf::uint32 value);

  // required uint32 time_stamp = 3;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 3;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // optional bytes Diag_AVM = 4;
  inline bool has_diag_avm() const;
  inline void clear_diag_avm();
  static const int kDiagAVMFieldNumber = 4;
  inline const ::std::string& diag_avm() const;
  inline void set_diag_avm(const ::std::string& value);
  inline void set_diag_avm(const char* value);
  inline void set_diag_avm(const void* value, size_t size);
  inline ::std::string* mutable_diag_avm();
  inline ::std::string* release_diag_avm();
  inline void set_allocated_diag_avm(::std::string* diag_avm);

  // optional bytes Diag_SONAR = 5;
  inline bool has_diag_sonar() const;
  inline void clear_diag_sonar();
  static const int kDiagSONARFieldNumber = 5;
  inline const ::std::string& diag_sonar() const;
  inline void set_diag_sonar(const ::std::string& value);
  inline void set_diag_sonar(const char* value);
  inline void set_diag_sonar(const void* value, size_t size);
  inline ::std::string* mutable_diag_sonar();
  inline ::std::string* release_diag_sonar();
  inline void set_allocated_diag_sonar(::std::string* diag_sonar);

  // optional bytes Diag_BSW = 6;
  inline bool has_diag_bsw() const;
  inline void clear_diag_bsw();
  static const int kDiagBSWFieldNumber = 6;
  inline const ::std::string& diag_bsw() const;
  inline void set_diag_bsw(const ::std::string& value);
  inline void set_diag_bsw(const char* value);
  inline void set_diag_bsw(const void* value, size_t size);
  inline ::std::string* mutable_diag_bsw();
  inline ::std::string* release_diag_bsw();
  inline void set_allocated_diag_bsw(::std::string* diag_bsw);

  // optional bytes Diag_ECM = 7;
  inline bool has_diag_ecm() const;
  inline void clear_diag_ecm();
  static const int kDiagECMFieldNumber = 7;
  inline const ::std::string& diag_ecm() const;
  inline void set_diag_ecm(const ::std::string& value);
  inline void set_diag_ecm(const char* value);
  inline void set_diag_ecm(const void* value, size_t size);
  inline ::std::string* mutable_diag_ecm();
  inline ::std::string* release_diag_ecm();
  inline void set_allocated_diag_ecm(::std::string* diag_ecm);

  // optional bytes Diag_TCM = 8;
  inline bool has_diag_tcm() const;
  inline void clear_diag_tcm();
  static const int kDiagTCMFieldNumber = 8;
  inline const ::std::string& diag_tcm() const;
  inline void set_diag_tcm(const ::std::string& value);
  inline void set_diag_tcm(const char* value);
  inline void set_diag_tcm(const void* value, size_t size);
  inline ::std::string* mutable_diag_tcm();
  inline ::std::string* release_diag_tcm();
  inline void set_allocated_diag_tcm(::std::string* diag_tcm);

  // optional bytes Diag_USM = 9;
  inline bool has_diag_usm() const;
  inline void clear_diag_usm();
  static const int kDiagUSMFieldNumber = 9;
  inline const ::std::string& diag_usm() const;
  inline void set_diag_usm(const ::std::string& value);
  inline void set_diag_usm(const char* value);
  inline void set_diag_usm(const void* value, size_t size);
  inline ::std::string* mutable_diag_usm();
  inline ::std::string* release_diag_usm();
  inline void set_allocated_diag_usm(::std::string* diag_usm);

  // optional bytes Diag_BCM = 10;
  inline bool has_diag_bcm() const;
  inline void clear_diag_bcm();
  static const int kDiagBCMFieldNumber = 10;
  inline const ::std::string& diag_bcm() const;
  inline void set_diag_bcm(const ::std::string& value);
  inline void set_diag_bcm(const char* value);
  inline void set_diag_bcm(const void* value, size_t size);
  inline ::std::string* mutable_diag_bcm();
  inline ::std::string* release_diag_bcm();
  inline void set_allocated_diag_bcm(::std::string* diag_bcm);

  // optional bytes Diag_FEB_CAMERA = 11;
  inline bool has_diag_feb_camera() const;
  inline void clear_diag_feb_camera();
  static const int kDiagFEBCAMERAFieldNumber = 11;
  inline const ::std::string& diag_feb_camera() const;
  inline void set_diag_feb_camera(const ::std::string& value);
  inline void set_diag_feb_camera(const char* value);
  inline void set_diag_feb_camera(const void* value, size_t size);
  inline ::std::string* mutable_diag_feb_camera();
  inline ::std::string* release_diag_feb_camera();
  inline void set_allocated_diag_feb_camera(::std::string* diag_feb_camera);

  // optional bytes Diag_FEB_RADAR = 12;
  inline bool has_diag_feb_radar() const;
  inline void clear_diag_feb_radar();
  static const int kDiagFEBRADARFieldNumber = 12;
  inline const ::std::string& diag_feb_radar() const;
  inline void set_diag_feb_radar(const ::std::string& value);
  inline void set_diag_feb_radar(const char* value);
  inline void set_diag_feb_radar(const void* value, size_t size);
  inline ::std::string* mutable_diag_feb_radar();
  inline ::std::string* release_diag_feb_radar();
  inline void set_allocated_diag_feb_radar(::std::string* diag_feb_radar);

  // optional bytes Diag_DVR = 13;
  inline bool has_diag_dvr() const;
  inline void clear_diag_dvr();
  static const int kDiagDVRFieldNumber = 13;
  inline const ::std::string& diag_dvr() const;
  inline void set_diag_dvr(const ::std::string& value);
  inline void set_diag_dvr(const char* value);
  inline void set_diag_dvr(const void* value, size_t size);
  inline ::std::string* mutable_diag_dvr();
  inline ::std::string* release_diag_dvr();
  inline void set_allocated_diag_dvr(::std::string* diag_dvr);

  // optional bytes Diag_VDC = 14;
  inline bool has_diag_vdc() const;
  inline void clear_diag_vdc();
  static const int kDiagVDCFieldNumber = 14;
  inline const ::std::string& diag_vdc() const;
  inline void set_diag_vdc(const ::std::string& value);
  inline void set_diag_vdc(const char* value);
  inline void set_diag_vdc(const void* value, size_t size);
  inline ::std::string* mutable_diag_vdc();
  inline ::std::string* release_diag_vdc();
  inline void set_allocated_diag_vdc(::std::string* diag_vdc);

  // optional bytes Diag_EPS = 15;
  inline bool has_diag_eps() const;
  inline void clear_diag_eps();
  static const int kDiagEPSFieldNumber = 15;
  inline const ::std::string& diag_eps() const;
  inline void set_diag_eps(const ::std::string& value);
  inline void set_diag_eps(const char* value);
  inline void set_diag_eps(const void* value, size_t size);
  inline ::std::string* mutable_diag_eps();
  inline ::std::string* release_diag_eps();
  inline void set_allocated_diag_eps(::std::string* diag_eps);

  // optional bytes Diag_GW = 16;
  inline bool has_diag_gw() const;
  inline void clear_diag_gw();
  static const int kDiagGWFieldNumber = 16;
  inline const ::std::string& diag_gw() const;
  inline void set_diag_gw(const ::std::string& value);
  inline void set_diag_gw(const char* value);
  inline void set_diag_gw(const void* value, size_t size);
  inline ::std::string* mutable_diag_gw();
  inline ::std::string* release_diag_gw();
  inline void set_allocated_diag_gw(::std::string* diag_gw);

  // optional bytes Diag_TPMS = 17;
  inline bool has_diag_tpms() const;
  inline void clear_diag_tpms();
  static const int kDiagTPMSFieldNumber = 17;
  inline const ::std::string& diag_tpms() const;
  inline void set_diag_tpms(const ::std::string& value);
  inline void set_diag_tpms(const char* value);
  inline void set_diag_tpms(const void* value, size_t size);
  inline ::std::string* mutable_diag_tpms();
  inline ::std::string* release_diag_tpms();
  inline void set_allocated_diag_tpms(::std::string* diag_tpms);

  // optional bytes Diag_METER = 18;
  inline bool has_diag_meter() const;
  inline void clear_diag_meter();
  static const int kDiagMETERFieldNumber = 18;
  inline const ::std::string& diag_meter() const;
  inline void set_diag_meter(const ::std::string& value);
  inline void set_diag_meter(const char* value);
  inline void set_diag_meter(const void* value, size_t size);
  inline ::std::string* mutable_diag_meter();
  inline ::std::string* release_diag_meter();
  inline void set_allocated_diag_meter(::std::string* diag_meter);

  // optional bytes Diag_TCU = 19;
  inline bool has_diag_tcu() const;
  inline void clear_diag_tcu();
  static const int kDiagTCUFieldNumber = 19;
  inline const ::std::string& diag_tcu() const;
  inline void set_diag_tcu(const ::std::string& value);
  inline void set_diag_tcu(const char* value);
  inline void set_diag_tcu(const void* value, size_t size);
  inline ::std::string* mutable_diag_tcu();
  inline ::std::string* release_diag_tcu();
  inline void set_allocated_diag_tcu(::std::string* diag_tcu);

  // optional bytes Diag_ACU = 20;
  inline bool has_diag_acu() const;
  inline void clear_diag_acu();
  static const int kDiagACUFieldNumber = 20;
  inline const ::std::string& diag_acu() const;
  inline void set_diag_acu(const ::std::string& value);
  inline void set_diag_acu(const char* value);
  inline void set_diag_acu(const void* value, size_t size);
  inline ::std::string* mutable_diag_acu();
  inline ::std::string* release_diag_acu();
  inline void set_allocated_diag_acu(::std::string* diag_acu);

  // optional bytes Diag_DA = 21;
  inline bool has_diag_da() const;
  inline void clear_diag_da();
  static const int kDiagDAFieldNumber = 21;
  inline const ::std::string& diag_da() const;
  inline void set_diag_da(const ::std::string& value);
  inline void set_diag_da(const char* value);
  inline void set_diag_da(const void* value, size_t size);
  inline ::std::string* mutable_diag_da();
  inline ::std::string* release_diag_da();
  inline void set_allocated_diag_da(::std::string* diag_da);

  // @@protoc_insertion_point(class_scope:zna.protocol.RmtDiagRsp)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_serial_number();
  inline void clear_has_serial_number();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_diag_avm();
  inline void clear_has_diag_avm();
  inline void set_has_diag_sonar();
  inline void clear_has_diag_sonar();
  inline void set_has_diag_bsw();
  inline void clear_has_diag_bsw();
  inline void set_has_diag_ecm();
  inline void clear_has_diag_ecm();
  inline void set_has_diag_tcm();
  inline void clear_has_diag_tcm();
  inline void set_has_diag_usm();
  inline void clear_has_diag_usm();
  inline void set_has_diag_bcm();
  inline void clear_has_diag_bcm();
  inline void set_has_diag_feb_camera();
  inline void clear_has_diag_feb_camera();
  inline void set_has_diag_feb_radar();
  inline void clear_has_diag_feb_radar();
  inline void set_has_diag_dvr();
  inline void clear_has_diag_dvr();
  inline void set_has_diag_vdc();
  inline void clear_has_diag_vdc();
  inline void set_has_diag_eps();
  inline void clear_has_diag_eps();
  inline void set_has_diag_gw();
  inline void clear_has_diag_gw();
  inline void set_has_diag_tpms();
  inline void clear_has_diag_tpms();
  inline void set_has_diag_meter();
  inline void clear_has_diag_meter();
  inline void set_has_diag_tcu();
  inline void clear_has_diag_tcu();
  inline void set_has_diag_acu();
  inline void clear_has_diag_acu();
  inline void set_has_diag_da();
  inline void clear_has_diag_da();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int result_;
  ::google::protobuf::uint32 serial_number_;
  ::std::string* diag_avm_;
  ::std::string* diag_sonar_;
  ::std::string* diag_bsw_;
  ::std::string* diag_ecm_;
  ::std::string* diag_tcm_;
  ::std::string* diag_usm_;
  ::std::string* diag_bcm_;
  ::std::string* diag_feb_camera_;
  ::std::string* diag_feb_radar_;
  ::std::string* diag_dvr_;
  ::std::string* diag_vdc_;
  ::std::string* diag_eps_;
  ::std::string* diag_gw_;
  ::std::string* diag_tpms_;
  ::std::string* diag_meter_;
  ::std::string* diag_tcu_;
  ::std::string* diag_acu_;
  ::std::string* diag_da_;
  ::google::protobuf::uint32 time_stamp_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static RmtDiagRsp* default_instance_;
};
// -------------------------------------------------------------------

class RmtDiagReq : public ::google::protobuf::Message {
 public:
  RmtDiagReq();
  virtual ~RmtDiagReq();

  RmtDiagReq(const RmtDiagReq& from);

  inline RmtDiagReq& operator=(const RmtDiagReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RmtDiagReq& default_instance();

  void Swap(RmtDiagReq* other);

  // implements Message ----------------------------------------------

  RmtDiagReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RmtDiagReq& from);
  void MergeFrom(const RmtDiagReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 serial_number = 1;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 serial_number() const;
  inline void set_serial_number(::google::protobuf::uint32 value);

  // required uint32 time_stamp = 2;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 2;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.RmtDiagReq)
 private:
  inline void set_has_serial_number();
  inline void clear_has_serial_number();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 serial_number_;
  ::google::protobuf::uint32 time_stamp_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static RmtDiagReq* default_instance_;
};
// -------------------------------------------------------------------

class Fault_List_info : public ::google::protobuf::Message {
 public:
  Fault_List_info();
  virtual ~Fault_List_info();

  Fault_List_info(const Fault_List_info& from);

  inline Fault_List_info& operator=(const Fault_List_info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Fault_List_info& default_instance();

  void Swap(Fault_List_info* other);

  // implements Message ----------------------------------------------

  Fault_List_info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Fault_List_info& from);
  void MergeFrom(const Fault_List_info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 Fault_List_one = 1;
  inline bool has_fault_list_one() const;
  inline void clear_fault_list_one();
  static const int kFaultListOneFieldNumber = 1;
  inline ::google::protobuf::uint32 fault_list_one() const;
  inline void set_fault_list_one(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.Fault_List_info)
 private:
  inline void set_has_fault_list_one();
  inline void clear_has_fault_list_one();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fault_list_one_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static Fault_List_info* default_instance_;
};
// -------------------------------------------------------------------

class FourGExtendCmdRsp : public ::google::protobuf::Message {
 public:
  FourGExtendCmdRsp();
  virtual ~FourGExtendCmdRsp();

  FourGExtendCmdRsp(const FourGExtendCmdRsp& from);

  inline FourGExtendCmdRsp& operator=(const FourGExtendCmdRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FourGExtendCmdRsp& default_instance();

  void Swap(FourGExtendCmdRsp* other);

  // implements Message ----------------------------------------------

  FourGExtendCmdRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FourGExtendCmdRsp& from);
  void MergeFrom(const FourGExtendCmdRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 serial_number = 1;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 serial_number() const;
  inline void set_serial_number(::google::protobuf::uint32 value);

  // required uint32 time_stamp = 2;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 2;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // required uint32 commander_id = 3;
  inline bool has_commander_id() const;
  inline void clear_commander_id();
  static const int kCommanderIdFieldNumber = 3;
  inline ::google::protobuf::uint32 commander_id() const;
  inline void set_commander_id(::google::protobuf::uint32 value);

  // required bytes result_info = 4;
  inline bool has_result_info() const;
  inline void clear_result_info();
  static const int kResultInfoFieldNumber = 4;
  inline const ::std::string& result_info() const;
  inline void set_result_info(const ::std::string& value);
  inline void set_result_info(const char* value);
  inline void set_result_info(const void* value, size_t size);
  inline ::std::string* mutable_result_info();
  inline ::std::string* release_result_info();
  inline void set_allocated_result_info(::std::string* result_info);

  // @@protoc_insertion_point(class_scope:zna.protocol.FourGExtendCmdRsp)
 private:
  inline void set_has_serial_number();
  inline void clear_has_serial_number();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_commander_id();
  inline void clear_has_commander_id();
  inline void set_has_result_info();
  inline void clear_has_result_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 serial_number_;
  ::google::protobuf::uint32 time_stamp_;
  ::std::string* result_info_;
  ::google::protobuf::uint32 commander_id_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static FourGExtendCmdRsp* default_instance_;
};
// -------------------------------------------------------------------

class FourGExtendCmdReq : public ::google::protobuf::Message {
 public:
  FourGExtendCmdReq();
  virtual ~FourGExtendCmdReq();

  FourGExtendCmdReq(const FourGExtendCmdReq& from);

  inline FourGExtendCmdReq& operator=(const FourGExtendCmdReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FourGExtendCmdReq& default_instance();

  void Swap(FourGExtendCmdReq* other);

  // implements Message ----------------------------------------------

  FourGExtendCmdReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FourGExtendCmdReq& from);
  void MergeFrom(const FourGExtendCmdReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 serial_number = 1;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 serial_number() const;
  inline void set_serial_number(::google::protobuf::uint32 value);

  // required uint32 time_stamp = 2;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 2;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // required uint32 commander_id = 3;
  inline bool has_commander_id() const;
  inline void clear_commander_id();
  static const int kCommanderIdFieldNumber = 3;
  inline ::google::protobuf::uint32 commander_id() const;
  inline void set_commander_id(::google::protobuf::uint32 value);

  // required bytes result_info = 4;
  inline bool has_result_info() const;
  inline void clear_result_info();
  static const int kResultInfoFieldNumber = 4;
  inline const ::std::string& result_info() const;
  inline void set_result_info(const ::std::string& value);
  inline void set_result_info(const char* value);
  inline void set_result_info(const void* value, size_t size);
  inline ::std::string* mutable_result_info();
  inline ::std::string* release_result_info();
  inline void set_allocated_result_info(::std::string* result_info);

  // @@protoc_insertion_point(class_scope:zna.protocol.FourGExtendCmdReq)
 private:
  inline void set_has_serial_number();
  inline void clear_has_serial_number();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_commander_id();
  inline void clear_has_commander_id();
  inline void set_has_result_info();
  inline void clear_has_result_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 serial_number_;
  ::google::protobuf::uint32 time_stamp_;
  ::std::string* result_info_;
  ::google::protobuf::uint32 commander_id_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static FourGExtendCmdReq* default_instance_;
};
// -------------------------------------------------------------------

class TCUExtendCmdReq : public ::google::protobuf::Message {
 public:
  TCUExtendCmdReq();
  virtual ~TCUExtendCmdReq();

  TCUExtendCmdReq(const TCUExtendCmdReq& from);

  inline TCUExtendCmdReq& operator=(const TCUExtendCmdReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TCUExtendCmdReq& default_instance();

  void Swap(TCUExtendCmdReq* other);

  // implements Message ----------------------------------------------

  TCUExtendCmdReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TCUExtendCmdReq& from);
  void MergeFrom(const TCUExtendCmdReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 serial_number = 1;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 serial_number() const;
  inline void set_serial_number(::google::protobuf::uint32 value);

  // required uint32 time_stamp = 2;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 2;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // required uint32 commander_id = 3;
  inline bool has_commander_id() const;
  inline void clear_commander_id();
  static const int kCommanderIdFieldNumber = 3;
  inline ::google::protobuf::uint32 commander_id() const;
  inline void set_commander_id(::google::protobuf::uint32 value);

  // required bytes result_info = 4;
  inline bool has_result_info() const;
  inline void clear_result_info();
  static const int kResultInfoFieldNumber = 4;
  inline const ::std::string& result_info() const;
  inline void set_result_info(const ::std::string& value);
  inline void set_result_info(const char* value);
  inline void set_result_info(const void* value, size_t size);
  inline ::std::string* mutable_result_info();
  inline ::std::string* release_result_info();
  inline void set_allocated_result_info(::std::string* result_info);

  // @@protoc_insertion_point(class_scope:zna.protocol.TCUExtendCmdReq)
 private:
  inline void set_has_serial_number();
  inline void clear_has_serial_number();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_commander_id();
  inline void clear_has_commander_id();
  inline void set_has_result_info();
  inline void clear_has_result_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 serial_number_;
  ::google::protobuf::uint32 time_stamp_;
  ::std::string* result_info_;
  ::google::protobuf::uint32 commander_id_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static TCUExtendCmdReq* default_instance_;
};
// -------------------------------------------------------------------

class TCUExtendCmdRsp : public ::google::protobuf::Message {
 public:
  TCUExtendCmdRsp();
  virtual ~TCUExtendCmdRsp();

  TCUExtendCmdRsp(const TCUExtendCmdRsp& from);

  inline TCUExtendCmdRsp& operator=(const TCUExtendCmdRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TCUExtendCmdRsp& default_instance();

  void Swap(TCUExtendCmdRsp* other);

  // implements Message ----------------------------------------------

  TCUExtendCmdRsp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TCUExtendCmdRsp& from);
  void MergeFrom(const TCUExtendCmdRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 serial_number = 1;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 1;
  inline ::google::protobuf::uint32 serial_number() const;
  inline void set_serial_number(::google::protobuf::uint32 value);

  // required uint32 time_stamp = 2;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 2;
  inline ::google::protobuf::uint32 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::uint32 value);

  // required uint32 commander_id = 3;
  inline bool has_commander_id() const;
  inline void clear_commander_id();
  static const int kCommanderIdFieldNumber = 3;
  inline ::google::protobuf::uint32 commander_id() const;
  inline void set_commander_id(::google::protobuf::uint32 value);

  // required bytes result_info = 4;
  inline bool has_result_info() const;
  inline void clear_result_info();
  static const int kResultInfoFieldNumber = 4;
  inline const ::std::string& result_info() const;
  inline void set_result_info(const ::std::string& value);
  inline void set_result_info(const char* value);
  inline void set_result_info(const void* value, size_t size);
  inline ::std::string* mutable_result_info();
  inline ::std::string* release_result_info();
  inline void set_allocated_result_info(::std::string* result_info);

  // @@protoc_insertion_point(class_scope:zna.protocol.TCUExtendCmdRsp)
 private:
  inline void set_has_serial_number();
  inline void clear_has_serial_number();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_commander_id();
  inline void clear_has_commander_id();
  inline void set_has_result_info();
  inline void clear_has_result_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 serial_number_;
  ::google::protobuf::uint32 time_stamp_;
  ::std::string* result_info_;
  ::google::protobuf::uint32 commander_id_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static TCUExtendCmdRsp* default_instance_;
};
// -------------------------------------------------------------------

class FCM_Info : public ::google::protobuf::Message {
 public:
  FCM_Info();
  virtual ~FCM_Info();

  FCM_Info(const FCM_Info& from);

  inline FCM_Info& operator=(const FCM_Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FCM_Info& default_instance();

  void Swap(FCM_Info* other);

  // implements Message ----------------------------------------------

  FCM_Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FCM_Info& from);
  void MergeFrom(const FCM_Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 FCM_LKA_Sys_state = 1;
  inline bool has_fcm_lka_sys_state() const;
  inline void clear_fcm_lka_sys_state();
  static const int kFCMLKASysStateFieldNumber = 1;
  inline ::google::protobuf::uint32 fcm_lka_sys_state() const;
  inline void set_fcm_lka_sys_state(::google::protobuf::uint32 value);

  // optional uint32 FCM_ACC_SysFailure = 2;
  inline bool has_fcm_acc_sysfailure() const;
  inline void clear_fcm_acc_sysfailure();
  static const int kFCMACCSysFailureFieldNumber = 2;
  inline ::google::protobuf::uint32 fcm_acc_sysfailure() const;
  inline void set_fcm_acc_sysfailure(::google::protobuf::uint32 value);

  // optional uint32 FCM_AEB_Failinfo = 3;
  inline bool has_fcm_aeb_failinfo() const;
  inline void clear_fcm_aeb_failinfo();
  static const int kFCMAEBFailinfoFieldNumber = 3;
  inline ::google::protobuf::uint32 fcm_aeb_failinfo() const;
  inline void set_fcm_aeb_failinfo(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.FCM_Info)
 private:
  inline void set_has_fcm_lka_sys_state();
  inline void clear_has_fcm_lka_sys_state();
  inline void set_has_fcm_acc_sysfailure();
  inline void clear_has_fcm_acc_sysfailure();
  inline void set_has_fcm_aeb_failinfo();
  inline void clear_has_fcm_aeb_failinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 fcm_lka_sys_state_;
  ::google::protobuf::uint32 fcm_acc_sysfailure_;
  ::google::protobuf::uint32 fcm_aeb_failinfo_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static FCM_Info* default_instance_;
};
// -------------------------------------------------------------------

class EPS_Info : public ::google::protobuf::Message {
 public:
  EPS_Info();
  virtual ~EPS_Info();

  EPS_Info(const EPS_Info& from);

  inline EPS_Info& operator=(const EPS_Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EPS_Info& default_instance();

  void Swap(EPS_Info* other);

  // implements Message ----------------------------------------------

  EPS_Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EPS_Info& from);
  void MergeFrom(const EPS_Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 EPS_FaultStates = 1;
  inline bool has_eps_faultstates() const;
  inline void clear_eps_faultstates();
  static const int kEPSFaultStatesFieldNumber = 1;
  inline ::google::protobuf::uint32 eps_faultstates() const;
  inline void set_eps_faultstates(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.EPS_Info)
 private:
  inline void set_has_eps_faultstates();
  inline void clear_has_eps_faultstates();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 eps_faultstates_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static EPS_Info* default_instance_;
};
// -------------------------------------------------------------------

class ELD_Info : public ::google::protobuf::Message {
 public:
  ELD_Info();
  virtual ~ELD_Info();

  ELD_Info(const ELD_Info& from);

  inline ELD_Info& operator=(const ELD_Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ELD_Info& default_instance();

  void Swap(ELD_Info* other);

  // implements Message ----------------------------------------------

  ELD_Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ELD_Info& from);
  void MergeFrom(const ELD_Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ELDFaultSts = 1;
  inline bool has_eldfaultsts() const;
  inline void clear_eldfaultsts();
  static const int kELDFaultStsFieldNumber = 1;
  inline ::google::protobuf::uint32 eldfaultsts() const;
  inline void set_eldfaultsts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.ELD_Info)
 private:
  inline void set_has_eldfaultsts();
  inline void clear_has_eldfaultsts();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 eldfaultsts_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static ELD_Info* default_instance_;
};
// -------------------------------------------------------------------

class ECU_Info : public ::google::protobuf::Message {
 public:
  ECU_Info();
  virtual ~ECU_Info();

  ECU_Info(const ECU_Info& from);

  inline ECU_Info& operator=(const ECU_Info& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ECU_Info& default_instance();

  void Swap(ECU_Info* other);

  // implements Message ----------------------------------------------

  ECU_Info* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ECU_Info& from);
  void MergeFrom(const ECU_Info& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 ECMD_48V_FaultStates = 1;
  inline bool has_ecmd_48v_faultstates() const;
  inline void clear_ecmd_48v_faultstates();
  static const int kECMD48VFaultStatesFieldNumber = 1;
  inline ::google::protobuf::uint32 ecmd_48v_faultstates() const;
  inline void set_ecmd_48v_faultstates(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:zna.protocol.ECU_Info)
 private:
  inline void set_has_ecmd_48v_faultstates();
  inline void clear_has_ecmd_48v_faultstates();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ecmd_48v_faultstates_;
  friend void  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static ECU_Info* default_instance_;
};
// ===================================================================


// ===================================================================

// UpgradeInfo

// required string filetype = 1;
inline bool UpgradeInfo::has_filetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpgradeInfo::set_has_filetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpgradeInfo::clear_has_filetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpgradeInfo::clear_filetype() {
  if (filetype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filetype_->clear();
  }
  clear_has_filetype();
}
inline const ::std::string& UpgradeInfo::filetype() const {
  // @@protoc_insertion_point(field_get:zna.protocol.UpgradeInfo.filetype)
  return *filetype_;
}
inline void UpgradeInfo::set_filetype(const ::std::string& value) {
  set_has_filetype();
  if (filetype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filetype_ = new ::std::string;
  }
  filetype_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.UpgradeInfo.filetype)
}
inline void UpgradeInfo::set_filetype(const char* value) {
  set_has_filetype();
  if (filetype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filetype_ = new ::std::string;
  }
  filetype_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.UpgradeInfo.filetype)
}
inline void UpgradeInfo::set_filetype(const char* value, size_t size) {
  set_has_filetype();
  if (filetype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filetype_ = new ::std::string;
  }
  filetype_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.UpgradeInfo.filetype)
}
inline ::std::string* UpgradeInfo::mutable_filetype() {
  set_has_filetype();
  if (filetype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filetype_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.UpgradeInfo.filetype)
  return filetype_;
}
inline ::std::string* UpgradeInfo::release_filetype() {
  clear_has_filetype();
  if (filetype_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filetype_;
    filetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpgradeInfo::set_allocated_filetype(::std::string* filetype) {
  if (filetype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filetype_;
  }
  if (filetype) {
    set_has_filetype();
    filetype_ = filetype;
  } else {
    clear_has_filetype();
    filetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.UpgradeInfo.filetype)
}

// required string filepath = 2;
inline bool UpgradeInfo::has_filepath() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpgradeInfo::set_has_filepath() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpgradeInfo::clear_has_filepath() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpgradeInfo::clear_filepath() {
  if (filepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_->clear();
  }
  clear_has_filepath();
}
inline const ::std::string& UpgradeInfo::filepath() const {
  // @@protoc_insertion_point(field_get:zna.protocol.UpgradeInfo.filepath)
  return *filepath_;
}
inline void UpgradeInfo::set_filepath(const ::std::string& value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.UpgradeInfo.filepath)
}
inline void UpgradeInfo::set_filepath(const char* value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.UpgradeInfo.filepath)
}
inline void UpgradeInfo::set_filepath(const char* value, size_t size) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.UpgradeInfo.filepath)
}
inline ::std::string* UpgradeInfo::mutable_filepath() {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.UpgradeInfo.filepath)
  return filepath_;
}
inline ::std::string* UpgradeInfo::release_filepath() {
  clear_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filepath_;
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpgradeInfo::set_allocated_filepath(::std::string* filepath) {
  if (filepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filepath_;
  }
  if (filepath) {
    set_has_filepath();
    filepath_ = filepath;
  } else {
    clear_has_filepath();
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.UpgradeInfo.filepath)
}

// required string version = 3;
inline bool UpgradeInfo::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpgradeInfo::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpgradeInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpgradeInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& UpgradeInfo::version() const {
  // @@protoc_insertion_point(field_get:zna.protocol.UpgradeInfo.version)
  return *version_;
}
inline void UpgradeInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.UpgradeInfo.version)
}
inline void UpgradeInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.UpgradeInfo.version)
}
inline void UpgradeInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.UpgradeInfo.version)
}
inline ::std::string* UpgradeInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.UpgradeInfo.version)
  return version_;
}
inline ::std::string* UpgradeInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpgradeInfo::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.UpgradeInfo.version)
}

// required uint32 filesize = 4;
inline bool UpgradeInfo::has_filesize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpgradeInfo::set_has_filesize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpgradeInfo::clear_has_filesize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpgradeInfo::clear_filesize() {
  filesize_ = 0u;
  clear_has_filesize();
}
inline ::google::protobuf::uint32 UpgradeInfo::filesize() const {
  // @@protoc_insertion_point(field_get:zna.protocol.UpgradeInfo.filesize)
  return filesize_;
}
inline void UpgradeInfo::set_filesize(::google::protobuf::uint32 value) {
  set_has_filesize();
  filesize_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.UpgradeInfo.filesize)
}

// required bytes md5 = 5;
inline bool UpgradeInfo::has_md5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UpgradeInfo::set_has_md5() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UpgradeInfo::clear_has_md5() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UpgradeInfo::clear_md5() {
  if (md5_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    md5_->clear();
  }
  clear_has_md5();
}
inline const ::std::string& UpgradeInfo::md5() const {
  // @@protoc_insertion_point(field_get:zna.protocol.UpgradeInfo.md5)
  return *md5_;
}
inline void UpgradeInfo::set_md5(const ::std::string& value) {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    md5_ = new ::std::string;
  }
  md5_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.UpgradeInfo.md5)
}
inline void UpgradeInfo::set_md5(const char* value) {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    md5_ = new ::std::string;
  }
  md5_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.UpgradeInfo.md5)
}
inline void UpgradeInfo::set_md5(const void* value, size_t size) {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    md5_ = new ::std::string;
  }
  md5_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.UpgradeInfo.md5)
}
inline ::std::string* UpgradeInfo::mutable_md5() {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    md5_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.UpgradeInfo.md5)
  return md5_;
}
inline ::std::string* UpgradeInfo::release_md5() {
  clear_has_md5();
  if (md5_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = md5_;
    md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpgradeInfo::set_allocated_md5(::std::string* md5) {
  if (md5_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete md5_;
  }
  if (md5) {
    set_has_md5();
    md5_ = md5;
  } else {
    clear_has_md5();
    md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.UpgradeInfo.md5)
}

// optional string rc4 = 6;
inline bool UpgradeInfo::has_rc4() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UpgradeInfo::set_has_rc4() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UpgradeInfo::clear_has_rc4() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UpgradeInfo::clear_rc4() {
  if (rc4_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rc4_->clear();
  }
  clear_has_rc4();
}
inline const ::std::string& UpgradeInfo::rc4() const {
  // @@protoc_insertion_point(field_get:zna.protocol.UpgradeInfo.rc4)
  return *rc4_;
}
inline void UpgradeInfo::set_rc4(const ::std::string& value) {
  set_has_rc4();
  if (rc4_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rc4_ = new ::std::string;
  }
  rc4_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.UpgradeInfo.rc4)
}
inline void UpgradeInfo::set_rc4(const char* value) {
  set_has_rc4();
  if (rc4_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rc4_ = new ::std::string;
  }
  rc4_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.UpgradeInfo.rc4)
}
inline void UpgradeInfo::set_rc4(const char* value, size_t size) {
  set_has_rc4();
  if (rc4_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rc4_ = new ::std::string;
  }
  rc4_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.UpgradeInfo.rc4)
}
inline ::std::string* UpgradeInfo::mutable_rc4() {
  set_has_rc4();
  if (rc4_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    rc4_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.UpgradeInfo.rc4)
  return rc4_;
}
inline ::std::string* UpgradeInfo::release_rc4() {
  clear_has_rc4();
  if (rc4_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = rc4_;
    rc4_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpgradeInfo::set_allocated_rc4(::std::string* rc4) {
  if (rc4_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rc4_;
  }
  if (rc4) {
    set_has_rc4();
    rc4_ = rc4;
  } else {
    clear_has_rc4();
    rc4_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.UpgradeInfo.rc4)
}

// optional bytes sign_md5 = 7;
inline bool UpgradeInfo::has_sign_md5() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UpgradeInfo::set_has_sign_md5() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UpgradeInfo::clear_has_sign_md5() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UpgradeInfo::clear_sign_md5() {
  if (sign_md5_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_md5_->clear();
  }
  clear_has_sign_md5();
}
inline const ::std::string& UpgradeInfo::sign_md5() const {
  // @@protoc_insertion_point(field_get:zna.protocol.UpgradeInfo.sign_md5)
  return *sign_md5_;
}
inline void UpgradeInfo::set_sign_md5(const ::std::string& value) {
  set_has_sign_md5();
  if (sign_md5_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_md5_ = new ::std::string;
  }
  sign_md5_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.UpgradeInfo.sign_md5)
}
inline void UpgradeInfo::set_sign_md5(const char* value) {
  set_has_sign_md5();
  if (sign_md5_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_md5_ = new ::std::string;
  }
  sign_md5_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.UpgradeInfo.sign_md5)
}
inline void UpgradeInfo::set_sign_md5(const void* value, size_t size) {
  set_has_sign_md5();
  if (sign_md5_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_md5_ = new ::std::string;
  }
  sign_md5_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.UpgradeInfo.sign_md5)
}
inline ::std::string* UpgradeInfo::mutable_sign_md5() {
  set_has_sign_md5();
  if (sign_md5_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_md5_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.UpgradeInfo.sign_md5)
  return sign_md5_;
}
inline ::std::string* UpgradeInfo::release_sign_md5() {
  clear_has_sign_md5();
  if (sign_md5_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sign_md5_;
    sign_md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpgradeInfo::set_allocated_sign_md5(::std::string* sign_md5) {
  if (sign_md5_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sign_md5_;
  }
  if (sign_md5) {
    set_has_sign_md5();
    sign_md5_ = sign_md5;
  } else {
    clear_has_sign_md5();
    sign_md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.UpgradeInfo.sign_md5)
}

// optional bytes sha2 = 8;
inline bool UpgradeInfo::has_sha2() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UpgradeInfo::set_has_sha2() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UpgradeInfo::clear_has_sha2() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UpgradeInfo::clear_sha2() {
  if (sha2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sha2_->clear();
  }
  clear_has_sha2();
}
inline const ::std::string& UpgradeInfo::sha2() const {
  // @@protoc_insertion_point(field_get:zna.protocol.UpgradeInfo.sha2)
  return *sha2_;
}
inline void UpgradeInfo::set_sha2(const ::std::string& value) {
  set_has_sha2();
  if (sha2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sha2_ = new ::std::string;
  }
  sha2_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.UpgradeInfo.sha2)
}
inline void UpgradeInfo::set_sha2(const char* value) {
  set_has_sha2();
  if (sha2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sha2_ = new ::std::string;
  }
  sha2_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.UpgradeInfo.sha2)
}
inline void UpgradeInfo::set_sha2(const void* value, size_t size) {
  set_has_sha2();
  if (sha2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sha2_ = new ::std::string;
  }
  sha2_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.UpgradeInfo.sha2)
}
inline ::std::string* UpgradeInfo::mutable_sha2() {
  set_has_sha2();
  if (sha2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sha2_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.UpgradeInfo.sha2)
  return sha2_;
}
inline ::std::string* UpgradeInfo::release_sha2() {
  clear_has_sha2();
  if (sha2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sha2_;
    sha2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpgradeInfo::set_allocated_sha2(::std::string* sha2) {
  if (sha2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sha2_;
  }
  if (sha2) {
    set_has_sha2();
    sha2_ = sha2;
  } else {
    clear_has_sha2();
    sha2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.UpgradeInfo.sha2)
}

// optional string aes128 = 9;
inline bool UpgradeInfo::has_aes128() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UpgradeInfo::set_has_aes128() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UpgradeInfo::clear_has_aes128() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UpgradeInfo::clear_aes128() {
  if (aes128_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    aes128_->clear();
  }
  clear_has_aes128();
}
inline const ::std::string& UpgradeInfo::aes128() const {
  // @@protoc_insertion_point(field_get:zna.protocol.UpgradeInfo.aes128)
  return *aes128_;
}
inline void UpgradeInfo::set_aes128(const ::std::string& value) {
  set_has_aes128();
  if (aes128_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    aes128_ = new ::std::string;
  }
  aes128_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.UpgradeInfo.aes128)
}
inline void UpgradeInfo::set_aes128(const char* value) {
  set_has_aes128();
  if (aes128_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    aes128_ = new ::std::string;
  }
  aes128_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.UpgradeInfo.aes128)
}
inline void UpgradeInfo::set_aes128(const char* value, size_t size) {
  set_has_aes128();
  if (aes128_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    aes128_ = new ::std::string;
  }
  aes128_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.UpgradeInfo.aes128)
}
inline ::std::string* UpgradeInfo::mutable_aes128() {
  set_has_aes128();
  if (aes128_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    aes128_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.UpgradeInfo.aes128)
  return aes128_;
}
inline ::std::string* UpgradeInfo::release_aes128() {
  clear_has_aes128();
  if (aes128_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = aes128_;
    aes128_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpgradeInfo::set_allocated_aes128(::std::string* aes128) {
  if (aes128_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete aes128_;
  }
  if (aes128) {
    set_has_aes128();
    aes128_ = aes128;
  } else {
    clear_has_aes128();
    aes128_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.UpgradeInfo.aes128)
}

// optional bytes sign_sha2 = 10;
inline bool UpgradeInfo::has_sign_sha2() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UpgradeInfo::set_has_sign_sha2() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UpgradeInfo::clear_has_sign_sha2() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UpgradeInfo::clear_sign_sha2() {
  if (sign_sha2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_sha2_->clear();
  }
  clear_has_sign_sha2();
}
inline const ::std::string& UpgradeInfo::sign_sha2() const {
  // @@protoc_insertion_point(field_get:zna.protocol.UpgradeInfo.sign_sha2)
  return *sign_sha2_;
}
inline void UpgradeInfo::set_sign_sha2(const ::std::string& value) {
  set_has_sign_sha2();
  if (sign_sha2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_sha2_ = new ::std::string;
  }
  sign_sha2_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.UpgradeInfo.sign_sha2)
}
inline void UpgradeInfo::set_sign_sha2(const char* value) {
  set_has_sign_sha2();
  if (sign_sha2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_sha2_ = new ::std::string;
  }
  sign_sha2_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.UpgradeInfo.sign_sha2)
}
inline void UpgradeInfo::set_sign_sha2(const void* value, size_t size) {
  set_has_sign_sha2();
  if (sign_sha2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_sha2_ = new ::std::string;
  }
  sign_sha2_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.UpgradeInfo.sign_sha2)
}
inline ::std::string* UpgradeInfo::mutable_sign_sha2() {
  set_has_sign_sha2();
  if (sign_sha2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_sha2_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.UpgradeInfo.sign_sha2)
  return sign_sha2_;
}
inline ::std::string* UpgradeInfo::release_sign_sha2() {
  clear_has_sign_sha2();
  if (sign_sha2_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sign_sha2_;
    sign_sha2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void UpgradeInfo::set_allocated_sign_sha2(::std::string* sign_sha2) {
  if (sign_sha2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sign_sha2_;
  }
  if (sign_sha2) {
    set_has_sign_sha2();
    sign_sha2_ = sign_sha2;
  } else {
    clear_has_sign_sha2();
    sign_sha2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.UpgradeInfo.sign_sha2)
}

// optional uint32 prefilesize = 11;
inline bool UpgradeInfo::has_prefilesize() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UpgradeInfo::set_has_prefilesize() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UpgradeInfo::clear_has_prefilesize() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UpgradeInfo::clear_prefilesize() {
  prefilesize_ = 0u;
  clear_has_prefilesize();
}
inline ::google::protobuf::uint32 UpgradeInfo::prefilesize() const {
  // @@protoc_insertion_point(field_get:zna.protocol.UpgradeInfo.prefilesize)
  return prefilesize_;
}
inline void UpgradeInfo::set_prefilesize(::google::protobuf::uint32 value) {
  set_has_prefilesize();
  prefilesize_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.UpgradeInfo.prefilesize)
}

// optional uint32 encrypt_type = 12;
inline bool UpgradeInfo::has_encrypt_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UpgradeInfo::set_has_encrypt_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UpgradeInfo::clear_has_encrypt_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UpgradeInfo::clear_encrypt_type() {
  encrypt_type_ = 0u;
  clear_has_encrypt_type();
}
inline ::google::protobuf::uint32 UpgradeInfo::encrypt_type() const {
  // @@protoc_insertion_point(field_get:zna.protocol.UpgradeInfo.encrypt_type)
  return encrypt_type_;
}
inline void UpgradeInfo::set_encrypt_type(::google::protobuf::uint32 value) {
  set_has_encrypt_type();
  encrypt_type_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.UpgradeInfo.encrypt_type)
}

// -------------------------------------------------------------------

// LoginReq

// required string tcu_device_sn = 1;
inline bool LoginReq::has_tcu_device_sn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginReq::set_has_tcu_device_sn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginReq::clear_has_tcu_device_sn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginReq::clear_tcu_device_sn() {
  if (tcu_device_sn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tcu_device_sn_->clear();
  }
  clear_has_tcu_device_sn();
}
inline const ::std::string& LoginReq::tcu_device_sn() const {
  // @@protoc_insertion_point(field_get:zna.protocol.LoginReq.tcu_device_sn)
  return *tcu_device_sn_;
}
inline void LoginReq::set_tcu_device_sn(const ::std::string& value) {
  set_has_tcu_device_sn();
  if (tcu_device_sn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tcu_device_sn_ = new ::std::string;
  }
  tcu_device_sn_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.LoginReq.tcu_device_sn)
}
inline void LoginReq::set_tcu_device_sn(const char* value) {
  set_has_tcu_device_sn();
  if (tcu_device_sn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tcu_device_sn_ = new ::std::string;
  }
  tcu_device_sn_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.LoginReq.tcu_device_sn)
}
inline void LoginReq::set_tcu_device_sn(const char* value, size_t size) {
  set_has_tcu_device_sn();
  if (tcu_device_sn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tcu_device_sn_ = new ::std::string;
  }
  tcu_device_sn_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.LoginReq.tcu_device_sn)
}
inline ::std::string* LoginReq::mutable_tcu_device_sn() {
  set_has_tcu_device_sn();
  if (tcu_device_sn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tcu_device_sn_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.LoginReq.tcu_device_sn)
  return tcu_device_sn_;
}
inline ::std::string* LoginReq::release_tcu_device_sn() {
  clear_has_tcu_device_sn();
  if (tcu_device_sn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tcu_device_sn_;
    tcu_device_sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginReq::set_allocated_tcu_device_sn(::std::string* tcu_device_sn) {
  if (tcu_device_sn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tcu_device_sn_;
  }
  if (tcu_device_sn) {
    set_has_tcu_device_sn();
    tcu_device_sn_ = tcu_device_sn;
  } else {
    clear_has_tcu_device_sn();
    tcu_device_sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.LoginReq.tcu_device_sn)
}

// required string da_device_sn = 2;
inline bool LoginReq::has_da_device_sn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginReq::set_has_da_device_sn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginReq::clear_has_da_device_sn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginReq::clear_da_device_sn() {
  if (da_device_sn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    da_device_sn_->clear();
  }
  clear_has_da_device_sn();
}
inline const ::std::string& LoginReq::da_device_sn() const {
  // @@protoc_insertion_point(field_get:zna.protocol.LoginReq.da_device_sn)
  return *da_device_sn_;
}
inline void LoginReq::set_da_device_sn(const ::std::string& value) {
  set_has_da_device_sn();
  if (da_device_sn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    da_device_sn_ = new ::std::string;
  }
  da_device_sn_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.LoginReq.da_device_sn)
}
inline void LoginReq::set_da_device_sn(const char* value) {
  set_has_da_device_sn();
  if (da_device_sn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    da_device_sn_ = new ::std::string;
  }
  da_device_sn_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.LoginReq.da_device_sn)
}
inline void LoginReq::set_da_device_sn(const char* value, size_t size) {
  set_has_da_device_sn();
  if (da_device_sn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    da_device_sn_ = new ::std::string;
  }
  da_device_sn_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.LoginReq.da_device_sn)
}
inline ::std::string* LoginReq::mutable_da_device_sn() {
  set_has_da_device_sn();
  if (da_device_sn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    da_device_sn_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.LoginReq.da_device_sn)
  return da_device_sn_;
}
inline ::std::string* LoginReq::release_da_device_sn() {
  clear_has_da_device_sn();
  if (da_device_sn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = da_device_sn_;
    da_device_sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginReq::set_allocated_da_device_sn(::std::string* da_device_sn) {
  if (da_device_sn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete da_device_sn_;
  }
  if (da_device_sn) {
    set_has_da_device_sn();
    da_device_sn_ = da_device_sn;
  } else {
    clear_has_da_device_sn();
    da_device_sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.LoginReq.da_device_sn)
}

// required string vin = 3;
inline bool LoginReq::has_vin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginReq::set_has_vin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginReq::clear_has_vin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginReq::clear_vin() {
  if (vin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vin_->clear();
  }
  clear_has_vin();
}
inline const ::std::string& LoginReq::vin() const {
  // @@protoc_insertion_point(field_get:zna.protocol.LoginReq.vin)
  return *vin_;
}
inline void LoginReq::set_vin(const ::std::string& value) {
  set_has_vin();
  if (vin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vin_ = new ::std::string;
  }
  vin_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.LoginReq.vin)
}
inline void LoginReq::set_vin(const char* value) {
  set_has_vin();
  if (vin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vin_ = new ::std::string;
  }
  vin_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.LoginReq.vin)
}
inline void LoginReq::set_vin(const char* value, size_t size) {
  set_has_vin();
  if (vin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vin_ = new ::std::string;
  }
  vin_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.LoginReq.vin)
}
inline ::std::string* LoginReq::mutable_vin() {
  set_has_vin();
  if (vin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vin_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.LoginReq.vin)
  return vin_;
}
inline ::std::string* LoginReq::release_vin() {
  clear_has_vin();
  if (vin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vin_;
    vin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginReq::set_allocated_vin(::std::string* vin) {
  if (vin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vin_;
  }
  if (vin) {
    set_has_vin();
    vin_ = vin;
  } else {
    clear_has_vin();
    vin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.LoginReq.vin)
}

// required string iccid = 4;
inline bool LoginReq::has_iccid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginReq::set_has_iccid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginReq::clear_has_iccid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginReq::clear_iccid() {
  if (iccid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iccid_->clear();
  }
  clear_has_iccid();
}
inline const ::std::string& LoginReq::iccid() const {
  // @@protoc_insertion_point(field_get:zna.protocol.LoginReq.iccid)
  return *iccid_;
}
inline void LoginReq::set_iccid(const ::std::string& value) {
  set_has_iccid();
  if (iccid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iccid_ = new ::std::string;
  }
  iccid_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.LoginReq.iccid)
}
inline void LoginReq::set_iccid(const char* value) {
  set_has_iccid();
  if (iccid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iccid_ = new ::std::string;
  }
  iccid_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.LoginReq.iccid)
}
inline void LoginReq::set_iccid(const char* value, size_t size) {
  set_has_iccid();
  if (iccid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iccid_ = new ::std::string;
  }
  iccid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.LoginReq.iccid)
}
inline ::std::string* LoginReq::mutable_iccid() {
  set_has_iccid();
  if (iccid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iccid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.LoginReq.iccid)
  return iccid_;
}
inline ::std::string* LoginReq::release_iccid() {
  clear_has_iccid();
  if (iccid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = iccid_;
    iccid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginReq::set_allocated_iccid(::std::string* iccid) {
  if (iccid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete iccid_;
  }
  if (iccid) {
    set_has_iccid();
    iccid_ = iccid;
  } else {
    clear_has_iccid();
    iccid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.LoginReq.iccid)
}

// required string imsi = 5;
inline bool LoginReq::has_imsi() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginReq::set_has_imsi() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginReq::clear_has_imsi() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginReq::clear_imsi() {
  if (imsi_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imsi_->clear();
  }
  clear_has_imsi();
}
inline const ::std::string& LoginReq::imsi() const {
  // @@protoc_insertion_point(field_get:zna.protocol.LoginReq.imsi)
  return *imsi_;
}
inline void LoginReq::set_imsi(const ::std::string& value) {
  set_has_imsi();
  if (imsi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imsi_ = new ::std::string;
  }
  imsi_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.LoginReq.imsi)
}
inline void LoginReq::set_imsi(const char* value) {
  set_has_imsi();
  if (imsi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imsi_ = new ::std::string;
  }
  imsi_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.LoginReq.imsi)
}
inline void LoginReq::set_imsi(const char* value, size_t size) {
  set_has_imsi();
  if (imsi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imsi_ = new ::std::string;
  }
  imsi_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.LoginReq.imsi)
}
inline ::std::string* LoginReq::mutable_imsi() {
  set_has_imsi();
  if (imsi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imsi_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.LoginReq.imsi)
  return imsi_;
}
inline ::std::string* LoginReq::release_imsi() {
  clear_has_imsi();
  if (imsi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = imsi_;
    imsi_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginReq::set_allocated_imsi(::std::string* imsi) {
  if (imsi_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imsi_;
  }
  if (imsi) {
    set_has_imsi();
    imsi_ = imsi;
  } else {
    clear_has_imsi();
    imsi_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.LoginReq.imsi)
}

// required string imei = 6;
inline bool LoginReq::has_imei() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginReq::set_has_imei() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginReq::clear_has_imei() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginReq::clear_imei() {
  if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_->clear();
  }
  clear_has_imei();
}
inline const ::std::string& LoginReq::imei() const {
  // @@protoc_insertion_point(field_get:zna.protocol.LoginReq.imei)
  return *imei_;
}
inline void LoginReq::set_imei(const ::std::string& value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.LoginReq.imei)
}
inline void LoginReq::set_imei(const char* value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.LoginReq.imei)
}
inline void LoginReq::set_imei(const char* value, size_t size) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.LoginReq.imei)
}
inline ::std::string* LoginReq::mutable_imei() {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.LoginReq.imei)
  return imei_;
}
inline ::std::string* LoginReq::release_imei() {
  clear_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = imei_;
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginReq::set_allocated_imei(::std::string* imei) {
  if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imei_;
  }
  if (imei) {
    set_has_imei();
    imei_ = imei;
  } else {
    clear_has_imei();
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.LoginReq.imei)
}

// required string software_version = 7;
inline bool LoginReq::has_software_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginReq::set_has_software_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginReq::clear_has_software_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginReq::clear_software_version() {
  if (software_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    software_version_->clear();
  }
  clear_has_software_version();
}
inline const ::std::string& LoginReq::software_version() const {
  // @@protoc_insertion_point(field_get:zna.protocol.LoginReq.software_version)
  return *software_version_;
}
inline void LoginReq::set_software_version(const ::std::string& value) {
  set_has_software_version();
  if (software_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    software_version_ = new ::std::string;
  }
  software_version_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.LoginReq.software_version)
}
inline void LoginReq::set_software_version(const char* value) {
  set_has_software_version();
  if (software_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    software_version_ = new ::std::string;
  }
  software_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.LoginReq.software_version)
}
inline void LoginReq::set_software_version(const char* value, size_t size) {
  set_has_software_version();
  if (software_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    software_version_ = new ::std::string;
  }
  software_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.LoginReq.software_version)
}
inline ::std::string* LoginReq::mutable_software_version() {
  set_has_software_version();
  if (software_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    software_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.LoginReq.software_version)
  return software_version_;
}
inline ::std::string* LoginReq::release_software_version() {
  clear_has_software_version();
  if (software_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = software_version_;
    software_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginReq::set_allocated_software_version(::std::string* software_version) {
  if (software_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete software_version_;
  }
  if (software_version) {
    set_has_software_version();
    software_version_ = software_version;
  } else {
    clear_has_software_version();
    software_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.LoginReq.software_version)
}

// required string hardware_version = 8;
inline bool LoginReq::has_hardware_version() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoginReq::set_has_hardware_version() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoginReq::clear_has_hardware_version() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoginReq::clear_hardware_version() {
  if (hardware_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hardware_version_->clear();
  }
  clear_has_hardware_version();
}
inline const ::std::string& LoginReq::hardware_version() const {
  // @@protoc_insertion_point(field_get:zna.protocol.LoginReq.hardware_version)
  return *hardware_version_;
}
inline void LoginReq::set_hardware_version(const ::std::string& value) {
  set_has_hardware_version();
  if (hardware_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hardware_version_ = new ::std::string;
  }
  hardware_version_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.LoginReq.hardware_version)
}
inline void LoginReq::set_hardware_version(const char* value) {
  set_has_hardware_version();
  if (hardware_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hardware_version_ = new ::std::string;
  }
  hardware_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.LoginReq.hardware_version)
}
inline void LoginReq::set_hardware_version(const char* value, size_t size) {
  set_has_hardware_version();
  if (hardware_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hardware_version_ = new ::std::string;
  }
  hardware_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.LoginReq.hardware_version)
}
inline ::std::string* LoginReq::mutable_hardware_version() {
  set_has_hardware_version();
  if (hardware_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hardware_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.LoginReq.hardware_version)
  return hardware_version_;
}
inline ::std::string* LoginReq::release_hardware_version() {
  clear_has_hardware_version();
  if (hardware_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hardware_version_;
    hardware_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginReq::set_allocated_hardware_version(::std::string* hardware_version) {
  if (hardware_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hardware_version_;
  }
  if (hardware_version) {
    set_has_hardware_version();
    hardware_version_ = hardware_version;
  } else {
    clear_has_hardware_version();
    hardware_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.LoginReq.hardware_version)
}

// required uint32 time_stamp = 9;
inline bool LoginReq::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LoginReq::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LoginReq::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LoginReq::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 LoginReq::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.LoginReq.time_stamp)
  return time_stamp_;
}
inline void LoginReq::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.LoginReq.time_stamp)
}

// optional string g4_version = 10;
inline bool LoginReq::has_g4_version() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LoginReq::set_has_g4_version() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LoginReq::clear_has_g4_version() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LoginReq::clear_g4_version() {
  if (g4_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    g4_version_->clear();
  }
  clear_has_g4_version();
}
inline const ::std::string& LoginReq::g4_version() const {
  // @@protoc_insertion_point(field_get:zna.protocol.LoginReq.g4_version)
  return *g4_version_;
}
inline void LoginReq::set_g4_version(const ::std::string& value) {
  set_has_g4_version();
  if (g4_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    g4_version_ = new ::std::string;
  }
  g4_version_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.LoginReq.g4_version)
}
inline void LoginReq::set_g4_version(const char* value) {
  set_has_g4_version();
  if (g4_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    g4_version_ = new ::std::string;
  }
  g4_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.LoginReq.g4_version)
}
inline void LoginReq::set_g4_version(const char* value, size_t size) {
  set_has_g4_version();
  if (g4_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    g4_version_ = new ::std::string;
  }
  g4_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.LoginReq.g4_version)
}
inline ::std::string* LoginReq::mutable_g4_version() {
  set_has_g4_version();
  if (g4_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    g4_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.LoginReq.g4_version)
  return g4_version_;
}
inline ::std::string* LoginReq::release_g4_version() {
  clear_has_g4_version();
  if (g4_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = g4_version_;
    g4_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginReq::set_allocated_g4_version(::std::string* g4_version) {
  if (g4_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete g4_version_;
  }
  if (g4_version) {
    set_has_g4_version();
    g4_version_ = g4_version;
  } else {
    clear_has_g4_version();
    g4_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.LoginReq.g4_version)
}

// optional string vehicle_type = 11;
inline bool LoginReq::has_vehicle_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LoginReq::set_has_vehicle_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LoginReq::clear_has_vehicle_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LoginReq::clear_vehicle_type() {
  if (vehicle_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vehicle_type_->clear();
  }
  clear_has_vehicle_type();
}
inline const ::std::string& LoginReq::vehicle_type() const {
  // @@protoc_insertion_point(field_get:zna.protocol.LoginReq.vehicle_type)
  return *vehicle_type_;
}
inline void LoginReq::set_vehicle_type(const ::std::string& value) {
  set_has_vehicle_type();
  if (vehicle_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vehicle_type_ = new ::std::string;
  }
  vehicle_type_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.LoginReq.vehicle_type)
}
inline void LoginReq::set_vehicle_type(const char* value) {
  set_has_vehicle_type();
  if (vehicle_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vehicle_type_ = new ::std::string;
  }
  vehicle_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.LoginReq.vehicle_type)
}
inline void LoginReq::set_vehicle_type(const char* value, size_t size) {
  set_has_vehicle_type();
  if (vehicle_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vehicle_type_ = new ::std::string;
  }
  vehicle_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.LoginReq.vehicle_type)
}
inline ::std::string* LoginReq::mutable_vehicle_type() {
  set_has_vehicle_type();
  if (vehicle_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vehicle_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.LoginReq.vehicle_type)
  return vehicle_type_;
}
inline ::std::string* LoginReq::release_vehicle_type() {
  clear_has_vehicle_type();
  if (vehicle_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vehicle_type_;
    vehicle_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginReq::set_allocated_vehicle_type(::std::string* vehicle_type) {
  if (vehicle_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vehicle_type_;
  }
  if (vehicle_type) {
    set_has_vehicle_type();
    vehicle_type_ = vehicle_type;
  } else {
    clear_has_vehicle_type();
    vehicle_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.LoginReq.vehicle_type)
}

// optional bool upgrading = 12;
inline bool LoginReq::has_upgrading() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LoginReq::set_has_upgrading() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LoginReq::clear_has_upgrading() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LoginReq::clear_upgrading() {
  upgrading_ = false;
  clear_has_upgrading();
}
inline bool LoginReq::upgrading() const {
  // @@protoc_insertion_point(field_get:zna.protocol.LoginReq.upgrading)
  return upgrading_;
}
inline void LoginReq::set_upgrading(bool value) {
  set_has_upgrading();
  upgrading_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.LoginReq.upgrading)
}

// optional bool bcm_reg_status = 13;
inline bool LoginReq::has_bcm_reg_status() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LoginReq::set_has_bcm_reg_status() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LoginReq::clear_has_bcm_reg_status() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LoginReq::clear_bcm_reg_status() {
  bcm_reg_status_ = false;
  clear_has_bcm_reg_status();
}
inline bool LoginReq::bcm_reg_status() const {
  // @@protoc_insertion_point(field_get:zna.protocol.LoginReq.bcm_reg_status)
  return bcm_reg_status_;
}
inline void LoginReq::set_bcm_reg_status(bool value) {
  set_has_bcm_reg_status();
  bcm_reg_status_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.LoginReq.bcm_reg_status)
}

// optional uint32 ota_algrithom = 14;
inline bool LoginReq::has_ota_algrithom() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LoginReq::set_has_ota_algrithom() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LoginReq::clear_has_ota_algrithom() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LoginReq::clear_ota_algrithom() {
  ota_algrithom_ = 0u;
  clear_has_ota_algrithom();
}
inline ::google::protobuf::uint32 LoginReq::ota_algrithom() const {
  // @@protoc_insertion_point(field_get:zna.protocol.LoginReq.ota_algrithom)
  return ota_algrithom_;
}
inline void LoginReq::set_ota_algrithom(::google::protobuf::uint32 value) {
  set_has_ota_algrithom();
  ota_algrithom_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.LoginReq.ota_algrithom)
}

// -------------------------------------------------------------------

// LoginRsp

// required uint32 errcode = 1;
inline bool LoginRsp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRsp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRsp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRsp::clear_errcode() {
  errcode_ = 0u;
  clear_has_errcode();
}
inline ::google::protobuf::uint32 LoginRsp::errcode() const {
  // @@protoc_insertion_point(field_get:zna.protocol.LoginRsp.errcode)
  return errcode_;
}
inline void LoginRsp::set_errcode(::google::protobuf::uint32 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.LoginRsp.errcode)
}

// required uint32 time_stamp = 2;
inline bool LoginRsp::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRsp::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRsp::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRsp::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 LoginRsp::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.LoginRsp.time_stamp)
  return time_stamp_;
}
inline void LoginRsp::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.LoginRsp.time_stamp)
}

// repeated .zna.protocol.UpgradeInfo upgradeinfo = 3;
inline int LoginRsp::upgradeinfo_size() const {
  return upgradeinfo_.size();
}
inline void LoginRsp::clear_upgradeinfo() {
  upgradeinfo_.Clear();
}
inline const ::zna::protocol::UpgradeInfo& LoginRsp::upgradeinfo(int index) const {
  // @@protoc_insertion_point(field_get:zna.protocol.LoginRsp.upgradeinfo)
  return upgradeinfo_.Get(index);
}
inline ::zna::protocol::UpgradeInfo* LoginRsp::mutable_upgradeinfo(int index) {
  // @@protoc_insertion_point(field_mutable:zna.protocol.LoginRsp.upgradeinfo)
  return upgradeinfo_.Mutable(index);
}
inline ::zna::protocol::UpgradeInfo* LoginRsp::add_upgradeinfo() {
  // @@protoc_insertion_point(field_add:zna.protocol.LoginRsp.upgradeinfo)
  return upgradeinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zna::protocol::UpgradeInfo >&
LoginRsp::upgradeinfo() const {
  // @@protoc_insertion_point(field_list:zna.protocol.LoginRsp.upgradeinfo)
  return upgradeinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::zna::protocol::UpgradeInfo >*
LoginRsp::mutable_upgradeinfo() {
  // @@protoc_insertion_point(field_mutable_list:zna.protocol.LoginRsp.upgradeinfo)
  return &upgradeinfo_;
}

// -------------------------------------------------------------------

// HeartbeatReq

// required uint32 time_stamp = 1;
inline bool HeartbeatReq::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatReq::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatReq::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatReq::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 HeartbeatReq::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.HeartbeatReq.time_stamp)
  return time_stamp_;
}
inline void HeartbeatReq::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.HeartbeatReq.time_stamp)
}

// -------------------------------------------------------------------

// HeartbeatRsp

// required uint32 errcode = 1;
inline bool HeartbeatRsp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatRsp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatRsp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatRsp::clear_errcode() {
  errcode_ = 0u;
  clear_has_errcode();
}
inline ::google::protobuf::uint32 HeartbeatRsp::errcode() const {
  // @@protoc_insertion_point(field_get:zna.protocol.HeartbeatRsp.errcode)
  return errcode_;
}
inline void HeartbeatRsp::set_errcode(::google::protobuf::uint32 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.HeartbeatRsp.errcode)
}

// required uint32 time_stamp = 2;
inline bool HeartbeatRsp::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartbeatRsp::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeartbeatRsp::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeartbeatRsp::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 HeartbeatRsp::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.HeartbeatRsp.time_stamp)
  return time_stamp_;
}
inline void HeartbeatRsp::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.HeartbeatRsp.time_stamp)
}

// -------------------------------------------------------------------

// SendRSAReq

// required uint32 N_len = 1;
inline bool SendRSAReq::has_n_len() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendRSAReq::set_has_n_len() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendRSAReq::clear_has_n_len() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendRSAReq::clear_n_len() {
  n_len_ = 0u;
  clear_has_n_len();
}
inline ::google::protobuf::uint32 SendRSAReq::n_len() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SendRSAReq.N_len)
  return n_len_;
}
inline void SendRSAReq::set_n_len(::google::protobuf::uint32 value) {
  set_has_n_len();
  n_len_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SendRSAReq.N_len)
}

// required string N_string = 2;
inline bool SendRSAReq::has_n_string() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendRSAReq::set_has_n_string() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendRSAReq::clear_has_n_string() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendRSAReq::clear_n_string() {
  if (n_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    n_string_->clear();
  }
  clear_has_n_string();
}
inline const ::std::string& SendRSAReq::n_string() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SendRSAReq.N_string)
  return *n_string_;
}
inline void SendRSAReq::set_n_string(const ::std::string& value) {
  set_has_n_string();
  if (n_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    n_string_ = new ::std::string;
  }
  n_string_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.SendRSAReq.N_string)
}
inline void SendRSAReq::set_n_string(const char* value) {
  set_has_n_string();
  if (n_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    n_string_ = new ::std::string;
  }
  n_string_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.SendRSAReq.N_string)
}
inline void SendRSAReq::set_n_string(const char* value, size_t size) {
  set_has_n_string();
  if (n_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    n_string_ = new ::std::string;
  }
  n_string_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.SendRSAReq.N_string)
}
inline ::std::string* SendRSAReq::mutable_n_string() {
  set_has_n_string();
  if (n_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    n_string_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.SendRSAReq.N_string)
  return n_string_;
}
inline ::std::string* SendRSAReq::release_n_string() {
  clear_has_n_string();
  if (n_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = n_string_;
    n_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendRSAReq::set_allocated_n_string(::std::string* n_string) {
  if (n_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete n_string_;
  }
  if (n_string) {
    set_has_n_string();
    n_string_ = n_string;
  } else {
    clear_has_n_string();
    n_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.SendRSAReq.N_string)
}

// required uint32 E1_len = 3;
inline bool SendRSAReq::has_e1_len() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendRSAReq::set_has_e1_len() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendRSAReq::clear_has_e1_len() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendRSAReq::clear_e1_len() {
  e1_len_ = 0u;
  clear_has_e1_len();
}
inline ::google::protobuf::uint32 SendRSAReq::e1_len() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SendRSAReq.E1_len)
  return e1_len_;
}
inline void SendRSAReq::set_e1_len(::google::protobuf::uint32 value) {
  set_has_e1_len();
  e1_len_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SendRSAReq.E1_len)
}

// required string E1_string = 4;
inline bool SendRSAReq::has_e1_string() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SendRSAReq::set_has_e1_string() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SendRSAReq::clear_has_e1_string() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SendRSAReq::clear_e1_string() {
  if (e1_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    e1_string_->clear();
  }
  clear_has_e1_string();
}
inline const ::std::string& SendRSAReq::e1_string() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SendRSAReq.E1_string)
  return *e1_string_;
}
inline void SendRSAReq::set_e1_string(const ::std::string& value) {
  set_has_e1_string();
  if (e1_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    e1_string_ = new ::std::string;
  }
  e1_string_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.SendRSAReq.E1_string)
}
inline void SendRSAReq::set_e1_string(const char* value) {
  set_has_e1_string();
  if (e1_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    e1_string_ = new ::std::string;
  }
  e1_string_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.SendRSAReq.E1_string)
}
inline void SendRSAReq::set_e1_string(const char* value, size_t size) {
  set_has_e1_string();
  if (e1_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    e1_string_ = new ::std::string;
  }
  e1_string_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.SendRSAReq.E1_string)
}
inline ::std::string* SendRSAReq::mutable_e1_string() {
  set_has_e1_string();
  if (e1_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    e1_string_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.SendRSAReq.E1_string)
  return e1_string_;
}
inline ::std::string* SendRSAReq::release_e1_string() {
  clear_has_e1_string();
  if (e1_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = e1_string_;
    e1_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendRSAReq::set_allocated_e1_string(::std::string* e1_string) {
  if (e1_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete e1_string_;
  }
  if (e1_string) {
    set_has_e1_string();
    e1_string_ = e1_string;
  } else {
    clear_has_e1_string();
    e1_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.SendRSAReq.E1_string)
}

// required uint32 time_stamp = 5;
inline bool SendRSAReq::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SendRSAReq::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SendRSAReq::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SendRSAReq::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 SendRSAReq::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SendRSAReq.time_stamp)
  return time_stamp_;
}
inline void SendRSAReq::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SendRSAReq.time_stamp)
}

// -------------------------------------------------------------------

// SendRC4Rsp

// required uint32 errcode = 1;
inline bool SendRC4Rsp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendRC4Rsp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendRC4Rsp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendRC4Rsp::clear_errcode() {
  errcode_ = 0u;
  clear_has_errcode();
}
inline ::google::protobuf::uint32 SendRC4Rsp::errcode() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SendRC4Rsp.errcode)
  return errcode_;
}
inline void SendRC4Rsp::set_errcode(::google::protobuf::uint32 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SendRC4Rsp.errcode)
}

// required uint32 serial_number = 2;
inline bool SendRC4Rsp::has_serial_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendRC4Rsp::set_has_serial_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendRC4Rsp::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendRC4Rsp::clear_serial_number() {
  serial_number_ = 0u;
  clear_has_serial_number();
}
inline ::google::protobuf::uint32 SendRC4Rsp::serial_number() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SendRC4Rsp.serial_number)
  return serial_number_;
}
inline void SendRC4Rsp::set_serial_number(::google::protobuf::uint32 value) {
  set_has_serial_number();
  serial_number_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SendRC4Rsp.serial_number)
}

// required uint32 time_stamp = 3;
inline bool SendRC4Rsp::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendRC4Rsp::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendRC4Rsp::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendRC4Rsp::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 SendRC4Rsp::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SendRC4Rsp.time_stamp)
  return time_stamp_;
}
inline void SendRC4Rsp::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SendRC4Rsp.time_stamp)
}

// -------------------------------------------------------------------

// SetParameterRsp

// required uint32 errcode = 1;
inline bool SetParameterRsp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetParameterRsp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetParameterRsp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetParameterRsp::clear_errcode() {
  errcode_ = 0u;
  clear_has_errcode();
}
inline ::google::protobuf::uint32 SetParameterRsp::errcode() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SetParameterRsp.errcode)
  return errcode_;
}
inline void SetParameterRsp::set_errcode(::google::protobuf::uint32 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SetParameterRsp.errcode)
}

// required uint32 time_stamp = 2;
inline bool SetParameterRsp::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetParameterRsp::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetParameterRsp::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetParameterRsp::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 SetParameterRsp::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SetParameterRsp.time_stamp)
  return time_stamp_;
}
inline void SetParameterRsp::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SetParameterRsp.time_stamp)
}

// -------------------------------------------------------------------

// SetParameterReq

// required uint32 local_storage_cycle = 1;
inline bool SetParameterReq::has_local_storage_cycle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetParameterReq::set_has_local_storage_cycle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetParameterReq::clear_has_local_storage_cycle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetParameterReq::clear_local_storage_cycle() {
  local_storage_cycle_ = 0u;
  clear_has_local_storage_cycle();
}
inline ::google::protobuf::uint32 SetParameterReq::local_storage_cycle() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SetParameterReq.local_storage_cycle)
  return local_storage_cycle_;
}
inline void SetParameterReq::set_local_storage_cycle(::google::protobuf::uint32 value) {
  set_has_local_storage_cycle();
  local_storage_cycle_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SetParameterReq.local_storage_cycle)
}

// required uint32 upload_data_cycle_normal = 2;
inline bool SetParameterReq::has_upload_data_cycle_normal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetParameterReq::set_has_upload_data_cycle_normal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetParameterReq::clear_has_upload_data_cycle_normal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetParameterReq::clear_upload_data_cycle_normal() {
  upload_data_cycle_normal_ = 0u;
  clear_has_upload_data_cycle_normal();
}
inline ::google::protobuf::uint32 SetParameterReq::upload_data_cycle_normal() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SetParameterReq.upload_data_cycle_normal)
  return upload_data_cycle_normal_;
}
inline void SetParameterReq::set_upload_data_cycle_normal(::google::protobuf::uint32 value) {
  set_has_upload_data_cycle_normal();
  upload_data_cycle_normal_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SetParameterReq.upload_data_cycle_normal)
}

// required uint32 upload_GPS_cycle_normal = 3;
inline bool SetParameterReq::has_upload_gps_cycle_normal() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetParameterReq::set_has_upload_gps_cycle_normal() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetParameterReq::clear_has_upload_gps_cycle_normal() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetParameterReq::clear_upload_gps_cycle_normal() {
  upload_gps_cycle_normal_ = 0u;
  clear_has_upload_gps_cycle_normal();
}
inline ::google::protobuf::uint32 SetParameterReq::upload_gps_cycle_normal() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SetParameterReq.upload_GPS_cycle_normal)
  return upload_gps_cycle_normal_;
}
inline void SetParameterReq::set_upload_gps_cycle_normal(::google::protobuf::uint32 value) {
  set_has_upload_gps_cycle_normal();
  upload_gps_cycle_normal_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SetParameterReq.upload_GPS_cycle_normal)
}

// required uint32 upload_data_cycle_alarm = 4;
inline bool SetParameterReq::has_upload_data_cycle_alarm() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetParameterReq::set_has_upload_data_cycle_alarm() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetParameterReq::clear_has_upload_data_cycle_alarm() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetParameterReq::clear_upload_data_cycle_alarm() {
  upload_data_cycle_alarm_ = 0u;
  clear_has_upload_data_cycle_alarm();
}
inline ::google::protobuf::uint32 SetParameterReq::upload_data_cycle_alarm() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SetParameterReq.upload_data_cycle_alarm)
  return upload_data_cycle_alarm_;
}
inline void SetParameterReq::set_upload_data_cycle_alarm(::google::protobuf::uint32 value) {
  set_has_upload_data_cycle_alarm();
  upload_data_cycle_alarm_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SetParameterReq.upload_data_cycle_alarm)
}

// required uint32 upload_GPS_cycle_alarm = 5;
inline bool SetParameterReq::has_upload_gps_cycle_alarm() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SetParameterReq::set_has_upload_gps_cycle_alarm() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SetParameterReq::clear_has_upload_gps_cycle_alarm() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SetParameterReq::clear_upload_gps_cycle_alarm() {
  upload_gps_cycle_alarm_ = 0u;
  clear_has_upload_gps_cycle_alarm();
}
inline ::google::protobuf::uint32 SetParameterReq::upload_gps_cycle_alarm() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SetParameterReq.upload_GPS_cycle_alarm)
  return upload_gps_cycle_alarm_;
}
inline void SetParameterReq::set_upload_gps_cycle_alarm(::google::protobuf::uint32 value) {
  set_has_upload_gps_cycle_alarm();
  upload_gps_cycle_alarm_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SetParameterReq.upload_GPS_cycle_alarm)
}

// optional uint32 heartbeat_cycle = 6;
inline bool SetParameterReq::has_heartbeat_cycle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SetParameterReq::set_has_heartbeat_cycle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SetParameterReq::clear_has_heartbeat_cycle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SetParameterReq::clear_heartbeat_cycle() {
  heartbeat_cycle_ = 0u;
  clear_has_heartbeat_cycle();
}
inline ::google::protobuf::uint32 SetParameterReq::heartbeat_cycle() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SetParameterReq.heartbeat_cycle)
  return heartbeat_cycle_;
}
inline void SetParameterReq::set_heartbeat_cycle(::google::protobuf::uint32 value) {
  set_has_heartbeat_cycle();
  heartbeat_cycle_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SetParameterReq.heartbeat_cycle)
}

// optional uint32 server_response_timeout = 7;
inline bool SetParameterReq::has_server_response_timeout() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SetParameterReq::set_has_server_response_timeout() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SetParameterReq::clear_has_server_response_timeout() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SetParameterReq::clear_server_response_timeout() {
  server_response_timeout_ = 0u;
  clear_has_server_response_timeout();
}
inline ::google::protobuf::uint32 SetParameterReq::server_response_timeout() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SetParameterReq.server_response_timeout)
  return server_response_timeout_;
}
inline void SetParameterReq::set_server_response_timeout(::google::protobuf::uint32 value) {
  set_has_server_response_timeout();
  server_response_timeout_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SetParameterReq.server_response_timeout)
}

// optional uint32 box_response_timeout = 8;
inline bool SetParameterReq::has_box_response_timeout() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SetParameterReq::set_has_box_response_timeout() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SetParameterReq::clear_has_box_response_timeout() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SetParameterReq::clear_box_response_timeout() {
  box_response_timeout_ = 0u;
  clear_has_box_response_timeout();
}
inline ::google::protobuf::uint32 SetParameterReq::box_response_timeout() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SetParameterReq.box_response_timeout)
  return box_response_timeout_;
}
inline void SetParameterReq::set_box_response_timeout(::google::protobuf::uint32 value) {
  set_has_box_response_timeout();
  box_response_timeout_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SetParameterReq.box_response_timeout)
}

// optional bool FlowControlSwitch = 9;
inline bool SetParameterReq::has_flowcontrolswitch() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SetParameterReq::set_has_flowcontrolswitch() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SetParameterReq::clear_has_flowcontrolswitch() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SetParameterReq::clear_flowcontrolswitch() {
  flowcontrolswitch_ = false;
  clear_has_flowcontrolswitch();
}
inline bool SetParameterReq::flowcontrolswitch() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SetParameterReq.FlowControlSwitch)
  return flowcontrolswitch_;
}
inline void SetParameterReq::set_flowcontrolswitch(bool value) {
  set_has_flowcontrolswitch();
  flowcontrolswitch_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SetParameterReq.FlowControlSwitch)
}

// optional uint32 GPSconversion = 10;
inline bool SetParameterReq::has_gpsconversion() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SetParameterReq::set_has_gpsconversion() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SetParameterReq::clear_has_gpsconversion() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SetParameterReq::clear_gpsconversion() {
  gpsconversion_ = 0u;
  clear_has_gpsconversion();
}
inline ::google::protobuf::uint32 SetParameterReq::gpsconversion() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SetParameterReq.GPSconversion)
  return gpsconversion_;
}
inline void SetParameterReq::set_gpsconversion(::google::protobuf::uint32 value) {
  set_has_gpsconversion();
  gpsconversion_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SetParameterReq.GPSconversion)
}

// -------------------------------------------------------------------

// GetParameterRsp

// required uint32 errcode = 1;
inline bool GetParameterRsp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetParameterRsp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetParameterRsp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetParameterRsp::clear_errcode() {
  errcode_ = 0u;
  clear_has_errcode();
}
inline ::google::protobuf::uint32 GetParameterRsp::errcode() const {
  // @@protoc_insertion_point(field_get:zna.protocol.GetParameterRsp.errcode)
  return errcode_;
}
inline void GetParameterRsp::set_errcode(::google::protobuf::uint32 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.GetParameterRsp.errcode)
}

// required uint32 local_storage_cycle = 2;
inline bool GetParameterRsp::has_local_storage_cycle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetParameterRsp::set_has_local_storage_cycle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetParameterRsp::clear_has_local_storage_cycle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetParameterRsp::clear_local_storage_cycle() {
  local_storage_cycle_ = 0u;
  clear_has_local_storage_cycle();
}
inline ::google::protobuf::uint32 GetParameterRsp::local_storage_cycle() const {
  // @@protoc_insertion_point(field_get:zna.protocol.GetParameterRsp.local_storage_cycle)
  return local_storage_cycle_;
}
inline void GetParameterRsp::set_local_storage_cycle(::google::protobuf::uint32 value) {
  set_has_local_storage_cycle();
  local_storage_cycle_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.GetParameterRsp.local_storage_cycle)
}

// required uint32 upload_data_cycle_normal = 3;
inline bool GetParameterRsp::has_upload_data_cycle_normal() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetParameterRsp::set_has_upload_data_cycle_normal() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetParameterRsp::clear_has_upload_data_cycle_normal() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetParameterRsp::clear_upload_data_cycle_normal() {
  upload_data_cycle_normal_ = 0u;
  clear_has_upload_data_cycle_normal();
}
inline ::google::protobuf::uint32 GetParameterRsp::upload_data_cycle_normal() const {
  // @@protoc_insertion_point(field_get:zna.protocol.GetParameterRsp.upload_data_cycle_normal)
  return upload_data_cycle_normal_;
}
inline void GetParameterRsp::set_upload_data_cycle_normal(::google::protobuf::uint32 value) {
  set_has_upload_data_cycle_normal();
  upload_data_cycle_normal_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.GetParameterRsp.upload_data_cycle_normal)
}

// required uint32 upload_GPS_cycle_normal = 4;
inline bool GetParameterRsp::has_upload_gps_cycle_normal() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetParameterRsp::set_has_upload_gps_cycle_normal() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetParameterRsp::clear_has_upload_gps_cycle_normal() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetParameterRsp::clear_upload_gps_cycle_normal() {
  upload_gps_cycle_normal_ = 0u;
  clear_has_upload_gps_cycle_normal();
}
inline ::google::protobuf::uint32 GetParameterRsp::upload_gps_cycle_normal() const {
  // @@protoc_insertion_point(field_get:zna.protocol.GetParameterRsp.upload_GPS_cycle_normal)
  return upload_gps_cycle_normal_;
}
inline void GetParameterRsp::set_upload_gps_cycle_normal(::google::protobuf::uint32 value) {
  set_has_upload_gps_cycle_normal();
  upload_gps_cycle_normal_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.GetParameterRsp.upload_GPS_cycle_normal)
}

// required uint32 upload_data_cycle_alarm = 5;
inline bool GetParameterRsp::has_upload_data_cycle_alarm() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetParameterRsp::set_has_upload_data_cycle_alarm() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetParameterRsp::clear_has_upload_data_cycle_alarm() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetParameterRsp::clear_upload_data_cycle_alarm() {
  upload_data_cycle_alarm_ = 0u;
  clear_has_upload_data_cycle_alarm();
}
inline ::google::protobuf::uint32 GetParameterRsp::upload_data_cycle_alarm() const {
  // @@protoc_insertion_point(field_get:zna.protocol.GetParameterRsp.upload_data_cycle_alarm)
  return upload_data_cycle_alarm_;
}
inline void GetParameterRsp::set_upload_data_cycle_alarm(::google::protobuf::uint32 value) {
  set_has_upload_data_cycle_alarm();
  upload_data_cycle_alarm_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.GetParameterRsp.upload_data_cycle_alarm)
}

// required uint32 upload_GPS_cycle_alarm = 6;
inline bool GetParameterRsp::has_upload_gps_cycle_alarm() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetParameterRsp::set_has_upload_gps_cycle_alarm() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetParameterRsp::clear_has_upload_gps_cycle_alarm() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetParameterRsp::clear_upload_gps_cycle_alarm() {
  upload_gps_cycle_alarm_ = 0u;
  clear_has_upload_gps_cycle_alarm();
}
inline ::google::protobuf::uint32 GetParameterRsp::upload_gps_cycle_alarm() const {
  // @@protoc_insertion_point(field_get:zna.protocol.GetParameterRsp.upload_GPS_cycle_alarm)
  return upload_gps_cycle_alarm_;
}
inline void GetParameterRsp::set_upload_gps_cycle_alarm(::google::protobuf::uint32 value) {
  set_has_upload_gps_cycle_alarm();
  upload_gps_cycle_alarm_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.GetParameterRsp.upload_GPS_cycle_alarm)
}

// required uint32 heartbeat_cycle = 7;
inline bool GetParameterRsp::has_heartbeat_cycle() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetParameterRsp::set_has_heartbeat_cycle() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetParameterRsp::clear_has_heartbeat_cycle() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetParameterRsp::clear_heartbeat_cycle() {
  heartbeat_cycle_ = 0u;
  clear_has_heartbeat_cycle();
}
inline ::google::protobuf::uint32 GetParameterRsp::heartbeat_cycle() const {
  // @@protoc_insertion_point(field_get:zna.protocol.GetParameterRsp.heartbeat_cycle)
  return heartbeat_cycle_;
}
inline void GetParameterRsp::set_heartbeat_cycle(::google::protobuf::uint32 value) {
  set_has_heartbeat_cycle();
  heartbeat_cycle_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.GetParameterRsp.heartbeat_cycle)
}

// required uint32 server_response_timeout = 8;
inline bool GetParameterRsp::has_server_response_timeout() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GetParameterRsp::set_has_server_response_timeout() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GetParameterRsp::clear_has_server_response_timeout() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GetParameterRsp::clear_server_response_timeout() {
  server_response_timeout_ = 0u;
  clear_has_server_response_timeout();
}
inline ::google::protobuf::uint32 GetParameterRsp::server_response_timeout() const {
  // @@protoc_insertion_point(field_get:zna.protocol.GetParameterRsp.server_response_timeout)
  return server_response_timeout_;
}
inline void GetParameterRsp::set_server_response_timeout(::google::protobuf::uint32 value) {
  set_has_server_response_timeout();
  server_response_timeout_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.GetParameterRsp.server_response_timeout)
}

// required uint32 box_response_timeout = 9;
inline bool GetParameterRsp::has_box_response_timeout() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GetParameterRsp::set_has_box_response_timeout() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GetParameterRsp::clear_has_box_response_timeout() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GetParameterRsp::clear_box_response_timeout() {
  box_response_timeout_ = 0u;
  clear_has_box_response_timeout();
}
inline ::google::protobuf::uint32 GetParameterRsp::box_response_timeout() const {
  // @@protoc_insertion_point(field_get:zna.protocol.GetParameterRsp.box_response_timeout)
  return box_response_timeout_;
}
inline void GetParameterRsp::set_box_response_timeout(::google::protobuf::uint32 value) {
  set_has_box_response_timeout();
  box_response_timeout_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.GetParameterRsp.box_response_timeout)
}

// required string firmware_version = 10;
inline bool GetParameterRsp::has_firmware_version() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GetParameterRsp::set_has_firmware_version() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GetParameterRsp::clear_has_firmware_version() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GetParameterRsp::clear_firmware_version() {
  if (firmware_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firmware_version_->clear();
  }
  clear_has_firmware_version();
}
inline const ::std::string& GetParameterRsp::firmware_version() const {
  // @@protoc_insertion_point(field_get:zna.protocol.GetParameterRsp.firmware_version)
  return *firmware_version_;
}
inline void GetParameterRsp::set_firmware_version(const ::std::string& value) {
  set_has_firmware_version();
  if (firmware_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firmware_version_ = new ::std::string;
  }
  firmware_version_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.GetParameterRsp.firmware_version)
}
inline void GetParameterRsp::set_firmware_version(const char* value) {
  set_has_firmware_version();
  if (firmware_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firmware_version_ = new ::std::string;
  }
  firmware_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.GetParameterRsp.firmware_version)
}
inline void GetParameterRsp::set_firmware_version(const char* value, size_t size) {
  set_has_firmware_version();
  if (firmware_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firmware_version_ = new ::std::string;
  }
  firmware_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.GetParameterRsp.firmware_version)
}
inline ::std::string* GetParameterRsp::mutable_firmware_version() {
  set_has_firmware_version();
  if (firmware_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    firmware_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.GetParameterRsp.firmware_version)
  return firmware_version_;
}
inline ::std::string* GetParameterRsp::release_firmware_version() {
  clear_has_firmware_version();
  if (firmware_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = firmware_version_;
    firmware_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetParameterRsp::set_allocated_firmware_version(::std::string* firmware_version) {
  if (firmware_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete firmware_version_;
  }
  if (firmware_version) {
    set_has_firmware_version();
    firmware_version_ = firmware_version;
  } else {
    clear_has_firmware_version();
    firmware_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.GetParameterRsp.firmware_version)
}

// required string hardware_version = 11;
inline bool GetParameterRsp::has_hardware_version() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GetParameterRsp::set_has_hardware_version() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GetParameterRsp::clear_has_hardware_version() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GetParameterRsp::clear_hardware_version() {
  if (hardware_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hardware_version_->clear();
  }
  clear_has_hardware_version();
}
inline const ::std::string& GetParameterRsp::hardware_version() const {
  // @@protoc_insertion_point(field_get:zna.protocol.GetParameterRsp.hardware_version)
  return *hardware_version_;
}
inline void GetParameterRsp::set_hardware_version(const ::std::string& value) {
  set_has_hardware_version();
  if (hardware_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hardware_version_ = new ::std::string;
  }
  hardware_version_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.GetParameterRsp.hardware_version)
}
inline void GetParameterRsp::set_hardware_version(const char* value) {
  set_has_hardware_version();
  if (hardware_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hardware_version_ = new ::std::string;
  }
  hardware_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.GetParameterRsp.hardware_version)
}
inline void GetParameterRsp::set_hardware_version(const char* value, size_t size) {
  set_has_hardware_version();
  if (hardware_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hardware_version_ = new ::std::string;
  }
  hardware_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.GetParameterRsp.hardware_version)
}
inline ::std::string* GetParameterRsp::mutable_hardware_version() {
  set_has_hardware_version();
  if (hardware_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hardware_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.GetParameterRsp.hardware_version)
  return hardware_version_;
}
inline ::std::string* GetParameterRsp::release_hardware_version() {
  clear_has_hardware_version();
  if (hardware_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hardware_version_;
    hardware_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetParameterRsp::set_allocated_hardware_version(::std::string* hardware_version) {
  if (hardware_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hardware_version_;
  }
  if (hardware_version) {
    set_has_hardware_version();
    hardware_version_ = hardware_version;
  } else {
    clear_has_hardware_version();
    hardware_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.GetParameterRsp.hardware_version)
}

// required uint32 time_stamp = 12;
inline bool GetParameterRsp::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GetParameterRsp::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GetParameterRsp::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GetParameterRsp::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 GetParameterRsp::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.GetParameterRsp.time_stamp)
  return time_stamp_;
}
inline void GetParameterRsp::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.GetParameterRsp.time_stamp)
}

// -------------------------------------------------------------------

// GetParameterReq

// required uint32 time_stamp = 1;
inline bool GetParameterReq::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetParameterReq::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetParameterReq::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetParameterReq::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 GetParameterReq::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.GetParameterReq.time_stamp)
  return time_stamp_;
}
inline void GetParameterReq::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.GetParameterReq.time_stamp)
}

// -------------------------------------------------------------------

// ECM_Info

// optional uint32 EngineRPM = 1;
inline bool ECM_Info::has_enginerpm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ECM_Info::set_has_enginerpm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ECM_Info::clear_has_enginerpm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ECM_Info::clear_enginerpm() {
  enginerpm_ = 0u;
  clear_has_enginerpm();
}
inline ::google::protobuf::uint32 ECM_Info::enginerpm() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ECM_Info.EngineRPM)
  return enginerpm_;
}
inline void ECM_Info::set_enginerpm(::google::protobuf::uint32 value) {
  set_has_enginerpm();
  enginerpm_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ECM_Info.EngineRPM)
}

// optional uint32 EngineStatus = 4;
inline bool ECM_Info::has_enginestatus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ECM_Info::set_has_enginestatus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ECM_Info::clear_has_enginestatus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ECM_Info::clear_enginestatus() {
  enginestatus_ = 0u;
  clear_has_enginestatus();
}
inline ::google::protobuf::uint32 ECM_Info::enginestatus() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ECM_Info.EngineStatus)
  return enginestatus_;
}
inline void ECM_Info::set_enginestatus(::google::protobuf::uint32 value) {
  set_has_enginestatus();
  enginestatus_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ECM_Info.EngineStatus)
}

// optional uint32 EngineCoolantTemp = 5;
inline bool ECM_Info::has_enginecoolanttemp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ECM_Info::set_has_enginecoolanttemp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ECM_Info::clear_has_enginecoolanttemp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ECM_Info::clear_enginecoolanttemp() {
  enginecoolanttemp_ = 0u;
  clear_has_enginecoolanttemp();
}
inline ::google::protobuf::uint32 ECM_Info::enginecoolanttemp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ECM_Info.EngineCoolantTemp)
  return enginecoolanttemp_;
}
inline void ECM_Info::set_enginecoolanttemp(::google::protobuf::uint32 value) {
  set_has_enginecoolanttemp();
  enginecoolanttemp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ECM_Info.EngineCoolantTemp)
}

// optional uint32 MILLamp = 21;
inline bool ECM_Info::has_millamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ECM_Info::set_has_millamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ECM_Info::clear_has_millamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ECM_Info::clear_millamp() {
  millamp_ = 0u;
  clear_has_millamp();
}
inline ::google::protobuf::uint32 ECM_Info::millamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ECM_Info.MILLamp)
  return millamp_;
}
inline void ECM_Info::set_millamp(::google::protobuf::uint32 value) {
  set_has_millamp();
  millamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ECM_Info.MILLamp)
}

// optional uint32 SVSLamp = 22;
inline bool ECM_Info::has_svslamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ECM_Info::set_has_svslamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ECM_Info::clear_has_svslamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ECM_Info::clear_svslamp() {
  svslamp_ = 0u;
  clear_has_svslamp();
}
inline ::google::protobuf::uint32 ECM_Info::svslamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ECM_Info.SVSLamp)
  return svslamp_;
}
inline void ECM_Info::set_svslamp(::google::protobuf::uint32 value) {
  set_has_svslamp();
  svslamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ECM_Info.SVSLamp)
}

// optional uint32 OilPress_Lamp = 23;
inline bool ECM_Info::has_oilpress_lamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ECM_Info::set_has_oilpress_lamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ECM_Info::clear_has_oilpress_lamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ECM_Info::clear_oilpress_lamp() {
  oilpress_lamp_ = 0u;
  clear_has_oilpress_lamp();
}
inline ::google::protobuf::uint32 ECM_Info::oilpress_lamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ECM_Info.OilPress_Lamp)
  return oilpress_lamp_;
}
inline void ECM_Info::set_oilpress_lamp(::google::protobuf::uint32 value) {
  set_has_oilpress_lamp();
  oilpress_lamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ECM_Info.OilPress_Lamp)
}

// optional uint32 UreaLamp = 24;
inline bool ECM_Info::has_urealamp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ECM_Info::set_has_urealamp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ECM_Info::clear_has_urealamp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ECM_Info::clear_urealamp() {
  urealamp_ = 0u;
  clear_has_urealamp();
}
inline ::google::protobuf::uint32 ECM_Info::urealamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ECM_Info.UreaLamp)
  return urealamp_;
}
inline void ECM_Info::set_urealamp(::google::protobuf::uint32 value) {
  set_has_urealamp();
  urealamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ECM_Info.UreaLamp)
}

// optional bool Filterwater_Det = 25;
inline bool ECM_Info::has_filterwater_det() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ECM_Info::set_has_filterwater_det() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ECM_Info::clear_has_filterwater_det() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ECM_Info::clear_filterwater_det() {
  filterwater_det_ = false;
  clear_has_filterwater_det();
}
inline bool ECM_Info::filterwater_det() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ECM_Info.Filterwater_Det)
  return filterwater_det_;
}
inline void ECM_Info::set_filterwater_det(bool value) {
  set_has_filterwater_det();
  filterwater_det_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ECM_Info.Filterwater_Det)
}

// optional bool BatteryCharge_Sts = 26;
inline bool ECM_Info::has_batterycharge_sts() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ECM_Info::set_has_batterycharge_sts() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ECM_Info::clear_has_batterycharge_sts() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ECM_Info::clear_batterycharge_sts() {
  batterycharge_sts_ = false;
  clear_has_batterycharge_sts();
}
inline bool ECM_Info::batterycharge_sts() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ECM_Info.BatteryCharge_Sts)
  return batterycharge_sts_;
}
inline void ECM_Info::set_batterycharge_sts(bool value) {
  set_has_batterycharge_sts();
  batterycharge_sts_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ECM_Info.BatteryCharge_Sts)
}

// -------------------------------------------------------------------

// METER_Info

// optional uint32 Average_Fuel_Economy = 2;
inline bool METER_Info::has_average_fuel_economy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void METER_Info::set_has_average_fuel_economy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void METER_Info::clear_has_average_fuel_economy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void METER_Info::clear_average_fuel_economy() {
  average_fuel_economy_ = 0u;
  clear_has_average_fuel_economy();
}
inline ::google::protobuf::uint32 METER_Info::average_fuel_economy() const {
  // @@protoc_insertion_point(field_get:zna.protocol.METER_Info.Average_Fuel_Economy)
  return average_fuel_economy_;
}
inline void METER_Info::set_average_fuel_economy(::google::protobuf::uint32 value) {
  set_has_average_fuel_economy();
  average_fuel_economy_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.METER_Info.Average_Fuel_Economy)
}

// optional uint32 Distance_to_empty = 3;
inline bool METER_Info::has_distance_to_empty() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void METER_Info::set_has_distance_to_empty() {
  _has_bits_[0] |= 0x00000002u;
}
inline void METER_Info::clear_has_distance_to_empty() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void METER_Info::clear_distance_to_empty() {
  distance_to_empty_ = 0u;
  clear_has_distance_to_empty();
}
inline ::google::protobuf::uint32 METER_Info::distance_to_empty() const {
  // @@protoc_insertion_point(field_get:zna.protocol.METER_Info.Distance_to_empty)
  return distance_to_empty_;
}
inline void METER_Info::set_distance_to_empty(::google::protobuf::uint32 value) {
  set_has_distance_to_empty();
  distance_to_empty_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.METER_Info.Distance_to_empty)
}

// optional uint32 Distance_Totalizer = 4;
inline bool METER_Info::has_distance_totalizer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void METER_Info::set_has_distance_totalizer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void METER_Info::clear_has_distance_totalizer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void METER_Info::clear_distance_totalizer() {
  distance_totalizer_ = 0u;
  clear_has_distance_totalizer();
}
inline ::google::protobuf::uint32 METER_Info::distance_totalizer() const {
  // @@protoc_insertion_point(field_get:zna.protocol.METER_Info.Distance_Totalizer)
  return distance_totalizer_;
}
inline void METER_Info::set_distance_totalizer(::google::protobuf::uint32 value) {
  set_has_distance_totalizer();
  distance_totalizer_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.METER_Info.Distance_Totalizer)
}

// optional uint32 Fuel_Remain = 5;
inline bool METER_Info::has_fuel_remain() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void METER_Info::set_has_fuel_remain() {
  _has_bits_[0] |= 0x00000008u;
}
inline void METER_Info::clear_has_fuel_remain() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void METER_Info::clear_fuel_remain() {
  fuel_remain_ = 0u;
  clear_has_fuel_remain();
}
inline ::google::protobuf::uint32 METER_Info::fuel_remain() const {
  // @@protoc_insertion_point(field_get:zna.protocol.METER_Info.Fuel_Remain)
  return fuel_remain_;
}
inline void METER_Info::set_fuel_remain(::google::protobuf::uint32 value) {
  set_has_fuel_remain();
  fuel_remain_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.METER_Info.Fuel_Remain)
}

// optional bool TotalOdo_Valid = 13;
inline bool METER_Info::has_totalodo_valid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void METER_Info::set_has_totalodo_valid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void METER_Info::clear_has_totalodo_valid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void METER_Info::clear_totalodo_valid() {
  totalodo_valid_ = false;
  clear_has_totalodo_valid();
}
inline bool METER_Info::totalodo_valid() const {
  // @@protoc_insertion_point(field_get:zna.protocol.METER_Info.TotalOdo_Valid)
  return totalodo_valid_;
}
inline void METER_Info::set_totalodo_valid(bool value) {
  set_has_totalodo_valid();
  totalodo_valid_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.METER_Info.TotalOdo_Valid)
}

// optional bool OilPres = 14;
inline bool METER_Info::has_oilpres() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void METER_Info::set_has_oilpres() {
  _has_bits_[0] |= 0x00000020u;
}
inline void METER_Info::clear_has_oilpres() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void METER_Info::clear_oilpres() {
  oilpres_ = false;
  clear_has_oilpres();
}
inline bool METER_Info::oilpres() const {
  // @@protoc_insertion_point(field_get:zna.protocol.METER_Info.OilPres)
  return oilpres_;
}
inline void METER_Info::set_oilpres(bool value) {
  set_has_oilpres();
  oilpres_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.METER_Info.OilPres)
}

// optional uint32 BrakeFailure = 15;
inline bool METER_Info::has_brakefailure() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void METER_Info::set_has_brakefailure() {
  _has_bits_[0] |= 0x00000040u;
}
inline void METER_Info::clear_has_brakefailure() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void METER_Info::clear_brakefailure() {
  brakefailure_ = 0u;
  clear_has_brakefailure();
}
inline ::google::protobuf::uint32 METER_Info::brakefailure() const {
  // @@protoc_insertion_point(field_get:zna.protocol.METER_Info.BrakeFailure)
  return brakefailure_;
}
inline void METER_Info::set_brakefailure(::google::protobuf::uint32 value) {
  set_has_brakefailure();
  brakefailure_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.METER_Info.BrakeFailure)
}

// optional uint32 InstandFuel = 16;
inline bool METER_Info::has_instandfuel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void METER_Info::set_has_instandfuel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void METER_Info::clear_has_instandfuel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void METER_Info::clear_instandfuel() {
  instandfuel_ = 0u;
  clear_has_instandfuel();
}
inline ::google::protobuf::uint32 METER_Info::instandfuel() const {
  // @@protoc_insertion_point(field_get:zna.protocol.METER_Info.InstandFuel)
  return instandfuel_;
}
inline void METER_Info::set_instandfuel(::google::protobuf::uint32 value) {
  set_has_instandfuel();
  instandfuel_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.METER_Info.InstandFuel)
}

// -------------------------------------------------------------------

// BCM_Info

// optional bool front_left_door_status = 3;
inline bool BCM_Info::has_front_left_door_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BCM_Info::set_has_front_left_door_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BCM_Info::clear_has_front_left_door_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BCM_Info::clear_front_left_door_status() {
  front_left_door_status_ = false;
  clear_has_front_left_door_status();
}
inline bool BCM_Info::front_left_door_status() const {
  // @@protoc_insertion_point(field_get:zna.protocol.BCM_Info.front_left_door_status)
  return front_left_door_status_;
}
inline void BCM_Info::set_front_left_door_status(bool value) {
  set_has_front_left_door_status();
  front_left_door_status_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.BCM_Info.front_left_door_status)
}

// optional bool front_right_door_status = 4;
inline bool BCM_Info::has_front_right_door_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BCM_Info::set_has_front_right_door_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BCM_Info::clear_has_front_right_door_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BCM_Info::clear_front_right_door_status() {
  front_right_door_status_ = false;
  clear_has_front_right_door_status();
}
inline bool BCM_Info::front_right_door_status() const {
  // @@protoc_insertion_point(field_get:zna.protocol.BCM_Info.front_right_door_status)
  return front_right_door_status_;
}
inline void BCM_Info::set_front_right_door_status(bool value) {
  set_has_front_right_door_status();
  front_right_door_status_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.BCM_Info.front_right_door_status)
}

// optional bool rear_left_door_status = 5;
inline bool BCM_Info::has_rear_left_door_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BCM_Info::set_has_rear_left_door_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BCM_Info::clear_has_rear_left_door_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BCM_Info::clear_rear_left_door_status() {
  rear_left_door_status_ = false;
  clear_has_rear_left_door_status();
}
inline bool BCM_Info::rear_left_door_status() const {
  // @@protoc_insertion_point(field_get:zna.protocol.BCM_Info.rear_left_door_status)
  return rear_left_door_status_;
}
inline void BCM_Info::set_rear_left_door_status(bool value) {
  set_has_rear_left_door_status();
  rear_left_door_status_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.BCM_Info.rear_left_door_status)
}

// optional bool rear_right_door_status = 6;
inline bool BCM_Info::has_rear_right_door_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BCM_Info::set_has_rear_right_door_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BCM_Info::clear_has_rear_right_door_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BCM_Info::clear_rear_right_door_status() {
  rear_right_door_status_ = false;
  clear_has_rear_right_door_status();
}
inline bool BCM_Info::rear_right_door_status() const {
  // @@protoc_insertion_point(field_get:zna.protocol.BCM_Info.rear_right_door_status)
  return rear_right_door_status_;
}
inline void BCM_Info::set_rear_right_door_status(bool value) {
  set_has_rear_right_door_status();
  rear_right_door_status_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.BCM_Info.rear_right_door_status)
}

// optional bool back_door_status = 7;
inline bool BCM_Info::has_back_door_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BCM_Info::set_has_back_door_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BCM_Info::clear_has_back_door_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BCM_Info::clear_back_door_status() {
  back_door_status_ = false;
  clear_has_back_door_status();
}
inline bool BCM_Info::back_door_status() const {
  // @@protoc_insertion_point(field_get:zna.protocol.BCM_Info.back_door_status)
  return back_door_status_;
}
inline void BCM_Info::set_back_door_status(bool value) {
  set_has_back_door_status();
  back_door_status_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.BCM_Info.back_door_status)
}

// optional bool back_door_locked_status = 9;
inline bool BCM_Info::has_back_door_locked_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BCM_Info::set_has_back_door_locked_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BCM_Info::clear_has_back_door_locked_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BCM_Info::clear_back_door_locked_status() {
  back_door_locked_status_ = false;
  clear_has_back_door_locked_status();
}
inline bool BCM_Info::back_door_locked_status() const {
  // @@protoc_insertion_point(field_get:zna.protocol.BCM_Info.back_door_locked_status)
  return back_door_locked_status_;
}
inline void BCM_Info::set_back_door_locked_status(bool value) {
  set_has_back_door_locked_status();
  back_door_locked_status_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.BCM_Info.back_door_locked_status)
}

// optional bool LowBeamRequest = 10;
inline bool BCM_Info::has_lowbeamrequest() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BCM_Info::set_has_lowbeamrequest() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BCM_Info::clear_has_lowbeamrequest() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BCM_Info::clear_lowbeamrequest() {
  lowbeamrequest_ = false;
  clear_has_lowbeamrequest();
}
inline bool BCM_Info::lowbeamrequest() const {
  // @@protoc_insertion_point(field_get:zna.protocol.BCM_Info.LowBeamRequest)
  return lowbeamrequest_;
}
inline void BCM_Info::set_lowbeamrequest(bool value) {
  set_has_lowbeamrequest();
  lowbeamrequest_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.BCM_Info.LowBeamRequest)
}

// optional bool HighBeamRequest = 12;
inline bool BCM_Info::has_highbeamrequest() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BCM_Info::set_has_highbeamrequest() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BCM_Info::clear_has_highbeamrequest() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BCM_Info::clear_highbeamrequest() {
  highbeamrequest_ = false;
  clear_has_highbeamrequest();
}
inline bool BCM_Info::highbeamrequest() const {
  // @@protoc_insertion_point(field_get:zna.protocol.BCM_Info.HighBeamRequest)
  return highbeamrequest_;
}
inline void BCM_Info::set_highbeamrequest(bool value) {
  set_has_highbeamrequest();
  highbeamrequest_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.BCM_Info.HighBeamRequest)
}

// optional bool SWIIGK = 51;
inline bool BCM_Info::has_swiigk() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BCM_Info::set_has_swiigk() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BCM_Info::clear_has_swiigk() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BCM_Info::clear_swiigk() {
  swiigk_ = false;
  clear_has_swiigk();
}
inline bool BCM_Info::swiigk() const {
  // @@protoc_insertion_point(field_get:zna.protocol.BCM_Info.SWIIGK)
  return swiigk_;
}
inline void BCM_Info::set_swiigk(bool value) {
  set_has_swiigk();
  swiigk_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.BCM_Info.SWIIGK)
}

// optional bool DoorOpen_Warning = 52;
inline bool BCM_Info::has_dooropen_warning() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BCM_Info::set_has_dooropen_warning() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BCM_Info::clear_has_dooropen_warning() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BCM_Info::clear_dooropen_warning() {
  dooropen_warning_ = false;
  clear_has_dooropen_warning();
}
inline bool BCM_Info::dooropen_warning() const {
  // @@protoc_insertion_point(field_get:zna.protocol.BCM_Info.DoorOpen_Warning)
  return dooropen_warning_;
}
inline void BCM_Info::set_dooropen_warning(bool value) {
  set_has_dooropen_warning();
  dooropen_warning_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.BCM_Info.DoorOpen_Warning)
}

// optional bool LightOn_Warning = 53;
inline bool BCM_Info::has_lighton_warning() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BCM_Info::set_has_lighton_warning() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BCM_Info::clear_has_lighton_warning() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BCM_Info::clear_lighton_warning() {
  lighton_warning_ = false;
  clear_has_lighton_warning();
}
inline bool BCM_Info::lighton_warning() const {
  // @@protoc_insertion_point(field_get:zna.protocol.BCM_Info.LightOn_Warning)
  return lighton_warning_;
}
inline void BCM_Info::set_lighton_warning(bool value) {
  set_has_lighton_warning();
  lighton_warning_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.BCM_Info.LightOn_Warning)
}

// optional uint32 TPMSMIL_Req = 54;
inline bool BCM_Info::has_tpmsmil_req() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BCM_Info::set_has_tpmsmil_req() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BCM_Info::clear_has_tpmsmil_req() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BCM_Info::clear_tpmsmil_req() {
  tpmsmil_req_ = 0u;
  clear_has_tpmsmil_req();
}
inline ::google::protobuf::uint32 BCM_Info::tpmsmil_req() const {
  // @@protoc_insertion_point(field_get:zna.protocol.BCM_Info.TPMSMIL_Req)
  return tpmsmil_req_;
}
inline void BCM_Info::set_tpmsmil_req(::google::protobuf::uint32 value) {
  set_has_tpmsmil_req();
  tpmsmil_req_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.BCM_Info.TPMSMIL_Req)
}

// optional bool StopLampFailSts = 55;
inline bool BCM_Info::has_stoplampfailsts() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BCM_Info::set_has_stoplampfailsts() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BCM_Info::clear_has_stoplampfailsts() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BCM_Info::clear_stoplampfailsts() {
  stoplampfailsts_ = false;
  clear_has_stoplampfailsts();
}
inline bool BCM_Info::stoplampfailsts() const {
  // @@protoc_insertion_point(field_get:zna.protocol.BCM_Info.StopLampFailSts)
  return stoplampfailsts_;
}
inline void BCM_Info::set_stoplampfailsts(bool value) {
  set_has_stoplampfailsts();
  stoplampfailsts_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.BCM_Info.StopLampFailSts)
}

// optional bool RemoteVecSearchSts = 56;
inline bool BCM_Info::has_remotevecsearchsts() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BCM_Info::set_has_remotevecsearchsts() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BCM_Info::clear_has_remotevecsearchsts() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BCM_Info::clear_remotevecsearchsts() {
  remotevecsearchsts_ = false;
  clear_has_remotevecsearchsts();
}
inline bool BCM_Info::remotevecsearchsts() const {
  // @@protoc_insertion_point(field_get:zna.protocol.BCM_Info.RemoteVecSearchSts)
  return remotevecsearchsts_;
}
inline void BCM_Info::set_remotevecsearchsts(bool value) {
  set_has_remotevecsearchsts();
  remotevecsearchsts_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.BCM_Info.RemoteVecSearchSts)
}

// optional bool DriverDoorLockSts = 57;
inline bool BCM_Info::has_driverdoorlocksts() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BCM_Info::set_has_driverdoorlocksts() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BCM_Info::clear_has_driverdoorlocksts() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BCM_Info::clear_driverdoorlocksts() {
  driverdoorlocksts_ = false;
  clear_has_driverdoorlocksts();
}
inline bool BCM_Info::driverdoorlocksts() const {
  // @@protoc_insertion_point(field_get:zna.protocol.BCM_Info.DriverDoorLockSts)
  return driverdoorlocksts_;
}
inline void BCM_Info::set_driverdoorlocksts(bool value) {
  set_has_driverdoorlocksts();
  driverdoorlocksts_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.BCM_Info.DriverDoorLockSts)
}

// optional uint32 KeyAlarmSts = 58;
inline bool BCM_Info::has_keyalarmsts() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BCM_Info::set_has_keyalarmsts() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BCM_Info::clear_has_keyalarmsts() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BCM_Info::clear_keyalarmsts() {
  keyalarmsts_ = 0u;
  clear_has_keyalarmsts();
}
inline ::google::protobuf::uint32 BCM_Info::keyalarmsts() const {
  // @@protoc_insertion_point(field_get:zna.protocol.BCM_Info.KeyAlarmSts)
  return keyalarmsts_;
}
inline void BCM_Info::set_keyalarmsts(::google::protobuf::uint32 value) {
  set_has_keyalarmsts();
  keyalarmsts_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.BCM_Info.KeyAlarmSts)
}

// optional bool HoodStatus = 59;
inline bool BCM_Info::has_hoodstatus() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void BCM_Info::set_has_hoodstatus() {
  _has_bits_[0] |= 0x00010000u;
}
inline void BCM_Info::clear_has_hoodstatus() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void BCM_Info::clear_hoodstatus() {
  hoodstatus_ = false;
  clear_has_hoodstatus();
}
inline bool BCM_Info::hoodstatus() const {
  // @@protoc_insertion_point(field_get:zna.protocol.BCM_Info.HoodStatus)
  return hoodstatus_;
}
inline void BCM_Info::set_hoodstatus(bool value) {
  set_has_hoodstatus();
  hoodstatus_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.BCM_Info.HoodStatus)
}

// optional bool AccStatus = 60;
inline bool BCM_Info::has_accstatus() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void BCM_Info::set_has_accstatus() {
  _has_bits_[0] |= 0x00020000u;
}
inline void BCM_Info::clear_has_accstatus() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void BCM_Info::clear_accstatus() {
  accstatus_ = false;
  clear_has_accstatus();
}
inline bool BCM_Info::accstatus() const {
  // @@protoc_insertion_point(field_get:zna.protocol.BCM_Info.AccStatus)
  return accstatus_;
}
inline void BCM_Info::set_accstatus(bool value) {
  set_has_accstatus();
  accstatus_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.BCM_Info.AccStatus)
}

// optional bool remote_enging_run_flag = 61;
inline bool BCM_Info::has_remote_enging_run_flag() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void BCM_Info::set_has_remote_enging_run_flag() {
  _has_bits_[0] |= 0x00040000u;
}
inline void BCM_Info::clear_has_remote_enging_run_flag() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void BCM_Info::clear_remote_enging_run_flag() {
  remote_enging_run_flag_ = false;
  clear_has_remote_enging_run_flag();
}
inline bool BCM_Info::remote_enging_run_flag() const {
  // @@protoc_insertion_point(field_get:zna.protocol.BCM_Info.remote_enging_run_flag)
  return remote_enging_run_flag_;
}
inline void BCM_Info::set_remote_enging_run_flag(bool value) {
  set_has_remote_enging_run_flag();
  remote_enging_run_flag_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.BCM_Info.remote_enging_run_flag)
}

// -------------------------------------------------------------------

// ACU_Info

// optional uint32 Airbag_Crash_Order = 1;
inline bool ACU_Info::has_airbag_crash_order() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACU_Info::set_has_airbag_crash_order() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ACU_Info::clear_has_airbag_crash_order() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ACU_Info::clear_airbag_crash_order() {
  airbag_crash_order_ = 0u;
  clear_has_airbag_crash_order();
}
inline ::google::protobuf::uint32 ACU_Info::airbag_crash_order() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ACU_Info.Airbag_Crash_Order)
  return airbag_crash_order_;
}
inline void ACU_Info::set_airbag_crash_order(::google::protobuf::uint32 value) {
  set_has_airbag_crash_order();
  airbag_crash_order_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ACU_Info.Airbag_Crash_Order)
}

// optional uint32 AirbagFail_Sts = 12;
inline bool ACU_Info::has_airbagfail_sts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACU_Info::set_has_airbagfail_sts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ACU_Info::clear_has_airbagfail_sts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ACU_Info::clear_airbagfail_sts() {
  airbagfail_sts_ = 0u;
  clear_has_airbagfail_sts();
}
inline ::google::protobuf::uint32 ACU_Info::airbagfail_sts() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ACU_Info.AirbagFail_Sts)
  return airbagfail_sts_;
}
inline void ACU_Info::set_airbagfail_sts(::google::protobuf::uint32 value) {
  set_has_airbagfail_sts();
  airbagfail_sts_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ACU_Info.AirbagFail_Sts)
}

// -------------------------------------------------------------------

// ECO_Info

// optional uint32 rapid_acceleration_count = 1;
inline bool ECO_Info::has_rapid_acceleration_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ECO_Info::set_has_rapid_acceleration_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ECO_Info::clear_has_rapid_acceleration_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ECO_Info::clear_rapid_acceleration_count() {
  rapid_acceleration_count_ = 0u;
  clear_has_rapid_acceleration_count();
}
inline ::google::protobuf::uint32 ECO_Info::rapid_acceleration_count() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ECO_Info.rapid_acceleration_count)
  return rapid_acceleration_count_;
}
inline void ECO_Info::set_rapid_acceleration_count(::google::protobuf::uint32 value) {
  set_has_rapid_acceleration_count();
  rapid_acceleration_count_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ECO_Info.rapid_acceleration_count)
}

// optional uint32 rapid_deceleration_count = 2;
inline bool ECO_Info::has_rapid_deceleration_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ECO_Info::set_has_rapid_deceleration_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ECO_Info::clear_has_rapid_deceleration_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ECO_Info::clear_rapid_deceleration_count() {
  rapid_deceleration_count_ = 0u;
  clear_has_rapid_deceleration_count();
}
inline ::google::protobuf::uint32 ECO_Info::rapid_deceleration_count() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ECO_Info.rapid_deceleration_count)
  return rapid_deceleration_count_;
}
inline void ECO_Info::set_rapid_deceleration_count(::google::protobuf::uint32 value) {
  set_has_rapid_deceleration_count();
  rapid_deceleration_count_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ECO_Info.rapid_deceleration_count)
}

// optional uint32 sharp_turn_count = 3;
inline bool ECO_Info::has_sharp_turn_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ECO_Info::set_has_sharp_turn_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ECO_Info::clear_has_sharp_turn_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ECO_Info::clear_sharp_turn_count() {
  sharp_turn_count_ = 0u;
  clear_has_sharp_turn_count();
}
inline ::google::protobuf::uint32 ECO_Info::sharp_turn_count() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ECO_Info.sharp_turn_count)
  return sharp_turn_count_;
}
inline void ECO_Info::set_sharp_turn_count(::google::protobuf::uint32 value) {
  set_has_sharp_turn_count();
  sharp_turn_count_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ECO_Info.sharp_turn_count)
}

// -------------------------------------------------------------------

// ALARM_Info

// optional uint32 alarm_type = 1;
inline bool ALARM_Info::has_alarm_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ALARM_Info::set_has_alarm_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ALARM_Info::clear_has_alarm_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ALARM_Info::clear_alarm_type() {
  alarm_type_ = 0u;
  clear_has_alarm_type();
}
inline ::google::protobuf::uint32 ALARM_Info::alarm_type() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ALARM_Info.alarm_type)
  return alarm_type_;
}
inline void ALARM_Info::set_alarm_type(::google::protobuf::uint32 value) {
  set_has_alarm_type();
  alarm_type_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ALARM_Info.alarm_type)
}

// optional bytes alarm_typeEx = 2;
inline bool ALARM_Info::has_alarm_typeex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ALARM_Info::set_has_alarm_typeex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ALARM_Info::clear_has_alarm_typeex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ALARM_Info::clear_alarm_typeex() {
  if (alarm_typeex_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alarm_typeex_->clear();
  }
  clear_has_alarm_typeex();
}
inline const ::std::string& ALARM_Info::alarm_typeex() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ALARM_Info.alarm_typeEx)
  return *alarm_typeex_;
}
inline void ALARM_Info::set_alarm_typeex(const ::std::string& value) {
  set_has_alarm_typeex();
  if (alarm_typeex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alarm_typeex_ = new ::std::string;
  }
  alarm_typeex_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.ALARM_Info.alarm_typeEx)
}
inline void ALARM_Info::set_alarm_typeex(const char* value) {
  set_has_alarm_typeex();
  if (alarm_typeex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alarm_typeex_ = new ::std::string;
  }
  alarm_typeex_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.ALARM_Info.alarm_typeEx)
}
inline void ALARM_Info::set_alarm_typeex(const void* value, size_t size) {
  set_has_alarm_typeex();
  if (alarm_typeex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alarm_typeex_ = new ::std::string;
  }
  alarm_typeex_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.ALARM_Info.alarm_typeEx)
}
inline ::std::string* ALARM_Info::mutable_alarm_typeex() {
  set_has_alarm_typeex();
  if (alarm_typeex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    alarm_typeex_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.ALARM_Info.alarm_typeEx)
  return alarm_typeex_;
}
inline ::std::string* ALARM_Info::release_alarm_typeex() {
  clear_has_alarm_typeex();
  if (alarm_typeex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = alarm_typeex_;
    alarm_typeex_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ALARM_Info::set_allocated_alarm_typeex(::std::string* alarm_typeex) {
  if (alarm_typeex_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete alarm_typeex_;
  }
  if (alarm_typeex) {
    set_has_alarm_typeex();
    alarm_typeex_ = alarm_typeex;
  } else {
    clear_has_alarm_typeex();
    alarm_typeex_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.ALARM_Info.alarm_typeEx)
}

// optional uint32 Transmitter_Fail = 3;
inline bool ALARM_Info::has_transmitter_fail() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ALARM_Info::set_has_transmitter_fail() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ALARM_Info::clear_has_transmitter_fail() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ALARM_Info::clear_transmitter_fail() {
  transmitter_fail_ = 0u;
  clear_has_transmitter_fail();
}
inline ::google::protobuf::uint32 ALARM_Info::transmitter_fail() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ALARM_Info.Transmitter_Fail)
  return transmitter_fail_;
}
inline void ALARM_Info::set_transmitter_fail(::google::protobuf::uint32 value) {
  set_has_transmitter_fail();
  transmitter_fail_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ALARM_Info.Transmitter_Fail)
}

// optional uint32 LowTirePressure = 4;
inline bool ALARM_Info::has_lowtirepressure() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ALARM_Info::set_has_lowtirepressure() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ALARM_Info::clear_has_lowtirepressure() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ALARM_Info::clear_lowtirepressure() {
  lowtirepressure_ = 0u;
  clear_has_lowtirepressure();
}
inline ::google::protobuf::uint32 ALARM_Info::lowtirepressure() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ALARM_Info.LowTirePressure)
  return lowtirepressure_;
}
inline void ALARM_Info::set_lowtirepressure(::google::protobuf::uint32 value) {
  set_has_lowtirepressure();
  lowtirepressure_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ALARM_Info.LowTirePressure)
}

// optional uint32 ZNA_P15MC = 5;
inline bool ALARM_Info::has_zna_p15mc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ALARM_Info::set_has_zna_p15mc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ALARM_Info::clear_has_zna_p15mc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ALARM_Info::clear_zna_p15mc() {
  zna_p15mc_ = 0u;
  clear_has_zna_p15mc();
}
inline ::google::protobuf::uint32 ALARM_Info::zna_p15mc() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ALARM_Info.ZNA_P15MC)
  return zna_p15mc_;
}
inline void ALARM_Info::set_zna_p15mc(::google::protobuf::uint32 value) {
  set_has_zna_p15mc();
  zna_p15mc_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ALARM_Info.ZNA_P15MC)
}

// -------------------------------------------------------------------

// PEPS_Info

// optional uint32 RemoteFeedback_Sts = 1;
inline bool PEPS_Info::has_remotefeedback_sts() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PEPS_Info::set_has_remotefeedback_sts() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PEPS_Info::clear_has_remotefeedback_sts() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PEPS_Info::clear_remotefeedback_sts() {
  remotefeedback_sts_ = 0u;
  clear_has_remotefeedback_sts();
}
inline ::google::protobuf::uint32 PEPS_Info::remotefeedback_sts() const {
  // @@protoc_insertion_point(field_get:zna.protocol.PEPS_Info.RemoteFeedback_Sts)
  return remotefeedback_sts_;
}
inline void PEPS_Info::set_remotefeedback_sts(::google::protobuf::uint32 value) {
  set_has_remotefeedback_sts();
  remotefeedback_sts_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.PEPS_Info.RemoteFeedback_Sts)
}

// optional uint32 RemotePEPS_Mode = 2;
inline bool PEPS_Info::has_remotepeps_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PEPS_Info::set_has_remotepeps_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PEPS_Info::clear_has_remotepeps_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PEPS_Info::clear_remotepeps_mode() {
  remotepeps_mode_ = 0u;
  clear_has_remotepeps_mode();
}
inline ::google::protobuf::uint32 PEPS_Info::remotepeps_mode() const {
  // @@protoc_insertion_point(field_get:zna.protocol.PEPS_Info.RemotePEPS_Mode)
  return remotepeps_mode_;
}
inline void PEPS_Info::set_remotepeps_mode(::google::protobuf::uint32 value) {
  set_has_remotepeps_mode();
  remotepeps_mode_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.PEPS_Info.RemotePEPS_Mode)
}

// optional uint32 RemoteEngineRun_Cnt = 3;
inline bool PEPS_Info::has_remoteenginerun_cnt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PEPS_Info::set_has_remoteenginerun_cnt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PEPS_Info::clear_has_remoteenginerun_cnt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PEPS_Info::clear_remoteenginerun_cnt() {
  remoteenginerun_cnt_ = 0u;
  clear_has_remoteenginerun_cnt();
}
inline ::google::protobuf::uint32 PEPS_Info::remoteenginerun_cnt() const {
  // @@protoc_insertion_point(field_get:zna.protocol.PEPS_Info.RemoteEngineRun_Cnt)
  return remoteenginerun_cnt_;
}
inline void PEPS_Info::set_remoteenginerun_cnt(::google::protobuf::uint32 value) {
  set_has_remoteenginerun_cnt();
  remoteenginerun_cnt_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.PEPS_Info.RemoteEngineRun_Cnt)
}

// optional uint32 PEPS_PDU = 4;
inline bool PEPS_Info::has_peps_pdu() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PEPS_Info::set_has_peps_pdu() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PEPS_Info::clear_has_peps_pdu() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PEPS_Info::clear_peps_pdu() {
  peps_pdu_ = 0u;
  clear_has_peps_pdu();
}
inline ::google::protobuf::uint32 PEPS_Info::peps_pdu() const {
  // @@protoc_insertion_point(field_get:zna.protocol.PEPS_Info.PEPS_PDU)
  return peps_pdu_;
}
inline void PEPS_Info::set_peps_pdu(::google::protobuf::uint32 value) {
  set_has_peps_pdu();
  peps_pdu_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.PEPS_Info.PEPS_PDU)
}

// optional bool PEPS_Bluetooth = 5;
inline bool PEPS_Info::has_peps_bluetooth() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PEPS_Info::set_has_peps_bluetooth() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PEPS_Info::clear_has_peps_bluetooth() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PEPS_Info::clear_peps_bluetooth() {
  peps_bluetooth_ = false;
  clear_has_peps_bluetooth();
}
inline bool PEPS_Info::peps_bluetooth() const {
  // @@protoc_insertion_point(field_get:zna.protocol.PEPS_Info.PEPS_Bluetooth)
  return peps_bluetooth_;
}
inline void PEPS_Info::set_peps_bluetooth(bool value) {
  set_has_peps_bluetooth();
  peps_bluetooth_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.PEPS_Info.PEPS_Bluetooth)
}

// optional uint32 PEPS_MeterAlarm = 6;
inline bool PEPS_Info::has_peps_meteralarm() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PEPS_Info::set_has_peps_meteralarm() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PEPS_Info::clear_has_peps_meteralarm() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PEPS_Info::clear_peps_meteralarm() {
  peps_meteralarm_ = 0u;
  clear_has_peps_meteralarm();
}
inline ::google::protobuf::uint32 PEPS_Info::peps_meteralarm() const {
  // @@protoc_insertion_point(field_get:zna.protocol.PEPS_Info.PEPS_MeterAlarm)
  return peps_meteralarm_;
}
inline void PEPS_Info::set_peps_meteralarm(::google::protobuf::uint32 value) {
  set_has_peps_meteralarm();
  peps_meteralarm_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.PEPS_Info.PEPS_MeterAlarm)
}

// -------------------------------------------------------------------

// ESP_Info

// optional uint32 ESP_Lamp = 1;
inline bool ESP_Info::has_esp_lamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ESP_Info::set_has_esp_lamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ESP_Info::clear_has_esp_lamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ESP_Info::clear_esp_lamp() {
  esp_lamp_ = 0u;
  clear_has_esp_lamp();
}
inline ::google::protobuf::uint32 ESP_Info::esp_lamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ESP_Info.ESP_Lamp)
  return esp_lamp_;
}
inline void ESP_Info::set_esp_lamp(::google::protobuf::uint32 value) {
  set_has_esp_lamp();
  esp_lamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ESP_Info.ESP_Lamp)
}

// optional uint32 ABS_Lamp = 2;
inline bool ESP_Info::has_abs_lamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ESP_Info::set_has_abs_lamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ESP_Info::clear_has_abs_lamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ESP_Info::clear_abs_lamp() {
  abs_lamp_ = 0u;
  clear_has_abs_lamp();
}
inline ::google::protobuf::uint32 ESP_Info::abs_lamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ESP_Info.ABS_Lamp)
  return abs_lamp_;
}
inline void ESP_Info::set_abs_lamp(::google::protobuf::uint32 value) {
  set_has_abs_lamp();
  abs_lamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ESP_Info.ABS_Lamp)
}

// optional bool HAZ_Active = 3;
inline bool ESP_Info::has_haz_active() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ESP_Info::set_has_haz_active() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ESP_Info::clear_has_haz_active() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ESP_Info::clear_haz_active() {
  haz_active_ = false;
  clear_has_haz_active();
}
inline bool ESP_Info::haz_active() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ESP_Info.HAZ_Active)
  return haz_active_;
}
inline void ESP_Info::set_haz_active(bool value) {
  set_has_haz_active();
  haz_active_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ESP_Info.HAZ_Active)
}

// optional bool VehicleSpeed_Valid = 4;
inline bool ESP_Info::has_vehiclespeed_valid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ESP_Info::set_has_vehiclespeed_valid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ESP_Info::clear_has_vehiclespeed_valid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ESP_Info::clear_vehiclespeed_valid() {
  vehiclespeed_valid_ = false;
  clear_has_vehiclespeed_valid();
}
inline bool ESP_Info::vehiclespeed_valid() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ESP_Info.VehicleSpeed_Valid)
  return vehiclespeed_valid_;
}
inline void ESP_Info::set_vehiclespeed_valid(bool value) {
  set_has_vehiclespeed_valid();
  vehiclespeed_valid_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ESP_Info.VehicleSpeed_Valid)
}

// optional uint32 LongAccel = 5;
inline bool ESP_Info::has_longaccel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ESP_Info::set_has_longaccel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ESP_Info::clear_has_longaccel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ESP_Info::clear_longaccel() {
  longaccel_ = 0u;
  clear_has_longaccel();
}
inline ::google::protobuf::uint32 ESP_Info::longaccel() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ESP_Info.LongAccel)
  return longaccel_;
}
inline void ESP_Info::set_longaccel(::google::protobuf::uint32 value) {
  set_has_longaccel();
  longaccel_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ESP_Info.LongAccel)
}

// optional uint32 VehicleSpeed = 6;
inline bool ESP_Info::has_vehiclespeed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ESP_Info::set_has_vehiclespeed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ESP_Info::clear_has_vehiclespeed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ESP_Info::clear_vehiclespeed() {
  vehiclespeed_ = 0u;
  clear_has_vehiclespeed();
}
inline ::google::protobuf::uint32 ESP_Info::vehiclespeed() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ESP_Info.VehicleSpeed)
  return vehiclespeed_;
}
inline void ESP_Info::set_vehiclespeed(::google::protobuf::uint32 value) {
  set_has_vehiclespeed();
  vehiclespeed_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ESP_Info.VehicleSpeed)
}

// optional uint32 EBD_Lamp = 7;
inline bool ESP_Info::has_ebd_lamp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ESP_Info::set_has_ebd_lamp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ESP_Info::clear_has_ebd_lamp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ESP_Info::clear_ebd_lamp() {
  ebd_lamp_ = 0u;
  clear_has_ebd_lamp();
}
inline ::google::protobuf::uint32 ESP_Info::ebd_lamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ESP_Info.EBD_Lamp)
  return ebd_lamp_;
}
inline void ESP_Info::set_ebd_lamp(::google::protobuf::uint32 value) {
  set_has_ebd_lamp();
  ebd_lamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ESP_Info.EBD_Lamp)
}

// optional bool ABS_Acitve = 8;
inline bool ESP_Info::has_abs_acitve() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ESP_Info::set_has_abs_acitve() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ESP_Info::clear_has_abs_acitve() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ESP_Info::clear_abs_acitve() {
  abs_acitve_ = false;
  clear_has_abs_acitve();
}
inline bool ESP_Info::abs_acitve() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ESP_Info.ABS_Acitve)
  return abs_acitve_;
}
inline void ESP_Info::set_abs_acitve(bool value) {
  set_has_abs_acitve();
  abs_acitve_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ESP_Info.ABS_Acitve)
}

// -------------------------------------------------------------------

// EPB_Info

// optional uint32 EPB_FailStatus = 1;
inline bool EPB_Info::has_epb_failstatus() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EPB_Info::set_has_epb_failstatus() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EPB_Info::clear_has_epb_failstatus() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EPB_Info::clear_epb_failstatus() {
  epb_failstatus_ = 0u;
  clear_has_epb_failstatus();
}
inline ::google::protobuf::uint32 EPB_Info::epb_failstatus() const {
  // @@protoc_insertion_point(field_get:zna.protocol.EPB_Info.EPB_FailStatus)
  return epb_failstatus_;
}
inline void EPB_Info::set_epb_failstatus(::google::protobuf::uint32 value) {
  set_has_epb_failstatus();
  epb_failstatus_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.EPB_Info.EPB_FailStatus)
}

// -------------------------------------------------------------------

// TCU_Info

// optional uint32 TCU_Fault = 1;
inline bool TCU_Info::has_tcu_fault() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TCU_Info::set_has_tcu_fault() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TCU_Info::clear_has_tcu_fault() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TCU_Info::clear_tcu_fault() {
  tcu_fault_ = 0u;
  clear_has_tcu_fault();
}
inline ::google::protobuf::uint32 TCU_Info::tcu_fault() const {
  // @@protoc_insertion_point(field_get:zna.protocol.TCU_Info.TCU_Fault)
  return tcu_fault_;
}
inline void TCU_Info::set_tcu_fault(::google::protobuf::uint32 value) {
  set_has_tcu_fault();
  tcu_fault_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.TCU_Info.TCU_Fault)
}

// optional uint32 GearSelect_Pos = 2;
inline bool TCU_Info::has_gearselect_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TCU_Info::set_has_gearselect_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TCU_Info::clear_has_gearselect_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TCU_Info::clear_gearselect_pos() {
  gearselect_pos_ = 0u;
  clear_has_gearselect_pos();
}
inline ::google::protobuf::uint32 TCU_Info::gearselect_pos() const {
  // @@protoc_insertion_point(field_get:zna.protocol.TCU_Info.GearSelect_Pos)
  return gearselect_pos_;
}
inline void TCU_Info::set_gearselect_pos(::google::protobuf::uint32 value) {
  set_has_gearselect_pos();
  gearselect_pos_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.TCU_Info.GearSelect_Pos)
}

// optional uint32 Driving_Mode = 3;
inline bool TCU_Info::has_driving_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TCU_Info::set_has_driving_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TCU_Info::clear_has_driving_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TCU_Info::clear_driving_mode() {
  driving_mode_ = 0u;
  clear_has_driving_mode();
}
inline ::google::protobuf::uint32 TCU_Info::driving_mode() const {
  // @@protoc_insertion_point(field_get:zna.protocol.TCU_Info.Driving_Mode)
  return driving_mode_;
}
inline void TCU_Info::set_driving_mode(::google::protobuf::uint32 value) {
  set_has_driving_mode();
  driving_mode_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.TCU_Info.Driving_Mode)
}

// -------------------------------------------------------------------

// AWD_Info

// optional uint32 AWD_Mode = 1;
inline bool AWD_Info::has_awd_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AWD_Info::set_has_awd_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AWD_Info::clear_has_awd_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AWD_Info::clear_awd_mode() {
  awd_mode_ = 0u;
  clear_has_awd_mode();
}
inline ::google::protobuf::uint32 AWD_Info::awd_mode() const {
  // @@protoc_insertion_point(field_get:zna.protocol.AWD_Info.AWD_Mode)
  return awd_mode_;
}
inline void AWD_Info::set_awd_mode(::google::protobuf::uint32 value) {
  set_has_awd_mode();
  awd_mode_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.AWD_Info.AWD_Mode)
}

// -------------------------------------------------------------------

// AC_Info

// optional bool AC_OnState = 1;
inline bool AC_Info::has_ac_onstate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AC_Info::set_has_ac_onstate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AC_Info::clear_has_ac_onstate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AC_Info::clear_ac_onstate() {
  ac_onstate_ = false;
  clear_has_ac_onstate();
}
inline bool AC_Info::ac_onstate() const {
  // @@protoc_insertion_point(field_get:zna.protocol.AC_Info.AC_OnState)
  return ac_onstate_;
}
inline void AC_Info::set_ac_onstate(bool value) {
  set_has_ac_onstate();
  ac_onstate_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.AC_Info.AC_OnState)
}

// optional uint32 AirDistribution_Mode = 2;
inline bool AC_Info::has_airdistribution_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AC_Info::set_has_airdistribution_mode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AC_Info::clear_has_airdistribution_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AC_Info::clear_airdistribution_mode() {
  airdistribution_mode_ = 0u;
  clear_has_airdistribution_mode();
}
inline ::google::protobuf::uint32 AC_Info::airdistribution_mode() const {
  // @@protoc_insertion_point(field_get:zna.protocol.AC_Info.AirDistribution_Mode)
  return airdistribution_mode_;
}
inline void AC_Info::set_airdistribution_mode(::google::protobuf::uint32 value) {
  set_has_airdistribution_mode();
  airdistribution_mode_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.AC_Info.AirDistribution_Mode)
}

// optional uint32 ACInsideSen_Temp = 3;
inline bool AC_Info::has_acinsidesen_temp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AC_Info::set_has_acinsidesen_temp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AC_Info::clear_has_acinsidesen_temp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AC_Info::clear_acinsidesen_temp() {
  acinsidesen_temp_ = 0u;
  clear_has_acinsidesen_temp();
}
inline ::google::protobuf::uint32 AC_Info::acinsidesen_temp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.AC_Info.ACInsideSen_Temp)
  return acinsidesen_temp_;
}
inline void AC_Info::set_acinsidesen_temp(::google::protobuf::uint32 value) {
  set_has_acinsidesen_temp();
  acinsidesen_temp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.AC_Info.ACInsideSen_Temp)
}

// -------------------------------------------------------------------

// SAS_Info

// optional uint32 SteeringAngel = 1;
inline bool SAS_Info::has_steeringangel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SAS_Info::set_has_steeringangel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SAS_Info::clear_has_steeringangel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SAS_Info::clear_steeringangel() {
  steeringangel_ = 0u;
  clear_has_steeringangel();
}
inline ::google::protobuf::uint32 SAS_Info::steeringangel() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SAS_Info.SteeringAngel)
  return steeringangel_;
}
inline void SAS_Info::set_steeringangel(::google::protobuf::uint32 value) {
  set_has_steeringangel();
  steeringangel_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SAS_Info.SteeringAngel)
}

// optional uint32 SteeringAngel_Velocity = 2;
inline bool SAS_Info::has_steeringangel_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SAS_Info::set_has_steeringangel_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SAS_Info::clear_has_steeringangel_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SAS_Info::clear_steeringangel_velocity() {
  steeringangel_velocity_ = 0u;
  clear_has_steeringangel_velocity();
}
inline ::google::protobuf::uint32 SAS_Info::steeringangel_velocity() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SAS_Info.SteeringAngel_Velocity)
  return steeringangel_velocity_;
}
inline void SAS_Info::set_steeringangel_velocity(::google::protobuf::uint32 value) {
  set_has_steeringangel_velocity();
  steeringangel_velocity_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SAS_Info.SteeringAngel_Velocity)
}

// -------------------------------------------------------------------

// Basic_Info

// optional .zna.protocol.ECM_Info ecm_info = 1;
inline bool Basic_Info::has_ecm_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Basic_Info::set_has_ecm_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Basic_Info::clear_has_ecm_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Basic_Info::clear_ecm_info() {
  if (ecm_info_ != NULL) ecm_info_->::zna::protocol::ECM_Info::Clear();
  clear_has_ecm_info();
}
inline const ::zna::protocol::ECM_Info& Basic_Info::ecm_info() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Basic_Info.ecm_info)
  return ecm_info_ != NULL ? *ecm_info_ : *default_instance_->ecm_info_;
}
inline ::zna::protocol::ECM_Info* Basic_Info::mutable_ecm_info() {
  set_has_ecm_info();
  if (ecm_info_ == NULL) ecm_info_ = new ::zna::protocol::ECM_Info;
  // @@protoc_insertion_point(field_mutable:zna.protocol.Basic_Info.ecm_info)
  return ecm_info_;
}
inline ::zna::protocol::ECM_Info* Basic_Info::release_ecm_info() {
  clear_has_ecm_info();
  ::zna::protocol::ECM_Info* temp = ecm_info_;
  ecm_info_ = NULL;
  return temp;
}
inline void Basic_Info::set_allocated_ecm_info(::zna::protocol::ECM_Info* ecm_info) {
  delete ecm_info_;
  ecm_info_ = ecm_info;
  if (ecm_info) {
    set_has_ecm_info();
  } else {
    clear_has_ecm_info();
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.Basic_Info.ecm_info)
}

// optional .zna.protocol.METER_Info meter_info = 3;
inline bool Basic_Info::has_meter_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Basic_Info::set_has_meter_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Basic_Info::clear_has_meter_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Basic_Info::clear_meter_info() {
  if (meter_info_ != NULL) meter_info_->::zna::protocol::METER_Info::Clear();
  clear_has_meter_info();
}
inline const ::zna::protocol::METER_Info& Basic_Info::meter_info() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Basic_Info.meter_info)
  return meter_info_ != NULL ? *meter_info_ : *default_instance_->meter_info_;
}
inline ::zna::protocol::METER_Info* Basic_Info::mutable_meter_info() {
  set_has_meter_info();
  if (meter_info_ == NULL) meter_info_ = new ::zna::protocol::METER_Info;
  // @@protoc_insertion_point(field_mutable:zna.protocol.Basic_Info.meter_info)
  return meter_info_;
}
inline ::zna::protocol::METER_Info* Basic_Info::release_meter_info() {
  clear_has_meter_info();
  ::zna::protocol::METER_Info* temp = meter_info_;
  meter_info_ = NULL;
  return temp;
}
inline void Basic_Info::set_allocated_meter_info(::zna::protocol::METER_Info* meter_info) {
  delete meter_info_;
  meter_info_ = meter_info;
  if (meter_info) {
    set_has_meter_info();
  } else {
    clear_has_meter_info();
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.Basic_Info.meter_info)
}

// optional .zna.protocol.BCM_Info bcm_info = 4;
inline bool Basic_Info::has_bcm_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Basic_Info::set_has_bcm_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Basic_Info::clear_has_bcm_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Basic_Info::clear_bcm_info() {
  if (bcm_info_ != NULL) bcm_info_->::zna::protocol::BCM_Info::Clear();
  clear_has_bcm_info();
}
inline const ::zna::protocol::BCM_Info& Basic_Info::bcm_info() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Basic_Info.bcm_info)
  return bcm_info_ != NULL ? *bcm_info_ : *default_instance_->bcm_info_;
}
inline ::zna::protocol::BCM_Info* Basic_Info::mutable_bcm_info() {
  set_has_bcm_info();
  if (bcm_info_ == NULL) bcm_info_ = new ::zna::protocol::BCM_Info;
  // @@protoc_insertion_point(field_mutable:zna.protocol.Basic_Info.bcm_info)
  return bcm_info_;
}
inline ::zna::protocol::BCM_Info* Basic_Info::release_bcm_info() {
  clear_has_bcm_info();
  ::zna::protocol::BCM_Info* temp = bcm_info_;
  bcm_info_ = NULL;
  return temp;
}
inline void Basic_Info::set_allocated_bcm_info(::zna::protocol::BCM_Info* bcm_info) {
  delete bcm_info_;
  bcm_info_ = bcm_info;
  if (bcm_info) {
    set_has_bcm_info();
  } else {
    clear_has_bcm_info();
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.Basic_Info.bcm_info)
}

// optional .zna.protocol.ACU_Info acu_info = 5;
inline bool Basic_Info::has_acu_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Basic_Info::set_has_acu_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Basic_Info::clear_has_acu_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Basic_Info::clear_acu_info() {
  if (acu_info_ != NULL) acu_info_->::zna::protocol::ACU_Info::Clear();
  clear_has_acu_info();
}
inline const ::zna::protocol::ACU_Info& Basic_Info::acu_info() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Basic_Info.acu_info)
  return acu_info_ != NULL ? *acu_info_ : *default_instance_->acu_info_;
}
inline ::zna::protocol::ACU_Info* Basic_Info::mutable_acu_info() {
  set_has_acu_info();
  if (acu_info_ == NULL) acu_info_ = new ::zna::protocol::ACU_Info;
  // @@protoc_insertion_point(field_mutable:zna.protocol.Basic_Info.acu_info)
  return acu_info_;
}
inline ::zna::protocol::ACU_Info* Basic_Info::release_acu_info() {
  clear_has_acu_info();
  ::zna::protocol::ACU_Info* temp = acu_info_;
  acu_info_ = NULL;
  return temp;
}
inline void Basic_Info::set_allocated_acu_info(::zna::protocol::ACU_Info* acu_info) {
  delete acu_info_;
  acu_info_ = acu_info;
  if (acu_info) {
    set_has_acu_info();
  } else {
    clear_has_acu_info();
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.Basic_Info.acu_info)
}

// optional .zna.protocol.ECO_Info eco_info = 12;
inline bool Basic_Info::has_eco_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Basic_Info::set_has_eco_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Basic_Info::clear_has_eco_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Basic_Info::clear_eco_info() {
  if (eco_info_ != NULL) eco_info_->::zna::protocol::ECO_Info::Clear();
  clear_has_eco_info();
}
inline const ::zna::protocol::ECO_Info& Basic_Info::eco_info() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Basic_Info.eco_info)
  return eco_info_ != NULL ? *eco_info_ : *default_instance_->eco_info_;
}
inline ::zna::protocol::ECO_Info* Basic_Info::mutable_eco_info() {
  set_has_eco_info();
  if (eco_info_ == NULL) eco_info_ = new ::zna::protocol::ECO_Info;
  // @@protoc_insertion_point(field_mutable:zna.protocol.Basic_Info.eco_info)
  return eco_info_;
}
inline ::zna::protocol::ECO_Info* Basic_Info::release_eco_info() {
  clear_has_eco_info();
  ::zna::protocol::ECO_Info* temp = eco_info_;
  eco_info_ = NULL;
  return temp;
}
inline void Basic_Info::set_allocated_eco_info(::zna::protocol::ECO_Info* eco_info) {
  delete eco_info_;
  eco_info_ = eco_info;
  if (eco_info) {
    set_has_eco_info();
  } else {
    clear_has_eco_info();
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.Basic_Info.eco_info)
}

// optional .zna.protocol.ALARM_Info alarm_info = 13;
inline bool Basic_Info::has_alarm_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Basic_Info::set_has_alarm_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Basic_Info::clear_has_alarm_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Basic_Info::clear_alarm_info() {
  if (alarm_info_ != NULL) alarm_info_->::zna::protocol::ALARM_Info::Clear();
  clear_has_alarm_info();
}
inline const ::zna::protocol::ALARM_Info& Basic_Info::alarm_info() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Basic_Info.alarm_info)
  return alarm_info_ != NULL ? *alarm_info_ : *default_instance_->alarm_info_;
}
inline ::zna::protocol::ALARM_Info* Basic_Info::mutable_alarm_info() {
  set_has_alarm_info();
  if (alarm_info_ == NULL) alarm_info_ = new ::zna::protocol::ALARM_Info;
  // @@protoc_insertion_point(field_mutable:zna.protocol.Basic_Info.alarm_info)
  return alarm_info_;
}
inline ::zna::protocol::ALARM_Info* Basic_Info::release_alarm_info() {
  clear_has_alarm_info();
  ::zna::protocol::ALARM_Info* temp = alarm_info_;
  alarm_info_ = NULL;
  return temp;
}
inline void Basic_Info::set_allocated_alarm_info(::zna::protocol::ALARM_Info* alarm_info) {
  delete alarm_info_;
  alarm_info_ = alarm_info;
  if (alarm_info) {
    set_has_alarm_info();
  } else {
    clear_has_alarm_info();
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.Basic_Info.alarm_info)
}

// optional .zna.protocol.PEPS_Info peps_info = 20;
inline bool Basic_Info::has_peps_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Basic_Info::set_has_peps_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Basic_Info::clear_has_peps_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Basic_Info::clear_peps_info() {
  if (peps_info_ != NULL) peps_info_->::zna::protocol::PEPS_Info::Clear();
  clear_has_peps_info();
}
inline const ::zna::protocol::PEPS_Info& Basic_Info::peps_info() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Basic_Info.peps_info)
  return peps_info_ != NULL ? *peps_info_ : *default_instance_->peps_info_;
}
inline ::zna::protocol::PEPS_Info* Basic_Info::mutable_peps_info() {
  set_has_peps_info();
  if (peps_info_ == NULL) peps_info_ = new ::zna::protocol::PEPS_Info;
  // @@protoc_insertion_point(field_mutable:zna.protocol.Basic_Info.peps_info)
  return peps_info_;
}
inline ::zna::protocol::PEPS_Info* Basic_Info::release_peps_info() {
  clear_has_peps_info();
  ::zna::protocol::PEPS_Info* temp = peps_info_;
  peps_info_ = NULL;
  return temp;
}
inline void Basic_Info::set_allocated_peps_info(::zna::protocol::PEPS_Info* peps_info) {
  delete peps_info_;
  peps_info_ = peps_info;
  if (peps_info) {
    set_has_peps_info();
  } else {
    clear_has_peps_info();
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.Basic_Info.peps_info)
}

// optional .zna.protocol.ESP_Info esp_info = 21;
inline bool Basic_Info::has_esp_info() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Basic_Info::set_has_esp_info() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Basic_Info::clear_has_esp_info() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Basic_Info::clear_esp_info() {
  if (esp_info_ != NULL) esp_info_->::zna::protocol::ESP_Info::Clear();
  clear_has_esp_info();
}
inline const ::zna::protocol::ESP_Info& Basic_Info::esp_info() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Basic_Info.esp_info)
  return esp_info_ != NULL ? *esp_info_ : *default_instance_->esp_info_;
}
inline ::zna::protocol::ESP_Info* Basic_Info::mutable_esp_info() {
  set_has_esp_info();
  if (esp_info_ == NULL) esp_info_ = new ::zna::protocol::ESP_Info;
  // @@protoc_insertion_point(field_mutable:zna.protocol.Basic_Info.esp_info)
  return esp_info_;
}
inline ::zna::protocol::ESP_Info* Basic_Info::release_esp_info() {
  clear_has_esp_info();
  ::zna::protocol::ESP_Info* temp = esp_info_;
  esp_info_ = NULL;
  return temp;
}
inline void Basic_Info::set_allocated_esp_info(::zna::protocol::ESP_Info* esp_info) {
  delete esp_info_;
  esp_info_ = esp_info;
  if (esp_info) {
    set_has_esp_info();
  } else {
    clear_has_esp_info();
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.Basic_Info.esp_info)
}

// optional .zna.protocol.EPB_Info epb_info = 22;
inline bool Basic_Info::has_epb_info() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Basic_Info::set_has_epb_info() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Basic_Info::clear_has_epb_info() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Basic_Info::clear_epb_info() {
  if (epb_info_ != NULL) epb_info_->::zna::protocol::EPB_Info::Clear();
  clear_has_epb_info();
}
inline const ::zna::protocol::EPB_Info& Basic_Info::epb_info() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Basic_Info.epb_info)
  return epb_info_ != NULL ? *epb_info_ : *default_instance_->epb_info_;
}
inline ::zna::protocol::EPB_Info* Basic_Info::mutable_epb_info() {
  set_has_epb_info();
  if (epb_info_ == NULL) epb_info_ = new ::zna::protocol::EPB_Info;
  // @@protoc_insertion_point(field_mutable:zna.protocol.Basic_Info.epb_info)
  return epb_info_;
}
inline ::zna::protocol::EPB_Info* Basic_Info::release_epb_info() {
  clear_has_epb_info();
  ::zna::protocol::EPB_Info* temp = epb_info_;
  epb_info_ = NULL;
  return temp;
}
inline void Basic_Info::set_allocated_epb_info(::zna::protocol::EPB_Info* epb_info) {
  delete epb_info_;
  epb_info_ = epb_info;
  if (epb_info) {
    set_has_epb_info();
  } else {
    clear_has_epb_info();
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.Basic_Info.epb_info)
}

// optional .zna.protocol.TCU_Info tcu_info = 23;
inline bool Basic_Info::has_tcu_info() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Basic_Info::set_has_tcu_info() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Basic_Info::clear_has_tcu_info() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Basic_Info::clear_tcu_info() {
  if (tcu_info_ != NULL) tcu_info_->::zna::protocol::TCU_Info::Clear();
  clear_has_tcu_info();
}
inline const ::zna::protocol::TCU_Info& Basic_Info::tcu_info() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Basic_Info.tcu_info)
  return tcu_info_ != NULL ? *tcu_info_ : *default_instance_->tcu_info_;
}
inline ::zna::protocol::TCU_Info* Basic_Info::mutable_tcu_info() {
  set_has_tcu_info();
  if (tcu_info_ == NULL) tcu_info_ = new ::zna::protocol::TCU_Info;
  // @@protoc_insertion_point(field_mutable:zna.protocol.Basic_Info.tcu_info)
  return tcu_info_;
}
inline ::zna::protocol::TCU_Info* Basic_Info::release_tcu_info() {
  clear_has_tcu_info();
  ::zna::protocol::TCU_Info* temp = tcu_info_;
  tcu_info_ = NULL;
  return temp;
}
inline void Basic_Info::set_allocated_tcu_info(::zna::protocol::TCU_Info* tcu_info) {
  delete tcu_info_;
  tcu_info_ = tcu_info;
  if (tcu_info) {
    set_has_tcu_info();
  } else {
    clear_has_tcu_info();
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.Basic_Info.tcu_info)
}

// optional .zna.protocol.AWD_Info awd_info = 24;
inline bool Basic_Info::has_awd_info() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Basic_Info::set_has_awd_info() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Basic_Info::clear_has_awd_info() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Basic_Info::clear_awd_info() {
  if (awd_info_ != NULL) awd_info_->::zna::protocol::AWD_Info::Clear();
  clear_has_awd_info();
}
inline const ::zna::protocol::AWD_Info& Basic_Info::awd_info() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Basic_Info.awd_info)
  return awd_info_ != NULL ? *awd_info_ : *default_instance_->awd_info_;
}
inline ::zna::protocol::AWD_Info* Basic_Info::mutable_awd_info() {
  set_has_awd_info();
  if (awd_info_ == NULL) awd_info_ = new ::zna::protocol::AWD_Info;
  // @@protoc_insertion_point(field_mutable:zna.protocol.Basic_Info.awd_info)
  return awd_info_;
}
inline ::zna::protocol::AWD_Info* Basic_Info::release_awd_info() {
  clear_has_awd_info();
  ::zna::protocol::AWD_Info* temp = awd_info_;
  awd_info_ = NULL;
  return temp;
}
inline void Basic_Info::set_allocated_awd_info(::zna::protocol::AWD_Info* awd_info) {
  delete awd_info_;
  awd_info_ = awd_info;
  if (awd_info) {
    set_has_awd_info();
  } else {
    clear_has_awd_info();
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.Basic_Info.awd_info)
}

// optional .zna.protocol.AC_Info ac_info = 25;
inline bool Basic_Info::has_ac_info() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Basic_Info::set_has_ac_info() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Basic_Info::clear_has_ac_info() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Basic_Info::clear_ac_info() {
  if (ac_info_ != NULL) ac_info_->::zna::protocol::AC_Info::Clear();
  clear_has_ac_info();
}
inline const ::zna::protocol::AC_Info& Basic_Info::ac_info() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Basic_Info.ac_info)
  return ac_info_ != NULL ? *ac_info_ : *default_instance_->ac_info_;
}
inline ::zna::protocol::AC_Info* Basic_Info::mutable_ac_info() {
  set_has_ac_info();
  if (ac_info_ == NULL) ac_info_ = new ::zna::protocol::AC_Info;
  // @@protoc_insertion_point(field_mutable:zna.protocol.Basic_Info.ac_info)
  return ac_info_;
}
inline ::zna::protocol::AC_Info* Basic_Info::release_ac_info() {
  clear_has_ac_info();
  ::zna::protocol::AC_Info* temp = ac_info_;
  ac_info_ = NULL;
  return temp;
}
inline void Basic_Info::set_allocated_ac_info(::zna::protocol::AC_Info* ac_info) {
  delete ac_info_;
  ac_info_ = ac_info;
  if (ac_info) {
    set_has_ac_info();
  } else {
    clear_has_ac_info();
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.Basic_Info.ac_info)
}

// optional .zna.protocol.SAS_Info sas_info = 26;
inline bool Basic_Info::has_sas_info() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Basic_Info::set_has_sas_info() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Basic_Info::clear_has_sas_info() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Basic_Info::clear_sas_info() {
  if (sas_info_ != NULL) sas_info_->::zna::protocol::SAS_Info::Clear();
  clear_has_sas_info();
}
inline const ::zna::protocol::SAS_Info& Basic_Info::sas_info() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Basic_Info.sas_info)
  return sas_info_ != NULL ? *sas_info_ : *default_instance_->sas_info_;
}
inline ::zna::protocol::SAS_Info* Basic_Info::mutable_sas_info() {
  set_has_sas_info();
  if (sas_info_ == NULL) sas_info_ = new ::zna::protocol::SAS_Info;
  // @@protoc_insertion_point(field_mutable:zna.protocol.Basic_Info.sas_info)
  return sas_info_;
}
inline ::zna::protocol::SAS_Info* Basic_Info::release_sas_info() {
  clear_has_sas_info();
  ::zna::protocol::SAS_Info* temp = sas_info_;
  sas_info_ = NULL;
  return temp;
}
inline void Basic_Info::set_allocated_sas_info(::zna::protocol::SAS_Info* sas_info) {
  delete sas_info_;
  sas_info_ = sas_info;
  if (sas_info) {
    set_has_sas_info();
  } else {
    clear_has_sas_info();
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.Basic_Info.sas_info)
}

// optional .zna.protocol.FCM_Info fcm_info = 27;
inline bool Basic_Info::has_fcm_info() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Basic_Info::set_has_fcm_info() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Basic_Info::clear_has_fcm_info() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Basic_Info::clear_fcm_info() {
  if (fcm_info_ != NULL) fcm_info_->::zna::protocol::FCM_Info::Clear();
  clear_has_fcm_info();
}
inline const ::zna::protocol::FCM_Info& Basic_Info::fcm_info() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Basic_Info.fcm_info)
  return fcm_info_ != NULL ? *fcm_info_ : *default_instance_->fcm_info_;
}
inline ::zna::protocol::FCM_Info* Basic_Info::mutable_fcm_info() {
  set_has_fcm_info();
  if (fcm_info_ == NULL) fcm_info_ = new ::zna::protocol::FCM_Info;
  // @@protoc_insertion_point(field_mutable:zna.protocol.Basic_Info.fcm_info)
  return fcm_info_;
}
inline ::zna::protocol::FCM_Info* Basic_Info::release_fcm_info() {
  clear_has_fcm_info();
  ::zna::protocol::FCM_Info* temp = fcm_info_;
  fcm_info_ = NULL;
  return temp;
}
inline void Basic_Info::set_allocated_fcm_info(::zna::protocol::FCM_Info* fcm_info) {
  delete fcm_info_;
  fcm_info_ = fcm_info;
  if (fcm_info) {
    set_has_fcm_info();
  } else {
    clear_has_fcm_info();
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.Basic_Info.fcm_info)
}

// optional .zna.protocol.EPS_Info eps_info = 28;
inline bool Basic_Info::has_eps_info() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Basic_Info::set_has_eps_info() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Basic_Info::clear_has_eps_info() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Basic_Info::clear_eps_info() {
  if (eps_info_ != NULL) eps_info_->::zna::protocol::EPS_Info::Clear();
  clear_has_eps_info();
}
inline const ::zna::protocol::EPS_Info& Basic_Info::eps_info() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Basic_Info.eps_info)
  return eps_info_ != NULL ? *eps_info_ : *default_instance_->eps_info_;
}
inline ::zna::protocol::EPS_Info* Basic_Info::mutable_eps_info() {
  set_has_eps_info();
  if (eps_info_ == NULL) eps_info_ = new ::zna::protocol::EPS_Info;
  // @@protoc_insertion_point(field_mutable:zna.protocol.Basic_Info.eps_info)
  return eps_info_;
}
inline ::zna::protocol::EPS_Info* Basic_Info::release_eps_info() {
  clear_has_eps_info();
  ::zna::protocol::EPS_Info* temp = eps_info_;
  eps_info_ = NULL;
  return temp;
}
inline void Basic_Info::set_allocated_eps_info(::zna::protocol::EPS_Info* eps_info) {
  delete eps_info_;
  eps_info_ = eps_info;
  if (eps_info) {
    set_has_eps_info();
  } else {
    clear_has_eps_info();
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.Basic_Info.eps_info)
}

// optional .zna.protocol.ELD_Info eld_info = 29;
inline bool Basic_Info::has_eld_info() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Basic_Info::set_has_eld_info() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Basic_Info::clear_has_eld_info() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Basic_Info::clear_eld_info() {
  if (eld_info_ != NULL) eld_info_->::zna::protocol::ELD_Info::Clear();
  clear_has_eld_info();
}
inline const ::zna::protocol::ELD_Info& Basic_Info::eld_info() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Basic_Info.eld_info)
  return eld_info_ != NULL ? *eld_info_ : *default_instance_->eld_info_;
}
inline ::zna::protocol::ELD_Info* Basic_Info::mutable_eld_info() {
  set_has_eld_info();
  if (eld_info_ == NULL) eld_info_ = new ::zna::protocol::ELD_Info;
  // @@protoc_insertion_point(field_mutable:zna.protocol.Basic_Info.eld_info)
  return eld_info_;
}
inline ::zna::protocol::ELD_Info* Basic_Info::release_eld_info() {
  clear_has_eld_info();
  ::zna::protocol::ELD_Info* temp = eld_info_;
  eld_info_ = NULL;
  return temp;
}
inline void Basic_Info::set_allocated_eld_info(::zna::protocol::ELD_Info* eld_info) {
  delete eld_info_;
  eld_info_ = eld_info;
  if (eld_info) {
    set_has_eld_info();
  } else {
    clear_has_eld_info();
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.Basic_Info.eld_info)
}

// optional .zna.protocol.ECU_Info ecu_info = 30;
inline bool Basic_Info::has_ecu_info() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Basic_Info::set_has_ecu_info() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Basic_Info::clear_has_ecu_info() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Basic_Info::clear_ecu_info() {
  if (ecu_info_ != NULL) ecu_info_->::zna::protocol::ECU_Info::Clear();
  clear_has_ecu_info();
}
inline const ::zna::protocol::ECU_Info& Basic_Info::ecu_info() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Basic_Info.ecu_info)
  return ecu_info_ != NULL ? *ecu_info_ : *default_instance_->ecu_info_;
}
inline ::zna::protocol::ECU_Info* Basic_Info::mutable_ecu_info() {
  set_has_ecu_info();
  if (ecu_info_ == NULL) ecu_info_ = new ::zna::protocol::ECU_Info;
  // @@protoc_insertion_point(field_mutable:zna.protocol.Basic_Info.ecu_info)
  return ecu_info_;
}
inline ::zna::protocol::ECU_Info* Basic_Info::release_ecu_info() {
  clear_has_ecu_info();
  ::zna::protocol::ECU_Info* temp = ecu_info_;
  ecu_info_ = NULL;
  return temp;
}
inline void Basic_Info::set_allocated_ecu_info(::zna::protocol::ECU_Info* ecu_info) {
  delete ecu_info_;
  ecu_info_ = ecu_info;
  if (ecu_info) {
    set_has_ecu_info();
  } else {
    clear_has_ecu_info();
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.Basic_Info.ecu_info)
}

// -------------------------------------------------------------------

// Vehicle_Info

// required bool Info_type = 1;
inline bool Vehicle_Info::has_info_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vehicle_Info::set_has_info_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vehicle_Info::clear_has_info_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vehicle_Info::clear_info_type() {
  info_type_ = false;
  clear_has_info_type();
}
inline bool Vehicle_Info::info_type() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Vehicle_Info.Info_type)
  return info_type_;
}
inline void Vehicle_Info::set_info_type(bool value) {
  set_has_info_type();
  info_type_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.Vehicle_Info.Info_type)
}

// required uint32 collect_time = 2;
inline bool Vehicle_Info::has_collect_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vehicle_Info::set_has_collect_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vehicle_Info::clear_has_collect_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vehicle_Info::clear_collect_time() {
  collect_time_ = 0u;
  clear_has_collect_time();
}
inline ::google::protobuf::uint32 Vehicle_Info::collect_time() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Vehicle_Info.collect_time)
  return collect_time_;
}
inline void Vehicle_Info::set_collect_time(::google::protobuf::uint32 value) {
  set_has_collect_time();
  collect_time_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.Vehicle_Info.collect_time)
}

// required .zna.protocol.Basic_Info basic_info = 3;
inline bool Vehicle_Info::has_basic_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vehicle_Info::set_has_basic_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vehicle_Info::clear_has_basic_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vehicle_Info::clear_basic_info() {
  if (basic_info_ != NULL) basic_info_->::zna::protocol::Basic_Info::Clear();
  clear_has_basic_info();
}
inline const ::zna::protocol::Basic_Info& Vehicle_Info::basic_info() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Vehicle_Info.basic_info)
  return basic_info_ != NULL ? *basic_info_ : *default_instance_->basic_info_;
}
inline ::zna::protocol::Basic_Info* Vehicle_Info::mutable_basic_info() {
  set_has_basic_info();
  if (basic_info_ == NULL) basic_info_ = new ::zna::protocol::Basic_Info;
  // @@protoc_insertion_point(field_mutable:zna.protocol.Vehicle_Info.basic_info)
  return basic_info_;
}
inline ::zna::protocol::Basic_Info* Vehicle_Info::release_basic_info() {
  clear_has_basic_info();
  ::zna::protocol::Basic_Info* temp = basic_info_;
  basic_info_ = NULL;
  return temp;
}
inline void Vehicle_Info::set_allocated_basic_info(::zna::protocol::Basic_Info* basic_info) {
  delete basic_info_;
  basic_info_ = basic_info;
  if (basic_info) {
    set_has_basic_info();
  } else {
    clear_has_basic_info();
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.Vehicle_Info.basic_info)
}

// required uint32 time_stamp = 4;
inline bool Vehicle_Info::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Vehicle_Info::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Vehicle_Info::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Vehicle_Info::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 Vehicle_Info::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Vehicle_Info.time_stamp)
  return time_stamp_;
}
inline void Vehicle_Info::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.Vehicle_Info.time_stamp)
}

// optional uint32 IgnOnTag = 5;
inline bool Vehicle_Info::has_ignontag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Vehicle_Info::set_has_ignontag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Vehicle_Info::clear_has_ignontag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Vehicle_Info::clear_ignontag() {
  ignontag_ = 0u;
  clear_has_ignontag();
}
inline ::google::protobuf::uint32 Vehicle_Info::ignontag() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Vehicle_Info.IgnOnTag)
  return ignontag_;
}
inline void Vehicle_Info::set_ignontag(::google::protobuf::uint32 value) {
  set_has_ignontag();
  ignontag_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.Vehicle_Info.IgnOnTag)
}

// optional uint32 EF82 = 6;
inline bool Vehicle_Info::has_ef82() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Vehicle_Info::set_has_ef82() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Vehicle_Info::clear_has_ef82() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Vehicle_Info::clear_ef82() {
  ef82_ = 0u;
  clear_has_ef82();
}
inline ::google::protobuf::uint32 Vehicle_Info::ef82() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Vehicle_Info.EF82)
  return ef82_;
}
inline void Vehicle_Info::set_ef82(::google::protobuf::uint32 value) {
  set_has_ef82();
  ef82_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.Vehicle_Info.EF82)
}

// optional string Version = 7;
inline bool Vehicle_Info::has_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Vehicle_Info::set_has_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Vehicle_Info::clear_has_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Vehicle_Info::clear_version() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& Vehicle_Info::version() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Vehicle_Info.Version)
  return *version_;
}
inline void Vehicle_Info::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.Vehicle_Info.Version)
}
inline void Vehicle_Info::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.Vehicle_Info.Version)
}
inline void Vehicle_Info::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.Vehicle_Info.Version)
}
inline ::std::string* Vehicle_Info::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.Vehicle_Info.Version)
  return version_;
}
inline ::std::string* Vehicle_Info::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Vehicle_Info::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.Vehicle_Info.Version)
}

// -------------------------------------------------------------------

// Vehicle_InfoRsp

// required uint32 errcode = 1;
inline bool Vehicle_InfoRsp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vehicle_InfoRsp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vehicle_InfoRsp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vehicle_InfoRsp::clear_errcode() {
  errcode_ = 0u;
  clear_has_errcode();
}
inline ::google::protobuf::uint32 Vehicle_InfoRsp::errcode() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Vehicle_InfoRsp.errcode)
  return errcode_;
}
inline void Vehicle_InfoRsp::set_errcode(::google::protobuf::uint32 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.Vehicle_InfoRsp.errcode)
}

// required uint32 time_stamp = 2;
inline bool Vehicle_InfoRsp::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vehicle_InfoRsp::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vehicle_InfoRsp::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vehicle_InfoRsp::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 Vehicle_InfoRsp::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Vehicle_InfoRsp.time_stamp)
  return time_stamp_;
}
inline void Vehicle_InfoRsp::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.Vehicle_InfoRsp.time_stamp)
}

// -------------------------------------------------------------------

// Location_Info

// required bool Info_type = 1;
inline bool Location_Info::has_info_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Location_Info::set_has_info_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Location_Info::clear_has_info_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Location_Info::clear_info_type() {
  info_type_ = false;
  clear_has_info_type();
}
inline bool Location_Info::info_type() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Location_Info.Info_type)
  return info_type_;
}
inline void Location_Info::set_info_type(bool value) {
  set_has_info_type();
  info_type_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.Location_Info.Info_type)
}

// required uint32 location_status = 3;
inline bool Location_Info::has_location_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Location_Info::set_has_location_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Location_Info::clear_has_location_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Location_Info::clear_location_status() {
  location_status_ = 0u;
  clear_has_location_status();
}
inline ::google::protobuf::uint32 Location_Info::location_status() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Location_Info.location_status)
  return location_status_;
}
inline void Location_Info::set_location_status(::google::protobuf::uint32 value) {
  set_has_location_status();
  location_status_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.Location_Info.location_status)
}

// required uint32 longitude = 4;
inline bool Location_Info::has_longitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Location_Info::set_has_longitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Location_Info::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Location_Info::clear_longitude() {
  longitude_ = 0u;
  clear_has_longitude();
}
inline ::google::protobuf::uint32 Location_Info::longitude() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Location_Info.longitude)
  return longitude_;
}
inline void Location_Info::set_longitude(::google::protobuf::uint32 value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.Location_Info.longitude)
}

// required uint32 latitude = 5;
inline bool Location_Info::has_latitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Location_Info::set_has_latitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Location_Info::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Location_Info::clear_latitude() {
  latitude_ = 0u;
  clear_has_latitude();
}
inline ::google::protobuf::uint32 Location_Info::latitude() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Location_Info.latitude)
  return latitude_;
}
inline void Location_Info::set_latitude(::google::protobuf::uint32 value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.Location_Info.latitude)
}

// required uint32 time_stamp = 8;
inline bool Location_Info::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Location_Info::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Location_Info::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Location_Info::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 Location_Info::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Location_Info.time_stamp)
  return time_stamp_;
}
inline void Location_Info::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.Location_Info.time_stamp)
}

// optional uint32 isGPSconversion = 9;
inline bool Location_Info::has_isgpsconversion() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Location_Info::set_has_isgpsconversion() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Location_Info::clear_has_isgpsconversion() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Location_Info::clear_isgpsconversion() {
  isgpsconversion_ = 0u;
  clear_has_isgpsconversion();
}
inline ::google::protobuf::uint32 Location_Info::isgpsconversion() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Location_Info.isGPSconversion)
  return isgpsconversion_;
}
inline void Location_Info::set_isgpsconversion(::google::protobuf::uint32 value) {
  set_has_isgpsconversion();
  isgpsconversion_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.Location_Info.isGPSconversion)
}

// required uint64 gps_time = 10;
inline bool Location_Info::has_gps_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Location_Info::set_has_gps_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Location_Info::clear_has_gps_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Location_Info::clear_gps_time() {
  gps_time_ = GOOGLE_ULONGLONG(0);
  clear_has_gps_time();
}
inline ::google::protobuf::uint64 Location_Info::gps_time() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Location_Info.gps_time)
  return gps_time_;
}
inline void Location_Info::set_gps_time(::google::protobuf::uint64 value) {
  set_has_gps_time();
  gps_time_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.Location_Info.gps_time)
}

// required uint32 height_valid = 11;
inline bool Location_Info::has_height_valid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Location_Info::set_has_height_valid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Location_Info::clear_has_height_valid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Location_Info::clear_height_valid() {
  height_valid_ = 0u;
  clear_has_height_valid();
}
inline ::google::protobuf::uint32 Location_Info::height_valid() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Location_Info.height_valid)
  return height_valid_;
}
inline void Location_Info::set_height_valid(::google::protobuf::uint32 value) {
  set_has_height_valid();
  height_valid_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.Location_Info.height_valid)
}

// required uint32 height_data = 12;
inline bool Location_Info::has_height_data() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Location_Info::set_has_height_data() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Location_Info::clear_has_height_data() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Location_Info::clear_height_data() {
  height_data_ = 0u;
  clear_has_height_data();
}
inline ::google::protobuf::uint32 Location_Info::height_data() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Location_Info.height_data)
  return height_data_;
}
inline void Location_Info::set_height_data(::google::protobuf::uint32 value) {
  set_has_height_data();
  height_data_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.Location_Info.height_data)
}

// -------------------------------------------------------------------

// Location_InfoRsp

// required uint32 errcode = 1;
inline bool Location_InfoRsp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Location_InfoRsp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Location_InfoRsp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Location_InfoRsp::clear_errcode() {
  errcode_ = 0u;
  clear_has_errcode();
}
inline ::google::protobuf::uint32 Location_InfoRsp::errcode() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Location_InfoRsp.errcode)
  return errcode_;
}
inline void Location_InfoRsp::set_errcode(::google::protobuf::uint32 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.Location_InfoRsp.errcode)
}

// required uint32 time_stamp = 2;
inline bool Location_InfoRsp::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Location_InfoRsp::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Location_InfoRsp::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Location_InfoRsp::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 Location_InfoRsp::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Location_InfoRsp.time_stamp)
  return time_stamp_;
}
inline void Location_InfoRsp::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.Location_InfoRsp.time_stamp)
}

// -------------------------------------------------------------------

// RemoteControlResultRsp

// required uint32 control_type = 1;
inline bool RemoteControlResultRsp::has_control_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoteControlResultRsp::set_has_control_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoteControlResultRsp::clear_has_control_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoteControlResultRsp::clear_control_type() {
  control_type_ = 0u;
  clear_has_control_type();
}
inline ::google::protobuf::uint32 RemoteControlResultRsp::control_type() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RemoteControlResultRsp.control_type)
  return control_type_;
}
inline void RemoteControlResultRsp::set_control_type(::google::protobuf::uint32 value) {
  set_has_control_type();
  control_type_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.RemoteControlResultRsp.control_type)
}

// required uint32 control_value = 2;
inline bool RemoteControlResultRsp::has_control_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoteControlResultRsp::set_has_control_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoteControlResultRsp::clear_has_control_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoteControlResultRsp::clear_control_value() {
  control_value_ = 0u;
  clear_has_control_value();
}
inline ::google::protobuf::uint32 RemoteControlResultRsp::control_value() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RemoteControlResultRsp.control_value)
  return control_value_;
}
inline void RemoteControlResultRsp::set_control_value(::google::protobuf::uint32 value) {
  set_has_control_value();
  control_value_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.RemoteControlResultRsp.control_value)
}

// required uint32 serial_number = 3;
inline bool RemoteControlResultRsp::has_serial_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoteControlResultRsp::set_has_serial_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RemoteControlResultRsp::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RemoteControlResultRsp::clear_serial_number() {
  serial_number_ = 0u;
  clear_has_serial_number();
}
inline ::google::protobuf::uint32 RemoteControlResultRsp::serial_number() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RemoteControlResultRsp.serial_number)
  return serial_number_;
}
inline void RemoteControlResultRsp::set_serial_number(::google::protobuf::uint32 value) {
  set_has_serial_number();
  serial_number_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.RemoteControlResultRsp.serial_number)
}

// required uint32 control_result = 4;
inline bool RemoteControlResultRsp::has_control_result() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RemoteControlResultRsp::set_has_control_result() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RemoteControlResultRsp::clear_has_control_result() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RemoteControlResultRsp::clear_control_result() {
  control_result_ = 0u;
  clear_has_control_result();
}
inline ::google::protobuf::uint32 RemoteControlResultRsp::control_result() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RemoteControlResultRsp.control_result)
  return control_result_;
}
inline void RemoteControlResultRsp::set_control_result(::google::protobuf::uint32 value) {
  set_has_control_result();
  control_result_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.RemoteControlResultRsp.control_result)
}

// required uint32 time_stamp = 5;
inline bool RemoteControlResultRsp::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RemoteControlResultRsp::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RemoteControlResultRsp::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RemoteControlResultRsp::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 RemoteControlResultRsp::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RemoteControlResultRsp.time_stamp)
  return time_stamp_;
}
inline void RemoteControlResultRsp::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.RemoteControlResultRsp.time_stamp)
}

// -------------------------------------------------------------------

// RemoteControlReq

// required uint32 control_type = 1;
inline bool RemoteControlReq::has_control_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoteControlReq::set_has_control_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoteControlReq::clear_has_control_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoteControlReq::clear_control_type() {
  control_type_ = 0u;
  clear_has_control_type();
}
inline ::google::protobuf::uint32 RemoteControlReq::control_type() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RemoteControlReq.control_type)
  return control_type_;
}
inline void RemoteControlReq::set_control_type(::google::protobuf::uint32 value) {
  set_has_control_type();
  control_type_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.RemoteControlReq.control_type)
}

// required uint32 control_value = 2;
inline bool RemoteControlReq::has_control_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoteControlReq::set_has_control_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoteControlReq::clear_has_control_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoteControlReq::clear_control_value() {
  control_value_ = 0u;
  clear_has_control_value();
}
inline ::google::protobuf::uint32 RemoteControlReq::control_value() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RemoteControlReq.control_value)
  return control_value_;
}
inline void RemoteControlReq::set_control_value(::google::protobuf::uint32 value) {
  set_has_control_value();
  control_value_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.RemoteControlReq.control_value)
}

// required uint32 serial_number = 3;
inline bool RemoteControlReq::has_serial_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoteControlReq::set_has_serial_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RemoteControlReq::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RemoteControlReq::clear_serial_number() {
  serial_number_ = 0u;
  clear_has_serial_number();
}
inline ::google::protobuf::uint32 RemoteControlReq::serial_number() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RemoteControlReq.serial_number)
  return serial_number_;
}
inline void RemoteControlReq::set_serial_number(::google::protobuf::uint32 value) {
  set_has_serial_number();
  serial_number_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.RemoteControlReq.serial_number)
}

// required uint32 time_stamp = 4;
inline bool RemoteControlReq::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RemoteControlReq::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RemoteControlReq::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RemoteControlReq::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 RemoteControlReq::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RemoteControlReq.time_stamp)
  return time_stamp_;
}
inline void RemoteControlReq::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.RemoteControlReq.time_stamp)
}

// optional string signal_data = 5;
inline bool RemoteControlReq::has_signal_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RemoteControlReq::set_has_signal_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RemoteControlReq::clear_has_signal_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RemoteControlReq::clear_signal_data() {
  if (signal_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signal_data_->clear();
  }
  clear_has_signal_data();
}
inline const ::std::string& RemoteControlReq::signal_data() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RemoteControlReq.signal_data)
  return *signal_data_;
}
inline void RemoteControlReq::set_signal_data(const ::std::string& value) {
  set_has_signal_data();
  if (signal_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signal_data_ = new ::std::string;
  }
  signal_data_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RemoteControlReq.signal_data)
}
inline void RemoteControlReq::set_signal_data(const char* value) {
  set_has_signal_data();
  if (signal_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signal_data_ = new ::std::string;
  }
  signal_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RemoteControlReq.signal_data)
}
inline void RemoteControlReq::set_signal_data(const char* value, size_t size) {
  set_has_signal_data();
  if (signal_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signal_data_ = new ::std::string;
  }
  signal_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RemoteControlReq.signal_data)
}
inline ::std::string* RemoteControlReq::mutable_signal_data() {
  set_has_signal_data();
  if (signal_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    signal_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RemoteControlReq.signal_data)
  return signal_data_;
}
inline ::std::string* RemoteControlReq::release_signal_data() {
  clear_has_signal_data();
  if (signal_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = signal_data_;
    signal_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RemoteControlReq::set_allocated_signal_data(::std::string* signal_data) {
  if (signal_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signal_data_;
  }
  if (signal_data) {
    set_has_signal_data();
    signal_data_ = signal_data;
  } else {
    clear_has_signal_data();
    signal_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RemoteControlReq.signal_data)
}

// -------------------------------------------------------------------

// FlowCountRsp

// required uint32 dataAllowance = 1;
inline bool FlowCountRsp::has_dataallowance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlowCountRsp::set_has_dataallowance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlowCountRsp::clear_has_dataallowance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlowCountRsp::clear_dataallowance() {
  dataallowance_ = 0u;
  clear_has_dataallowance();
}
inline ::google::protobuf::uint32 FlowCountRsp::dataallowance() const {
  // @@protoc_insertion_point(field_get:zna.protocol.FlowCountRsp.dataAllowance)
  return dataallowance_;
}
inline void FlowCountRsp::set_dataallowance(::google::protobuf::uint32 value) {
  set_has_dataallowance();
  dataallowance_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.FlowCountRsp.dataAllowance)
}

// required uint32 dataUsage = 2;
inline bool FlowCountRsp::has_datausage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlowCountRsp::set_has_datausage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FlowCountRsp::clear_has_datausage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FlowCountRsp::clear_datausage() {
  datausage_ = 0u;
  clear_has_datausage();
}
inline ::google::protobuf::uint32 FlowCountRsp::datausage() const {
  // @@protoc_insertion_point(field_get:zna.protocol.FlowCountRsp.dataUsage)
  return datausage_;
}
inline void FlowCountRsp::set_datausage(::google::protobuf::uint32 value) {
  set_has_datausage();
  datausage_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.FlowCountRsp.dataUsage)
}

// required uint32 dataAvailable = 3;
inline bool FlowCountRsp::has_dataavailable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FlowCountRsp::set_has_dataavailable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FlowCountRsp::clear_has_dataavailable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FlowCountRsp::clear_dataavailable() {
  dataavailable_ = 0u;
  clear_has_dataavailable();
}
inline ::google::protobuf::uint32 FlowCountRsp::dataavailable() const {
  // @@protoc_insertion_point(field_get:zna.protocol.FlowCountRsp.dataAvailable)
  return dataavailable_;
}
inline void FlowCountRsp::set_dataavailable(::google::protobuf::uint32 value) {
  set_has_dataavailable();
  dataavailable_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.FlowCountRsp.dataAvailable)
}

// -------------------------------------------------------------------

// FlowCountLimitReq

// required uint32 limitVal = 1;
inline bool FlowCountLimitReq::has_limitval() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlowCountLimitReq::set_has_limitval() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlowCountLimitReq::clear_has_limitval() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlowCountLimitReq::clear_limitval() {
  limitval_ = 0u;
  clear_has_limitval();
}
inline ::google::protobuf::uint32 FlowCountLimitReq::limitval() const {
  // @@protoc_insertion_point(field_get:zna.protocol.FlowCountLimitReq.limitVal)
  return limitval_;
}
inline void FlowCountLimitReq::set_limitval(::google::protobuf::uint32 value) {
  set_has_limitval();
  limitval_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.FlowCountLimitReq.limitVal)
}

// -------------------------------------------------------------------

// OtaUpgradeReq

// repeated .zna.protocol.UpgradeInfo upgradeinfo = 1;
inline int OtaUpgradeReq::upgradeinfo_size() const {
  return upgradeinfo_.size();
}
inline void OtaUpgradeReq::clear_upgradeinfo() {
  upgradeinfo_.Clear();
}
inline const ::zna::protocol::UpgradeInfo& OtaUpgradeReq::upgradeinfo(int index) const {
  // @@protoc_insertion_point(field_get:zna.protocol.OtaUpgradeReq.upgradeinfo)
  return upgradeinfo_.Get(index);
}
inline ::zna::protocol::UpgradeInfo* OtaUpgradeReq::mutable_upgradeinfo(int index) {
  // @@protoc_insertion_point(field_mutable:zna.protocol.OtaUpgradeReq.upgradeinfo)
  return upgradeinfo_.Mutable(index);
}
inline ::zna::protocol::UpgradeInfo* OtaUpgradeReq::add_upgradeinfo() {
  // @@protoc_insertion_point(field_add:zna.protocol.OtaUpgradeReq.upgradeinfo)
  return upgradeinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zna::protocol::UpgradeInfo >&
OtaUpgradeReq::upgradeinfo() const {
  // @@protoc_insertion_point(field_list:zna.protocol.OtaUpgradeReq.upgradeinfo)
  return upgradeinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::zna::protocol::UpgradeInfo >*
OtaUpgradeReq::mutable_upgradeinfo() {
  // @@protoc_insertion_point(field_mutable_list:zna.protocol.OtaUpgradeReq.upgradeinfo)
  return &upgradeinfo_;
}

// required uint32 serial_number = 2;
inline bool OtaUpgradeReq::has_serial_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OtaUpgradeReq::set_has_serial_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OtaUpgradeReq::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OtaUpgradeReq::clear_serial_number() {
  serial_number_ = 0u;
  clear_has_serial_number();
}
inline ::google::protobuf::uint32 OtaUpgradeReq::serial_number() const {
  // @@protoc_insertion_point(field_get:zna.protocol.OtaUpgradeReq.serial_number)
  return serial_number_;
}
inline void OtaUpgradeReq::set_serial_number(::google::protobuf::uint32 value) {
  set_has_serial_number();
  serial_number_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.OtaUpgradeReq.serial_number)
}

// required uint32 time_stamp = 3;
inline bool OtaUpgradeReq::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OtaUpgradeReq::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OtaUpgradeReq::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OtaUpgradeReq::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 OtaUpgradeReq::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.OtaUpgradeReq.time_stamp)
  return time_stamp_;
}
inline void OtaUpgradeReq::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.OtaUpgradeReq.time_stamp)
}

// -------------------------------------------------------------------

// OtaUpgradeRsp

// required uint32 errcode = 1;
inline bool OtaUpgradeRsp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OtaUpgradeRsp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OtaUpgradeRsp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OtaUpgradeRsp::clear_errcode() {
  errcode_ = 0u;
  clear_has_errcode();
}
inline ::google::protobuf::uint32 OtaUpgradeRsp::errcode() const {
  // @@protoc_insertion_point(field_get:zna.protocol.OtaUpgradeRsp.errcode)
  return errcode_;
}
inline void OtaUpgradeRsp::set_errcode(::google::protobuf::uint32 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.OtaUpgradeRsp.errcode)
}

// required uint32 time_stamp = 2;
inline bool OtaUpgradeRsp::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OtaUpgradeRsp::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OtaUpgradeRsp::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OtaUpgradeRsp::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 OtaUpgradeRsp::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.OtaUpgradeRsp.time_stamp)
  return time_stamp_;
}
inline void OtaUpgradeRsp::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.OtaUpgradeRsp.time_stamp)
}

// required uint32 serial_number = 3;
inline bool OtaUpgradeRsp::has_serial_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OtaUpgradeRsp::set_has_serial_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OtaUpgradeRsp::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OtaUpgradeRsp::clear_serial_number() {
  serial_number_ = 0u;
  clear_has_serial_number();
}
inline ::google::protobuf::uint32 OtaUpgradeRsp::serial_number() const {
  // @@protoc_insertion_point(field_get:zna.protocol.OtaUpgradeRsp.serial_number)
  return serial_number_;
}
inline void OtaUpgradeRsp::set_serial_number(::google::protobuf::uint32 value) {
  set_has_serial_number();
  serial_number_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.OtaUpgradeRsp.serial_number)
}

// -------------------------------------------------------------------

// CancelOtaUpgradeRsp

// required uint32 errcode = 1;
inline bool CancelOtaUpgradeRsp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CancelOtaUpgradeRsp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CancelOtaUpgradeRsp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CancelOtaUpgradeRsp::clear_errcode() {
  errcode_ = 0u;
  clear_has_errcode();
}
inline ::google::protobuf::uint32 CancelOtaUpgradeRsp::errcode() const {
  // @@protoc_insertion_point(field_get:zna.protocol.CancelOtaUpgradeRsp.errcode)
  return errcode_;
}
inline void CancelOtaUpgradeRsp::set_errcode(::google::protobuf::uint32 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.CancelOtaUpgradeRsp.errcode)
}

// -------------------------------------------------------------------

// OtaUpgradeProgressReq

// required .zna.protocol.UpgradeProgressCodeType UpgradeProgressCode = 1;
inline bool OtaUpgradeProgressReq::has_upgradeprogresscode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OtaUpgradeProgressReq::set_has_upgradeprogresscode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OtaUpgradeProgressReq::clear_has_upgradeprogresscode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OtaUpgradeProgressReq::clear_upgradeprogresscode() {
  upgradeprogresscode_ = 0;
  clear_has_upgradeprogresscode();
}
inline ::zna::protocol::UpgradeProgressCodeType OtaUpgradeProgressReq::upgradeprogresscode() const {
  // @@protoc_insertion_point(field_get:zna.protocol.OtaUpgradeProgressReq.UpgradeProgressCode)
  return static_cast< ::zna::protocol::UpgradeProgressCodeType >(upgradeprogresscode_);
}
inline void OtaUpgradeProgressReq::set_upgradeprogresscode(::zna::protocol::UpgradeProgressCodeType value) {
  assert(::zna::protocol::UpgradeProgressCodeType_IsValid(value));
  set_has_upgradeprogresscode();
  upgradeprogresscode_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.OtaUpgradeProgressReq.UpgradeProgressCode)
}

// optional uint32 errcode = 2;
inline bool OtaUpgradeProgressReq::has_errcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OtaUpgradeProgressReq::set_has_errcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OtaUpgradeProgressReq::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OtaUpgradeProgressReq::clear_errcode() {
  errcode_ = 0u;
  clear_has_errcode();
}
inline ::google::protobuf::uint32 OtaUpgradeProgressReq::errcode() const {
  // @@protoc_insertion_point(field_get:zna.protocol.OtaUpgradeProgressReq.errcode)
  return errcode_;
}
inline void OtaUpgradeProgressReq::set_errcode(::google::protobuf::uint32 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.OtaUpgradeProgressReq.errcode)
}

// -------------------------------------------------------------------

// CertCom

// required uint32 serial_number = 1;
inline bool CertCom::has_serial_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CertCom::set_has_serial_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CertCom::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CertCom::clear_serial_number() {
  serial_number_ = 0u;
  clear_has_serial_number();
}
inline ::google::protobuf::uint32 CertCom::serial_number() const {
  // @@protoc_insertion_point(field_get:zna.protocol.CertCom.serial_number)
  return serial_number_;
}
inline void CertCom::set_serial_number(::google::protobuf::uint32 value) {
  set_has_serial_number();
  serial_number_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.CertCom.serial_number)
}

// required uint32 cur_cert_id = 2;
inline bool CertCom::has_cur_cert_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CertCom::set_has_cur_cert_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CertCom::clear_has_cur_cert_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CertCom::clear_cur_cert_id() {
  cur_cert_id_ = 0u;
  clear_has_cur_cert_id();
}
inline ::google::protobuf::uint32 CertCom::cur_cert_id() const {
  // @@protoc_insertion_point(field_get:zna.protocol.CertCom.cur_cert_id)
  return cur_cert_id_;
}
inline void CertCom::set_cur_cert_id(::google::protobuf::uint32 value) {
  set_has_cur_cert_id();
  cur_cert_id_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.CertCom.cur_cert_id)
}

// required uint32 data_status = 3;
inline bool CertCom::has_data_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CertCom::set_has_data_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CertCom::clear_has_data_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CertCom::clear_data_status() {
  data_status_ = 0u;
  clear_has_data_status();
}
inline ::google::protobuf::uint32 CertCom::data_status() const {
  // @@protoc_insertion_point(field_get:zna.protocol.CertCom.data_status)
  return data_status_;
}
inline void CertCom::set_data_status(::google::protobuf::uint32 value) {
  set_has_data_status();
  data_status_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.CertCom.data_status)
}

// required uint32 cmd_id = 4;
inline bool CertCom::has_cmd_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CertCom::set_has_cmd_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CertCom::clear_has_cmd_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CertCom::clear_cmd_id() {
  cmd_id_ = 0u;
  clear_has_cmd_id();
}
inline ::google::protobuf::uint32 CertCom::cmd_id() const {
  // @@protoc_insertion_point(field_get:zna.protocol.CertCom.cmd_id)
  return cmd_id_;
}
inline void CertCom::set_cmd_id(::google::protobuf::uint32 value) {
  set_has_cmd_id();
  cmd_id_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.CertCom.cmd_id)
}

// required string dcm_no = 5;
inline bool CertCom::has_dcm_no() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CertCom::set_has_dcm_no() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CertCom::clear_has_dcm_no() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CertCom::clear_dcm_no() {
  if (dcm_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dcm_no_->clear();
  }
  clear_has_dcm_no();
}
inline const ::std::string& CertCom::dcm_no() const {
  // @@protoc_insertion_point(field_get:zna.protocol.CertCom.dcm_no)
  return *dcm_no_;
}
inline void CertCom::set_dcm_no(const ::std::string& value) {
  set_has_dcm_no();
  if (dcm_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dcm_no_ = new ::std::string;
  }
  dcm_no_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.CertCom.dcm_no)
}
inline void CertCom::set_dcm_no(const char* value) {
  set_has_dcm_no();
  if (dcm_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dcm_no_ = new ::std::string;
  }
  dcm_no_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.CertCom.dcm_no)
}
inline void CertCom::set_dcm_no(const char* value, size_t size) {
  set_has_dcm_no();
  if (dcm_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dcm_no_ = new ::std::string;
  }
  dcm_no_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.CertCom.dcm_no)
}
inline ::std::string* CertCom::mutable_dcm_no() {
  set_has_dcm_no();
  if (dcm_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dcm_no_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.CertCom.dcm_no)
  return dcm_no_;
}
inline ::std::string* CertCom::release_dcm_no() {
  clear_has_dcm_no();
  if (dcm_no_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dcm_no_;
    dcm_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CertCom::set_allocated_dcm_no(::std::string* dcm_no) {
  if (dcm_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dcm_no_;
  }
  if (dcm_no) {
    set_has_dcm_no();
    dcm_no_ = dcm_no;
  } else {
    clear_has_dcm_no();
    dcm_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.CertCom.dcm_no)
}

// optional uint32 errcode = 6;
inline bool CertCom::has_errcode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CertCom::set_has_errcode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CertCom::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CertCom::clear_errcode() {
  errcode_ = 0u;
  clear_has_errcode();
}
inline ::google::protobuf::uint32 CertCom::errcode() const {
  // @@protoc_insertion_point(field_get:zna.protocol.CertCom.errcode)
  return errcode_;
}
inline void CertCom::set_errcode(::google::protobuf::uint32 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.CertCom.errcode)
}

// required bytes data_info = 7;
inline bool CertCom::has_data_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CertCom::set_has_data_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CertCom::clear_has_data_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CertCom::clear_data_info() {
  if (data_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_info_->clear();
  }
  clear_has_data_info();
}
inline const ::std::string& CertCom::data_info() const {
  // @@protoc_insertion_point(field_get:zna.protocol.CertCom.data_info)
  return *data_info_;
}
inline void CertCom::set_data_info(const ::std::string& value) {
  set_has_data_info();
  if (data_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_info_ = new ::std::string;
  }
  data_info_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.CertCom.data_info)
}
inline void CertCom::set_data_info(const char* value) {
  set_has_data_info();
  if (data_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_info_ = new ::std::string;
  }
  data_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.CertCom.data_info)
}
inline void CertCom::set_data_info(const void* value, size_t size) {
  set_has_data_info();
  if (data_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_info_ = new ::std::string;
  }
  data_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.CertCom.data_info)
}
inline ::std::string* CertCom::mutable_data_info() {
  set_has_data_info();
  if (data_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.CertCom.data_info)
  return data_info_;
}
inline ::std::string* CertCom::release_data_info() {
  clear_has_data_info();
  if (data_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_info_;
    data_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CertCom::set_allocated_data_info(::std::string* data_info) {
  if (data_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_info_;
  }
  if (data_info) {
    set_has_data_info();
    data_info_ = data_info;
  } else {
    clear_has_data_info();
    data_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.CertCom.data_info)
}

// optional bytes sign_data = 8;
inline bool CertCom::has_sign_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CertCom::set_has_sign_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CertCom::clear_has_sign_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CertCom::clear_sign_data() {
  if (sign_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_data_->clear();
  }
  clear_has_sign_data();
}
inline const ::std::string& CertCom::sign_data() const {
  // @@protoc_insertion_point(field_get:zna.protocol.CertCom.sign_data)
  return *sign_data_;
}
inline void CertCom::set_sign_data(const ::std::string& value) {
  set_has_sign_data();
  if (sign_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_data_ = new ::std::string;
  }
  sign_data_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.CertCom.sign_data)
}
inline void CertCom::set_sign_data(const char* value) {
  set_has_sign_data();
  if (sign_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_data_ = new ::std::string;
  }
  sign_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.CertCom.sign_data)
}
inline void CertCom::set_sign_data(const void* value, size_t size) {
  set_has_sign_data();
  if (sign_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_data_ = new ::std::string;
  }
  sign_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.CertCom.sign_data)
}
inline ::std::string* CertCom::mutable_sign_data() {
  set_has_sign_data();
  if (sign_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sign_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.CertCom.sign_data)
  return sign_data_;
}
inline ::std::string* CertCom::release_sign_data() {
  clear_has_sign_data();
  if (sign_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sign_data_;
    sign_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CertCom::set_allocated_sign_data(::std::string* sign_data) {
  if (sign_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sign_data_;
  }
  if (sign_data) {
    set_has_sign_data();
    sign_data_ = sign_data;
  } else {
    clear_has_sign_data();
    sign_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.CertCom.sign_data)
}

// -------------------------------------------------------------------

// TCUCertApply_Req

// required uint32 time_stamp = 1;
inline bool TCUCertApply_Req::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TCUCertApply_Req::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TCUCertApply_Req::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TCUCertApply_Req::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 TCUCertApply_Req::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.TCUCertApply_Req.time_stamp)
  return time_stamp_;
}
inline void TCUCertApply_Req::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.TCUCertApply_Req.time_stamp)
}

// required string vin = 2;
inline bool TCUCertApply_Req::has_vin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TCUCertApply_Req::set_has_vin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TCUCertApply_Req::clear_has_vin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TCUCertApply_Req::clear_vin() {
  if (vin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vin_->clear();
  }
  clear_has_vin();
}
inline const ::std::string& TCUCertApply_Req::vin() const {
  // @@protoc_insertion_point(field_get:zna.protocol.TCUCertApply_Req.vin)
  return *vin_;
}
inline void TCUCertApply_Req::set_vin(const ::std::string& value) {
  set_has_vin();
  if (vin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vin_ = new ::std::string;
  }
  vin_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.TCUCertApply_Req.vin)
}
inline void TCUCertApply_Req::set_vin(const char* value) {
  set_has_vin();
  if (vin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vin_ = new ::std::string;
  }
  vin_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.TCUCertApply_Req.vin)
}
inline void TCUCertApply_Req::set_vin(const char* value, size_t size) {
  set_has_vin();
  if (vin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vin_ = new ::std::string;
  }
  vin_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.TCUCertApply_Req.vin)
}
inline ::std::string* TCUCertApply_Req::mutable_vin() {
  set_has_vin();
  if (vin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vin_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.TCUCertApply_Req.vin)
  return vin_;
}
inline ::std::string* TCUCertApply_Req::release_vin() {
  clear_has_vin();
  if (vin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vin_;
    vin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TCUCertApply_Req::set_allocated_vin(::std::string* vin) {
  if (vin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vin_;
  }
  if (vin) {
    set_has_vin();
    vin_ = vin;
  } else {
    clear_has_vin();
    vin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.TCUCertApply_Req.vin)
}

// required uint32 cert_status = 3;
inline bool TCUCertApply_Req::has_cert_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TCUCertApply_Req::set_has_cert_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TCUCertApply_Req::clear_has_cert_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TCUCertApply_Req::clear_cert_status() {
  cert_status_ = 0u;
  clear_has_cert_status();
}
inline ::google::protobuf::uint32 TCUCertApply_Req::cert_status() const {
  // @@protoc_insertion_point(field_get:zna.protocol.TCUCertApply_Req.cert_status)
  return cert_status_;
}
inline void TCUCertApply_Req::set_cert_status(::google::protobuf::uint32 value) {
  set_has_cert_status();
  cert_status_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.TCUCertApply_Req.cert_status)
}

// required uint32 duration = 4;
inline bool TCUCertApply_Req::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TCUCertApply_Req::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TCUCertApply_Req::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TCUCertApply_Req::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 TCUCertApply_Req::duration() const {
  // @@protoc_insertion_point(field_get:zna.protocol.TCUCertApply_Req.duration)
  return duration_;
}
inline void TCUCertApply_Req::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.TCUCertApply_Req.duration)
}

// required bytes p10_csr = 5;
inline bool TCUCertApply_Req::has_p10_csr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TCUCertApply_Req::set_has_p10_csr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TCUCertApply_Req::clear_has_p10_csr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TCUCertApply_Req::clear_p10_csr() {
  if (p10_csr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    p10_csr_->clear();
  }
  clear_has_p10_csr();
}
inline const ::std::string& TCUCertApply_Req::p10_csr() const {
  // @@protoc_insertion_point(field_get:zna.protocol.TCUCertApply_Req.p10_csr)
  return *p10_csr_;
}
inline void TCUCertApply_Req::set_p10_csr(const ::std::string& value) {
  set_has_p10_csr();
  if (p10_csr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    p10_csr_ = new ::std::string;
  }
  p10_csr_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.TCUCertApply_Req.p10_csr)
}
inline void TCUCertApply_Req::set_p10_csr(const char* value) {
  set_has_p10_csr();
  if (p10_csr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    p10_csr_ = new ::std::string;
  }
  p10_csr_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.TCUCertApply_Req.p10_csr)
}
inline void TCUCertApply_Req::set_p10_csr(const void* value, size_t size) {
  set_has_p10_csr();
  if (p10_csr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    p10_csr_ = new ::std::string;
  }
  p10_csr_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.TCUCertApply_Req.p10_csr)
}
inline ::std::string* TCUCertApply_Req::mutable_p10_csr() {
  set_has_p10_csr();
  if (p10_csr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    p10_csr_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.TCUCertApply_Req.p10_csr)
  return p10_csr_;
}
inline ::std::string* TCUCertApply_Req::release_p10_csr() {
  clear_has_p10_csr();
  if (p10_csr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = p10_csr_;
    p10_csr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TCUCertApply_Req::set_allocated_p10_csr(::std::string* p10_csr) {
  if (p10_csr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete p10_csr_;
  }
  if (p10_csr) {
    set_has_p10_csr();
    p10_csr_ = p10_csr;
  } else {
    clear_has_p10_csr();
    p10_csr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.TCUCertApply_Req.p10_csr)
}

// optional bytes cst_sign_data = 6;
inline bool TCUCertApply_Req::has_cst_sign_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TCUCertApply_Req::set_has_cst_sign_data() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TCUCertApply_Req::clear_has_cst_sign_data() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TCUCertApply_Req::clear_cst_sign_data() {
  if (cst_sign_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cst_sign_data_->clear();
  }
  clear_has_cst_sign_data();
}
inline const ::std::string& TCUCertApply_Req::cst_sign_data() const {
  // @@protoc_insertion_point(field_get:zna.protocol.TCUCertApply_Req.cst_sign_data)
  return *cst_sign_data_;
}
inline void TCUCertApply_Req::set_cst_sign_data(const ::std::string& value) {
  set_has_cst_sign_data();
  if (cst_sign_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cst_sign_data_ = new ::std::string;
  }
  cst_sign_data_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.TCUCertApply_Req.cst_sign_data)
}
inline void TCUCertApply_Req::set_cst_sign_data(const char* value) {
  set_has_cst_sign_data();
  if (cst_sign_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cst_sign_data_ = new ::std::string;
  }
  cst_sign_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.TCUCertApply_Req.cst_sign_data)
}
inline void TCUCertApply_Req::set_cst_sign_data(const void* value, size_t size) {
  set_has_cst_sign_data();
  if (cst_sign_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cst_sign_data_ = new ::std::string;
  }
  cst_sign_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.TCUCertApply_Req.cst_sign_data)
}
inline ::std::string* TCUCertApply_Req::mutable_cst_sign_data() {
  set_has_cst_sign_data();
  if (cst_sign_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cst_sign_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.TCUCertApply_Req.cst_sign_data)
  return cst_sign_data_;
}
inline ::std::string* TCUCertApply_Req::release_cst_sign_data() {
  clear_has_cst_sign_data();
  if (cst_sign_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cst_sign_data_;
    cst_sign_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TCUCertApply_Req::set_allocated_cst_sign_data(::std::string* cst_sign_data) {
  if (cst_sign_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cst_sign_data_;
  }
  if (cst_sign_data) {
    set_has_cst_sign_data();
    cst_sign_data_ = cst_sign_data;
  } else {
    clear_has_cst_sign_data();
    cst_sign_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.TCUCertApply_Req.cst_sign_data)
}

// optional string cert_format = 7;
inline bool TCUCertApply_Req::has_cert_format() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TCUCertApply_Req::set_has_cert_format() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TCUCertApply_Req::clear_has_cert_format() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TCUCertApply_Req::clear_cert_format() {
  if (cert_format_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cert_format_->clear();
  }
  clear_has_cert_format();
}
inline const ::std::string& TCUCertApply_Req::cert_format() const {
  // @@protoc_insertion_point(field_get:zna.protocol.TCUCertApply_Req.cert_format)
  return *cert_format_;
}
inline void TCUCertApply_Req::set_cert_format(const ::std::string& value) {
  set_has_cert_format();
  if (cert_format_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cert_format_ = new ::std::string;
  }
  cert_format_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.TCUCertApply_Req.cert_format)
}
inline void TCUCertApply_Req::set_cert_format(const char* value) {
  set_has_cert_format();
  if (cert_format_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cert_format_ = new ::std::string;
  }
  cert_format_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.TCUCertApply_Req.cert_format)
}
inline void TCUCertApply_Req::set_cert_format(const char* value, size_t size) {
  set_has_cert_format();
  if (cert_format_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cert_format_ = new ::std::string;
  }
  cert_format_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.TCUCertApply_Req.cert_format)
}
inline ::std::string* TCUCertApply_Req::mutable_cert_format() {
  set_has_cert_format();
  if (cert_format_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cert_format_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.TCUCertApply_Req.cert_format)
  return cert_format_;
}
inline ::std::string* TCUCertApply_Req::release_cert_format() {
  clear_has_cert_format();
  if (cert_format_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cert_format_;
    cert_format_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TCUCertApply_Req::set_allocated_cert_format(::std::string* cert_format) {
  if (cert_format_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cert_format_;
  }
  if (cert_format) {
    set_has_cert_format();
    cert_format_ = cert_format;
  } else {
    clear_has_cert_format();
    cert_format_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.TCUCertApply_Req.cert_format)
}

// optional uint32 sign_type = 8;
inline bool TCUCertApply_Req::has_sign_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TCUCertApply_Req::set_has_sign_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TCUCertApply_Req::clear_has_sign_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TCUCertApply_Req::clear_sign_type() {
  sign_type_ = 0u;
  clear_has_sign_type();
}
inline ::google::protobuf::uint32 TCUCertApply_Req::sign_type() const {
  // @@protoc_insertion_point(field_get:zna.protocol.TCUCertApply_Req.sign_type)
  return sign_type_;
}
inline void TCUCertApply_Req::set_sign_type(::google::protobuf::uint32 value) {
  set_has_sign_type();
  sign_type_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.TCUCertApply_Req.sign_type)
}

// -------------------------------------------------------------------

// TCUCertApply_Rsp

// required uint32 time_stamp = 1;
inline bool TCUCertApply_Rsp::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TCUCertApply_Rsp::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TCUCertApply_Rsp::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TCUCertApply_Rsp::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 TCUCertApply_Rsp::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.TCUCertApply_Rsp.time_stamp)
  return time_stamp_;
}
inline void TCUCertApply_Rsp::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.TCUCertApply_Rsp.time_stamp)
}

// optional uint32 recv_status = 2;
inline bool TCUCertApply_Rsp::has_recv_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TCUCertApply_Rsp::set_has_recv_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TCUCertApply_Rsp::clear_has_recv_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TCUCertApply_Rsp::clear_recv_status() {
  recv_status_ = 0u;
  clear_has_recv_status();
}
inline ::google::protobuf::uint32 TCUCertApply_Rsp::recv_status() const {
  // @@protoc_insertion_point(field_get:zna.protocol.TCUCertApply_Rsp.recv_status)
  return recv_status_;
}
inline void TCUCertApply_Rsp::set_recv_status(::google::protobuf::uint32 value) {
  set_has_recv_status();
  recv_status_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.TCUCertApply_Rsp.recv_status)
}

// -------------------------------------------------------------------

// CertIssue_Req

// required uint32 time_stamp = 1;
inline bool CertIssue_Req::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CertIssue_Req::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CertIssue_Req::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CertIssue_Req::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 CertIssue_Req::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.CertIssue_Req.time_stamp)
  return time_stamp_;
}
inline void CertIssue_Req::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.CertIssue_Req.time_stamp)
}

// required uint32 cert_apply_status = 2;
inline bool CertIssue_Req::has_cert_apply_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CertIssue_Req::set_has_cert_apply_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CertIssue_Req::clear_has_cert_apply_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CertIssue_Req::clear_cert_apply_status() {
  cert_apply_status_ = 0u;
  clear_has_cert_apply_status();
}
inline ::google::protobuf::uint32 CertIssue_Req::cert_apply_status() const {
  // @@protoc_insertion_point(field_get:zna.protocol.CertIssue_Req.cert_apply_status)
  return cert_apply_status_;
}
inline void CertIssue_Req::set_cert_apply_status(::google::protobuf::uint32 value) {
  set_has_cert_apply_status();
  cert_apply_status_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.CertIssue_Req.cert_apply_status)
}

// optional uint32 apply_cert_id = 3;
inline bool CertIssue_Req::has_apply_cert_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CertIssue_Req::set_has_apply_cert_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CertIssue_Req::clear_has_apply_cert_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CertIssue_Req::clear_apply_cert_id() {
  apply_cert_id_ = 0u;
  clear_has_apply_cert_id();
}
inline ::google::protobuf::uint32 CertIssue_Req::apply_cert_id() const {
  // @@protoc_insertion_point(field_get:zna.protocol.CertIssue_Req.apply_cert_id)
  return apply_cert_id_;
}
inline void CertIssue_Req::set_apply_cert_id(::google::protobuf::uint32 value) {
  set_has_apply_cert_id();
  apply_cert_id_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.CertIssue_Req.apply_cert_id)
}

// optional bytes cert_data = 4;
inline bool CertIssue_Req::has_cert_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CertIssue_Req::set_has_cert_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CertIssue_Req::clear_has_cert_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CertIssue_Req::clear_cert_data() {
  if (cert_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cert_data_->clear();
  }
  clear_has_cert_data();
}
inline const ::std::string& CertIssue_Req::cert_data() const {
  // @@protoc_insertion_point(field_get:zna.protocol.CertIssue_Req.cert_data)
  return *cert_data_;
}
inline void CertIssue_Req::set_cert_data(const ::std::string& value) {
  set_has_cert_data();
  if (cert_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cert_data_ = new ::std::string;
  }
  cert_data_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.CertIssue_Req.cert_data)
}
inline void CertIssue_Req::set_cert_data(const char* value) {
  set_has_cert_data();
  if (cert_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cert_data_ = new ::std::string;
  }
  cert_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.CertIssue_Req.cert_data)
}
inline void CertIssue_Req::set_cert_data(const void* value, size_t size) {
  set_has_cert_data();
  if (cert_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cert_data_ = new ::std::string;
  }
  cert_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.CertIssue_Req.cert_data)
}
inline ::std::string* CertIssue_Req::mutable_cert_data() {
  set_has_cert_data();
  if (cert_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    cert_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.CertIssue_Req.cert_data)
  return cert_data_;
}
inline ::std::string* CertIssue_Req::release_cert_data() {
  clear_has_cert_data();
  if (cert_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = cert_data_;
    cert_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CertIssue_Req::set_allocated_cert_data(::std::string* cert_data) {
  if (cert_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cert_data_;
  }
  if (cert_data) {
    set_has_cert_data();
    cert_data_ = cert_data;
  } else {
    clear_has_cert_data();
    cert_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.CertIssue_Req.cert_data)
}

// -------------------------------------------------------------------

// CertIssue_Rsp

// required uint32 time_stamp = 1;
inline bool CertIssue_Rsp::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CertIssue_Rsp::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CertIssue_Rsp::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CertIssue_Rsp::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 CertIssue_Rsp::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.CertIssue_Rsp.time_stamp)
  return time_stamp_;
}
inline void CertIssue_Rsp::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.CertIssue_Rsp.time_stamp)
}

// required uint32 cert_recv_status = 2;
inline bool CertIssue_Rsp::has_cert_recv_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CertIssue_Rsp::set_has_cert_recv_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CertIssue_Rsp::clear_has_cert_recv_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CertIssue_Rsp::clear_cert_recv_status() {
  cert_recv_status_ = 0u;
  clear_has_cert_recv_status();
}
inline ::google::protobuf::uint32 CertIssue_Rsp::cert_recv_status() const {
  // @@protoc_insertion_point(field_get:zna.protocol.CertIssue_Rsp.cert_recv_status)
  return cert_recv_status_;
}
inline void CertIssue_Rsp::set_cert_recv_status(::google::protobuf::uint32 value) {
  set_has_cert_recv_status();
  cert_recv_status_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.CertIssue_Rsp.cert_recv_status)
}

// optional uint32 apply_cert_id = 3;
inline bool CertIssue_Rsp::has_apply_cert_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CertIssue_Rsp::set_has_apply_cert_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CertIssue_Rsp::clear_has_apply_cert_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CertIssue_Rsp::clear_apply_cert_id() {
  apply_cert_id_ = 0u;
  clear_has_apply_cert_id();
}
inline ::google::protobuf::uint32 CertIssue_Rsp::apply_cert_id() const {
  // @@protoc_insertion_point(field_get:zna.protocol.CertIssue_Rsp.apply_cert_id)
  return apply_cert_id_;
}
inline void CertIssue_Rsp::set_apply_cert_id(::google::protobuf::uint32 value) {
  set_has_apply_cert_id();
  apply_cert_id_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.CertIssue_Rsp.apply_cert_id)
}

// -------------------------------------------------------------------

// RSALoginReq

// required string tcu_device_sn = 1;
inline bool RSALoginReq::has_tcu_device_sn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RSALoginReq::set_has_tcu_device_sn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RSALoginReq::clear_has_tcu_device_sn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RSALoginReq::clear_tcu_device_sn() {
  if (tcu_device_sn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tcu_device_sn_->clear();
  }
  clear_has_tcu_device_sn();
}
inline const ::std::string& RSALoginReq::tcu_device_sn() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RSALoginReq.tcu_device_sn)
  return *tcu_device_sn_;
}
inline void RSALoginReq::set_tcu_device_sn(const ::std::string& value) {
  set_has_tcu_device_sn();
  if (tcu_device_sn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tcu_device_sn_ = new ::std::string;
  }
  tcu_device_sn_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RSALoginReq.tcu_device_sn)
}
inline void RSALoginReq::set_tcu_device_sn(const char* value) {
  set_has_tcu_device_sn();
  if (tcu_device_sn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tcu_device_sn_ = new ::std::string;
  }
  tcu_device_sn_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RSALoginReq.tcu_device_sn)
}
inline void RSALoginReq::set_tcu_device_sn(const char* value, size_t size) {
  set_has_tcu_device_sn();
  if (tcu_device_sn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tcu_device_sn_ = new ::std::string;
  }
  tcu_device_sn_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RSALoginReq.tcu_device_sn)
}
inline ::std::string* RSALoginReq::mutable_tcu_device_sn() {
  set_has_tcu_device_sn();
  if (tcu_device_sn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tcu_device_sn_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RSALoginReq.tcu_device_sn)
  return tcu_device_sn_;
}
inline ::std::string* RSALoginReq::release_tcu_device_sn() {
  clear_has_tcu_device_sn();
  if (tcu_device_sn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tcu_device_sn_;
    tcu_device_sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RSALoginReq::set_allocated_tcu_device_sn(::std::string* tcu_device_sn) {
  if (tcu_device_sn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tcu_device_sn_;
  }
  if (tcu_device_sn) {
    set_has_tcu_device_sn();
    tcu_device_sn_ = tcu_device_sn;
  } else {
    clear_has_tcu_device_sn();
    tcu_device_sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RSALoginReq.tcu_device_sn)
}

// required string imsi = 2;
inline bool RSALoginReq::has_imsi() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RSALoginReq::set_has_imsi() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RSALoginReq::clear_has_imsi() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RSALoginReq::clear_imsi() {
  if (imsi_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imsi_->clear();
  }
  clear_has_imsi();
}
inline const ::std::string& RSALoginReq::imsi() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RSALoginReq.imsi)
  return *imsi_;
}
inline void RSALoginReq::set_imsi(const ::std::string& value) {
  set_has_imsi();
  if (imsi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imsi_ = new ::std::string;
  }
  imsi_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RSALoginReq.imsi)
}
inline void RSALoginReq::set_imsi(const char* value) {
  set_has_imsi();
  if (imsi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imsi_ = new ::std::string;
  }
  imsi_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RSALoginReq.imsi)
}
inline void RSALoginReq::set_imsi(const char* value, size_t size) {
  set_has_imsi();
  if (imsi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imsi_ = new ::std::string;
  }
  imsi_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RSALoginReq.imsi)
}
inline ::std::string* RSALoginReq::mutable_imsi() {
  set_has_imsi();
  if (imsi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imsi_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RSALoginReq.imsi)
  return imsi_;
}
inline ::std::string* RSALoginReq::release_imsi() {
  clear_has_imsi();
  if (imsi_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = imsi_;
    imsi_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RSALoginReq::set_allocated_imsi(::std::string* imsi) {
  if (imsi_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imsi_;
  }
  if (imsi) {
    set_has_imsi();
    imsi_ = imsi;
  } else {
    clear_has_imsi();
    imsi_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RSALoginReq.imsi)
}

// required string imei = 3;
inline bool RSALoginReq::has_imei() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RSALoginReq::set_has_imei() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RSALoginReq::clear_has_imei() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RSALoginReq::clear_imei() {
  if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_->clear();
  }
  clear_has_imei();
}
inline const ::std::string& RSALoginReq::imei() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RSALoginReq.imei)
  return *imei_;
}
inline void RSALoginReq::set_imei(const ::std::string& value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RSALoginReq.imei)
}
inline void RSALoginReq::set_imei(const char* value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RSALoginReq.imei)
}
inline void RSALoginReq::set_imei(const char* value, size_t size) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  imei_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RSALoginReq.imei)
}
inline ::std::string* RSALoginReq::mutable_imei() {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    imei_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RSALoginReq.imei)
  return imei_;
}
inline ::std::string* RSALoginReq::release_imei() {
  clear_has_imei();
  if (imei_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = imei_;
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RSALoginReq::set_allocated_imei(::std::string* imei) {
  if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imei_;
  }
  if (imei) {
    set_has_imei();
    imei_ = imei;
  } else {
    clear_has_imei();
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RSALoginReq.imei)
}

// required string software_version = 4;
inline bool RSALoginReq::has_software_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RSALoginReq::set_has_software_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RSALoginReq::clear_has_software_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RSALoginReq::clear_software_version() {
  if (software_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    software_version_->clear();
  }
  clear_has_software_version();
}
inline const ::std::string& RSALoginReq::software_version() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RSALoginReq.software_version)
  return *software_version_;
}
inline void RSALoginReq::set_software_version(const ::std::string& value) {
  set_has_software_version();
  if (software_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    software_version_ = new ::std::string;
  }
  software_version_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RSALoginReq.software_version)
}
inline void RSALoginReq::set_software_version(const char* value) {
  set_has_software_version();
  if (software_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    software_version_ = new ::std::string;
  }
  software_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RSALoginReq.software_version)
}
inline void RSALoginReq::set_software_version(const char* value, size_t size) {
  set_has_software_version();
  if (software_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    software_version_ = new ::std::string;
  }
  software_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RSALoginReq.software_version)
}
inline ::std::string* RSALoginReq::mutable_software_version() {
  set_has_software_version();
  if (software_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    software_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RSALoginReq.software_version)
  return software_version_;
}
inline ::std::string* RSALoginReq::release_software_version() {
  clear_has_software_version();
  if (software_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = software_version_;
    software_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RSALoginReq::set_allocated_software_version(::std::string* software_version) {
  if (software_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete software_version_;
  }
  if (software_version) {
    set_has_software_version();
    software_version_ = software_version;
  } else {
    clear_has_software_version();
    software_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RSALoginReq.software_version)
}

// required string hardware_version = 5;
inline bool RSALoginReq::has_hardware_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RSALoginReq::set_has_hardware_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RSALoginReq::clear_has_hardware_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RSALoginReq::clear_hardware_version() {
  if (hardware_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hardware_version_->clear();
  }
  clear_has_hardware_version();
}
inline const ::std::string& RSALoginReq::hardware_version() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RSALoginReq.hardware_version)
  return *hardware_version_;
}
inline void RSALoginReq::set_hardware_version(const ::std::string& value) {
  set_has_hardware_version();
  if (hardware_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hardware_version_ = new ::std::string;
  }
  hardware_version_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RSALoginReq.hardware_version)
}
inline void RSALoginReq::set_hardware_version(const char* value) {
  set_has_hardware_version();
  if (hardware_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hardware_version_ = new ::std::string;
  }
  hardware_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RSALoginReq.hardware_version)
}
inline void RSALoginReq::set_hardware_version(const char* value, size_t size) {
  set_has_hardware_version();
  if (hardware_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hardware_version_ = new ::std::string;
  }
  hardware_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RSALoginReq.hardware_version)
}
inline ::std::string* RSALoginReq::mutable_hardware_version() {
  set_has_hardware_version();
  if (hardware_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hardware_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RSALoginReq.hardware_version)
  return hardware_version_;
}
inline ::std::string* RSALoginReq::release_hardware_version() {
  clear_has_hardware_version();
  if (hardware_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hardware_version_;
    hardware_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RSALoginReq::set_allocated_hardware_version(::std::string* hardware_version) {
  if (hardware_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hardware_version_;
  }
  if (hardware_version) {
    set_has_hardware_version();
    hardware_version_ = hardware_version;
  } else {
    clear_has_hardware_version();
    hardware_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RSALoginReq.hardware_version)
}

// required uint32 time_stamp = 6;
inline bool RSALoginReq::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RSALoginReq::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RSALoginReq::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RSALoginReq::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 RSALoginReq::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RSALoginReq.time_stamp)
  return time_stamp_;
}
inline void RSALoginReq::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.RSALoginReq.time_stamp)
}

// optional string g4_version = 7;
inline bool RSALoginReq::has_g4_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RSALoginReq::set_has_g4_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RSALoginReq::clear_has_g4_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RSALoginReq::clear_g4_version() {
  if (g4_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    g4_version_->clear();
  }
  clear_has_g4_version();
}
inline const ::std::string& RSALoginReq::g4_version() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RSALoginReq.g4_version)
  return *g4_version_;
}
inline void RSALoginReq::set_g4_version(const ::std::string& value) {
  set_has_g4_version();
  if (g4_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    g4_version_ = new ::std::string;
  }
  g4_version_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RSALoginReq.g4_version)
}
inline void RSALoginReq::set_g4_version(const char* value) {
  set_has_g4_version();
  if (g4_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    g4_version_ = new ::std::string;
  }
  g4_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RSALoginReq.g4_version)
}
inline void RSALoginReq::set_g4_version(const char* value, size_t size) {
  set_has_g4_version();
  if (g4_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    g4_version_ = new ::std::string;
  }
  g4_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RSALoginReq.g4_version)
}
inline ::std::string* RSALoginReq::mutable_g4_version() {
  set_has_g4_version();
  if (g4_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    g4_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RSALoginReq.g4_version)
  return g4_version_;
}
inline ::std::string* RSALoginReq::release_g4_version() {
  clear_has_g4_version();
  if (g4_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = g4_version_;
    g4_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RSALoginReq::set_allocated_g4_version(::std::string* g4_version) {
  if (g4_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete g4_version_;
  }
  if (g4_version) {
    set_has_g4_version();
    g4_version_ = g4_version;
  } else {
    clear_has_g4_version();
    g4_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RSALoginReq.g4_version)
}

// optional string vehicle_type = 8;
inline bool RSALoginReq::has_vehicle_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RSALoginReq::set_has_vehicle_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RSALoginReq::clear_has_vehicle_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RSALoginReq::clear_vehicle_type() {
  if (vehicle_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vehicle_type_->clear();
  }
  clear_has_vehicle_type();
}
inline const ::std::string& RSALoginReq::vehicle_type() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RSALoginReq.vehicle_type)
  return *vehicle_type_;
}
inline void RSALoginReq::set_vehicle_type(const ::std::string& value) {
  set_has_vehicle_type();
  if (vehicle_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vehicle_type_ = new ::std::string;
  }
  vehicle_type_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RSALoginReq.vehicle_type)
}
inline void RSALoginReq::set_vehicle_type(const char* value) {
  set_has_vehicle_type();
  if (vehicle_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vehicle_type_ = new ::std::string;
  }
  vehicle_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RSALoginReq.vehicle_type)
}
inline void RSALoginReq::set_vehicle_type(const char* value, size_t size) {
  set_has_vehicle_type();
  if (vehicle_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vehicle_type_ = new ::std::string;
  }
  vehicle_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RSALoginReq.vehicle_type)
}
inline ::std::string* RSALoginReq::mutable_vehicle_type() {
  set_has_vehicle_type();
  if (vehicle_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vehicle_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RSALoginReq.vehicle_type)
  return vehicle_type_;
}
inline ::std::string* RSALoginReq::release_vehicle_type() {
  clear_has_vehicle_type();
  if (vehicle_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vehicle_type_;
    vehicle_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RSALoginReq::set_allocated_vehicle_type(::std::string* vehicle_type) {
  if (vehicle_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vehicle_type_;
  }
  if (vehicle_type) {
    set_has_vehicle_type();
    vehicle_type_ = vehicle_type;
  } else {
    clear_has_vehicle_type();
    vehicle_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RSALoginReq.vehicle_type)
}

// -------------------------------------------------------------------

// SendRSARsp

// required uint32 errcode = 1;
inline bool SendRSARsp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendRSARsp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendRSARsp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendRSARsp::clear_errcode() {
  errcode_ = 0u;
  clear_has_errcode();
}
inline ::google::protobuf::uint32 SendRSARsp::errcode() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SendRSARsp.errcode)
  return errcode_;
}
inline void SendRSARsp::set_errcode(::google::protobuf::uint32 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SendRSARsp.errcode)
}

// optional uint32 N_len = 2;
inline bool SendRSARsp::has_n_len() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendRSARsp::set_has_n_len() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendRSARsp::clear_has_n_len() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendRSARsp::clear_n_len() {
  n_len_ = 0u;
  clear_has_n_len();
}
inline ::google::protobuf::uint32 SendRSARsp::n_len() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SendRSARsp.N_len)
  return n_len_;
}
inline void SendRSARsp::set_n_len(::google::protobuf::uint32 value) {
  set_has_n_len();
  n_len_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SendRSARsp.N_len)
}

// optional bytes N_string = 3;
inline bool SendRSARsp::has_n_string() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendRSARsp::set_has_n_string() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendRSARsp::clear_has_n_string() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendRSARsp::clear_n_string() {
  if (n_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    n_string_->clear();
  }
  clear_has_n_string();
}
inline const ::std::string& SendRSARsp::n_string() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SendRSARsp.N_string)
  return *n_string_;
}
inline void SendRSARsp::set_n_string(const ::std::string& value) {
  set_has_n_string();
  if (n_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    n_string_ = new ::std::string;
  }
  n_string_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.SendRSARsp.N_string)
}
inline void SendRSARsp::set_n_string(const char* value) {
  set_has_n_string();
  if (n_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    n_string_ = new ::std::string;
  }
  n_string_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.SendRSARsp.N_string)
}
inline void SendRSARsp::set_n_string(const void* value, size_t size) {
  set_has_n_string();
  if (n_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    n_string_ = new ::std::string;
  }
  n_string_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.SendRSARsp.N_string)
}
inline ::std::string* SendRSARsp::mutable_n_string() {
  set_has_n_string();
  if (n_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    n_string_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.SendRSARsp.N_string)
  return n_string_;
}
inline ::std::string* SendRSARsp::release_n_string() {
  clear_has_n_string();
  if (n_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = n_string_;
    n_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendRSARsp::set_allocated_n_string(::std::string* n_string) {
  if (n_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete n_string_;
  }
  if (n_string) {
    set_has_n_string();
    n_string_ = n_string;
  } else {
    clear_has_n_string();
    n_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.SendRSARsp.N_string)
}

// optional uint32 E1_len = 4;
inline bool SendRSARsp::has_e1_len() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SendRSARsp::set_has_e1_len() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SendRSARsp::clear_has_e1_len() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SendRSARsp::clear_e1_len() {
  e1_len_ = 0u;
  clear_has_e1_len();
}
inline ::google::protobuf::uint32 SendRSARsp::e1_len() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SendRSARsp.E1_len)
  return e1_len_;
}
inline void SendRSARsp::set_e1_len(::google::protobuf::uint32 value) {
  set_has_e1_len();
  e1_len_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SendRSARsp.E1_len)
}

// optional bytes E1_string = 5;
inline bool SendRSARsp::has_e1_string() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SendRSARsp::set_has_e1_string() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SendRSARsp::clear_has_e1_string() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SendRSARsp::clear_e1_string() {
  if (e1_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    e1_string_->clear();
  }
  clear_has_e1_string();
}
inline const ::std::string& SendRSARsp::e1_string() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SendRSARsp.E1_string)
  return *e1_string_;
}
inline void SendRSARsp::set_e1_string(const ::std::string& value) {
  set_has_e1_string();
  if (e1_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    e1_string_ = new ::std::string;
  }
  e1_string_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.SendRSARsp.E1_string)
}
inline void SendRSARsp::set_e1_string(const char* value) {
  set_has_e1_string();
  if (e1_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    e1_string_ = new ::std::string;
  }
  e1_string_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.SendRSARsp.E1_string)
}
inline void SendRSARsp::set_e1_string(const void* value, size_t size) {
  set_has_e1_string();
  if (e1_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    e1_string_ = new ::std::string;
  }
  e1_string_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.SendRSARsp.E1_string)
}
inline ::std::string* SendRSARsp::mutable_e1_string() {
  set_has_e1_string();
  if (e1_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    e1_string_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.SendRSARsp.E1_string)
  return e1_string_;
}
inline ::std::string* SendRSARsp::release_e1_string() {
  clear_has_e1_string();
  if (e1_string_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = e1_string_;
    e1_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendRSARsp::set_allocated_e1_string(::std::string* e1_string) {
  if (e1_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete e1_string_;
  }
  if (e1_string) {
    set_has_e1_string();
    e1_string_ = e1_string;
  } else {
    clear_has_e1_string();
    e1_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.SendRSARsp.E1_string)
}

// -------------------------------------------------------------------

// SendRC4Req

// required string da_device_sn = 1;
inline bool SendRC4Req::has_da_device_sn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendRC4Req::set_has_da_device_sn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendRC4Req::clear_has_da_device_sn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendRC4Req::clear_da_device_sn() {
  if (da_device_sn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    da_device_sn_->clear();
  }
  clear_has_da_device_sn();
}
inline const ::std::string& SendRC4Req::da_device_sn() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SendRC4Req.da_device_sn)
  return *da_device_sn_;
}
inline void SendRC4Req::set_da_device_sn(const ::std::string& value) {
  set_has_da_device_sn();
  if (da_device_sn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    da_device_sn_ = new ::std::string;
  }
  da_device_sn_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.SendRC4Req.da_device_sn)
}
inline void SendRC4Req::set_da_device_sn(const char* value) {
  set_has_da_device_sn();
  if (da_device_sn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    da_device_sn_ = new ::std::string;
  }
  da_device_sn_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.SendRC4Req.da_device_sn)
}
inline void SendRC4Req::set_da_device_sn(const char* value, size_t size) {
  set_has_da_device_sn();
  if (da_device_sn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    da_device_sn_ = new ::std::string;
  }
  da_device_sn_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.SendRC4Req.da_device_sn)
}
inline ::std::string* SendRC4Req::mutable_da_device_sn() {
  set_has_da_device_sn();
  if (da_device_sn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    da_device_sn_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.SendRC4Req.da_device_sn)
  return da_device_sn_;
}
inline ::std::string* SendRC4Req::release_da_device_sn() {
  clear_has_da_device_sn();
  if (da_device_sn_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = da_device_sn_;
    da_device_sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendRC4Req::set_allocated_da_device_sn(::std::string* da_device_sn) {
  if (da_device_sn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete da_device_sn_;
  }
  if (da_device_sn) {
    set_has_da_device_sn();
    da_device_sn_ = da_device_sn;
  } else {
    clear_has_da_device_sn();
    da_device_sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.SendRC4Req.da_device_sn)
}

// required string vin = 2;
inline bool SendRC4Req::has_vin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendRC4Req::set_has_vin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendRC4Req::clear_has_vin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendRC4Req::clear_vin() {
  if (vin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vin_->clear();
  }
  clear_has_vin();
}
inline const ::std::string& SendRC4Req::vin() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SendRC4Req.vin)
  return *vin_;
}
inline void SendRC4Req::set_vin(const ::std::string& value) {
  set_has_vin();
  if (vin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vin_ = new ::std::string;
  }
  vin_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.SendRC4Req.vin)
}
inline void SendRC4Req::set_vin(const char* value) {
  set_has_vin();
  if (vin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vin_ = new ::std::string;
  }
  vin_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.SendRC4Req.vin)
}
inline void SendRC4Req::set_vin(const char* value, size_t size) {
  set_has_vin();
  if (vin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vin_ = new ::std::string;
  }
  vin_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.SendRC4Req.vin)
}
inline ::std::string* SendRC4Req::mutable_vin() {
  set_has_vin();
  if (vin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vin_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.SendRC4Req.vin)
  return vin_;
}
inline ::std::string* SendRC4Req::release_vin() {
  clear_has_vin();
  if (vin_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vin_;
    vin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendRC4Req::set_allocated_vin(::std::string* vin) {
  if (vin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vin_;
  }
  if (vin) {
    set_has_vin();
    vin_ = vin;
  } else {
    clear_has_vin();
    vin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.SendRC4Req.vin)
}

// required string iccid = 3;
inline bool SendRC4Req::has_iccid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendRC4Req::set_has_iccid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendRC4Req::clear_has_iccid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendRC4Req::clear_iccid() {
  if (iccid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iccid_->clear();
  }
  clear_has_iccid();
}
inline const ::std::string& SendRC4Req::iccid() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SendRC4Req.iccid)
  return *iccid_;
}
inline void SendRC4Req::set_iccid(const ::std::string& value) {
  set_has_iccid();
  if (iccid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iccid_ = new ::std::string;
  }
  iccid_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.SendRC4Req.iccid)
}
inline void SendRC4Req::set_iccid(const char* value) {
  set_has_iccid();
  if (iccid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iccid_ = new ::std::string;
  }
  iccid_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.SendRC4Req.iccid)
}
inline void SendRC4Req::set_iccid(const char* value, size_t size) {
  set_has_iccid();
  if (iccid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iccid_ = new ::std::string;
  }
  iccid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.SendRC4Req.iccid)
}
inline ::std::string* SendRC4Req::mutable_iccid() {
  set_has_iccid();
  if (iccid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    iccid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.SendRC4Req.iccid)
  return iccid_;
}
inline ::std::string* SendRC4Req::release_iccid() {
  clear_has_iccid();
  if (iccid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = iccid_;
    iccid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendRC4Req::set_allocated_iccid(::std::string* iccid) {
  if (iccid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete iccid_;
  }
  if (iccid) {
    set_has_iccid();
    iccid_ = iccid;
  } else {
    clear_has_iccid();
    iccid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.SendRC4Req.iccid)
}

// required uint32 serial_number = 4;
inline bool SendRC4Req::has_serial_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SendRC4Req::set_has_serial_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SendRC4Req::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SendRC4Req::clear_serial_number() {
  serial_number_ = 0u;
  clear_has_serial_number();
}
inline ::google::protobuf::uint32 SendRC4Req::serial_number() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SendRC4Req.serial_number)
  return serial_number_;
}
inline void SendRC4Req::set_serial_number(::google::protobuf::uint32 value) {
  set_has_serial_number();
  serial_number_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SendRC4Req.serial_number)
}

// required uint32 key_len = 5;
inline bool SendRC4Req::has_key_len() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SendRC4Req::set_has_key_len() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SendRC4Req::clear_has_key_len() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SendRC4Req::clear_key_len() {
  key_len_ = 0u;
  clear_has_key_len();
}
inline ::google::protobuf::uint32 SendRC4Req::key_len() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SendRC4Req.key_len)
  return key_len_;
}
inline void SendRC4Req::set_key_len(::google::protobuf::uint32 value) {
  set_has_key_len();
  key_len_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SendRC4Req.key_len)
}

// required bytes key = 6;
inline bool SendRC4Req::has_key() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SendRC4Req::set_has_key() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SendRC4Req::clear_has_key() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SendRC4Req::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& SendRC4Req::key() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SendRC4Req.key)
  return *key_;
}
inline void SendRC4Req::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.SendRC4Req.key)
}
inline void SendRC4Req::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.SendRC4Req.key)
}
inline void SendRC4Req::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.SendRC4Req.key)
}
inline ::std::string* SendRC4Req::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.SendRC4Req.key)
  return key_;
}
inline ::std::string* SendRC4Req::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SendRC4Req::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.SendRC4Req.key)
}

// optional bool upgrading = 7;
inline bool SendRC4Req::has_upgrading() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SendRC4Req::set_has_upgrading() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SendRC4Req::clear_has_upgrading() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SendRC4Req::clear_upgrading() {
  upgrading_ = false;
  clear_has_upgrading();
}
inline bool SendRC4Req::upgrading() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SendRC4Req.upgrading)
  return upgrading_;
}
inline void SendRC4Req::set_upgrading(bool value) {
  set_has_upgrading();
  upgrading_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SendRC4Req.upgrading)
}

// optional bool bcm_reg_status = 8;
inline bool SendRC4Req::has_bcm_reg_status() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SendRC4Req::set_has_bcm_reg_status() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SendRC4Req::clear_has_bcm_reg_status() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SendRC4Req::clear_bcm_reg_status() {
  bcm_reg_status_ = false;
  clear_has_bcm_reg_status();
}
inline bool SendRC4Req::bcm_reg_status() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SendRC4Req.bcm_reg_status)
  return bcm_reg_status_;
}
inline void SendRC4Req::set_bcm_reg_status(bool value) {
  set_has_bcm_reg_status();
  bcm_reg_status_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SendRC4Req.bcm_reg_status)
}

// -------------------------------------------------------------------

// SendRC4Resp

// required uint32 errcode = 1;
inline bool SendRC4Resp::has_errcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendRC4Resp::set_has_errcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendRC4Resp::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendRC4Resp::clear_errcode() {
  errcode_ = 0u;
  clear_has_errcode();
}
inline ::google::protobuf::uint32 SendRC4Resp::errcode() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SendRC4Resp.errcode)
  return errcode_;
}
inline void SendRC4Resp::set_errcode(::google::protobuf::uint32 value) {
  set_has_errcode();
  errcode_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SendRC4Resp.errcode)
}

// required uint32 serial_number = 2;
inline bool SendRC4Resp::has_serial_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendRC4Resp::set_has_serial_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendRC4Resp::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendRC4Resp::clear_serial_number() {
  serial_number_ = 0u;
  clear_has_serial_number();
}
inline ::google::protobuf::uint32 SendRC4Resp::serial_number() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SendRC4Resp.serial_number)
  return serial_number_;
}
inline void SendRC4Resp::set_serial_number(::google::protobuf::uint32 value) {
  set_has_serial_number();
  serial_number_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SendRC4Resp.serial_number)
}

// required uint32 time_stamp = 3;
inline bool SendRC4Resp::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendRC4Resp::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendRC4Resp::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendRC4Resp::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 SendRC4Resp::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.SendRC4Resp.time_stamp)
  return time_stamp_;
}
inline void SendRC4Resp::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.SendRC4Resp.time_stamp)
}

// repeated .zna.protocol.UpgradeInfo upgradeinfo = 4;
inline int SendRC4Resp::upgradeinfo_size() const {
  return upgradeinfo_.size();
}
inline void SendRC4Resp::clear_upgradeinfo() {
  upgradeinfo_.Clear();
}
inline const ::zna::protocol::UpgradeInfo& SendRC4Resp::upgradeinfo(int index) const {
  // @@protoc_insertion_point(field_get:zna.protocol.SendRC4Resp.upgradeinfo)
  return upgradeinfo_.Get(index);
}
inline ::zna::protocol::UpgradeInfo* SendRC4Resp::mutable_upgradeinfo(int index) {
  // @@protoc_insertion_point(field_mutable:zna.protocol.SendRC4Resp.upgradeinfo)
  return upgradeinfo_.Mutable(index);
}
inline ::zna::protocol::UpgradeInfo* SendRC4Resp::add_upgradeinfo() {
  // @@protoc_insertion_point(field_add:zna.protocol.SendRC4Resp.upgradeinfo)
  return upgradeinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::zna::protocol::UpgradeInfo >&
SendRC4Resp::upgradeinfo() const {
  // @@protoc_insertion_point(field_list:zna.protocol.SendRC4Resp.upgradeinfo)
  return upgradeinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::zna::protocol::UpgradeInfo >*
SendRC4Resp::mutable_upgradeinfo() {
  // @@protoc_insertion_point(field_mutable_list:zna.protocol.SendRC4Resp.upgradeinfo)
  return &upgradeinfo_;
}

// -------------------------------------------------------------------

// WakeUpDVRRsp

// required uint32 serial_number = 1;
inline bool WakeUpDVRRsp::has_serial_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WakeUpDVRRsp::set_has_serial_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WakeUpDVRRsp::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WakeUpDVRRsp::clear_serial_number() {
  serial_number_ = 0u;
  clear_has_serial_number();
}
inline ::google::protobuf::uint32 WakeUpDVRRsp::serial_number() const {
  // @@protoc_insertion_point(field_get:zna.protocol.WakeUpDVRRsp.serial_number)
  return serial_number_;
}
inline void WakeUpDVRRsp::set_serial_number(::google::protobuf::uint32 value) {
  set_has_serial_number();
  serial_number_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.WakeUpDVRRsp.serial_number)
}

// required uint32 control_result = 2;
inline bool WakeUpDVRRsp::has_control_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WakeUpDVRRsp::set_has_control_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WakeUpDVRRsp::clear_has_control_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WakeUpDVRRsp::clear_control_result() {
  control_result_ = 0u;
  clear_has_control_result();
}
inline ::google::protobuf::uint32 WakeUpDVRRsp::control_result() const {
  // @@protoc_insertion_point(field_get:zna.protocol.WakeUpDVRRsp.control_result)
  return control_result_;
}
inline void WakeUpDVRRsp::set_control_result(::google::protobuf::uint32 value) {
  set_has_control_result();
  control_result_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.WakeUpDVRRsp.control_result)
}

// -------------------------------------------------------------------

// WakeUpDVRReq

// required uint32 serial_number = 1;
inline bool WakeUpDVRReq::has_serial_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WakeUpDVRReq::set_has_serial_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WakeUpDVRReq::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WakeUpDVRReq::clear_serial_number() {
  serial_number_ = 0u;
  clear_has_serial_number();
}
inline ::google::protobuf::uint32 WakeUpDVRReq::serial_number() const {
  // @@protoc_insertion_point(field_get:zna.protocol.WakeUpDVRReq.serial_number)
  return serial_number_;
}
inline void WakeUpDVRReq::set_serial_number(::google::protobuf::uint32 value) {
  set_has_serial_number();
  serial_number_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.WakeUpDVRReq.serial_number)
}

// required uint32 time_stamp = 2;
inline bool WakeUpDVRReq::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WakeUpDVRReq::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WakeUpDVRReq::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WakeUpDVRReq::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 WakeUpDVRReq::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.WakeUpDVRReq.time_stamp)
  return time_stamp_;
}
inline void WakeUpDVRReq::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.WakeUpDVRReq.time_stamp)
}

// -------------------------------------------------------------------

// RmtDiagRsp

// required .zna.protocol.RmtDiagRspCode result = 1;
inline bool RmtDiagRsp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RmtDiagRsp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RmtDiagRsp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RmtDiagRsp::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::zna::protocol::RmtDiagRspCode RmtDiagRsp::result() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RmtDiagRsp.result)
  return static_cast< ::zna::protocol::RmtDiagRspCode >(result_);
}
inline void RmtDiagRsp::set_result(::zna::protocol::RmtDiagRspCode value) {
  assert(::zna::protocol::RmtDiagRspCode_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.RmtDiagRsp.result)
}

// required uint32 serial_number = 2;
inline bool RmtDiagRsp::has_serial_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RmtDiagRsp::set_has_serial_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RmtDiagRsp::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RmtDiagRsp::clear_serial_number() {
  serial_number_ = 0u;
  clear_has_serial_number();
}
inline ::google::protobuf::uint32 RmtDiagRsp::serial_number() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RmtDiagRsp.serial_number)
  return serial_number_;
}
inline void RmtDiagRsp::set_serial_number(::google::protobuf::uint32 value) {
  set_has_serial_number();
  serial_number_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.RmtDiagRsp.serial_number)
}

// required uint32 time_stamp = 3;
inline bool RmtDiagRsp::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RmtDiagRsp::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RmtDiagRsp::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RmtDiagRsp::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 RmtDiagRsp::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RmtDiagRsp.time_stamp)
  return time_stamp_;
}
inline void RmtDiagRsp::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.RmtDiagRsp.time_stamp)
}

// optional bytes Diag_AVM = 4;
inline bool RmtDiagRsp::has_diag_avm() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RmtDiagRsp::set_has_diag_avm() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RmtDiagRsp::clear_has_diag_avm() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RmtDiagRsp::clear_diag_avm() {
  if (diag_avm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_avm_->clear();
  }
  clear_has_diag_avm();
}
inline const ::std::string& RmtDiagRsp::diag_avm() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RmtDiagRsp.Diag_AVM)
  return *diag_avm_;
}
inline void RmtDiagRsp::set_diag_avm(const ::std::string& value) {
  set_has_diag_avm();
  if (diag_avm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_avm_ = new ::std::string;
  }
  diag_avm_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RmtDiagRsp.Diag_AVM)
}
inline void RmtDiagRsp::set_diag_avm(const char* value) {
  set_has_diag_avm();
  if (diag_avm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_avm_ = new ::std::string;
  }
  diag_avm_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RmtDiagRsp.Diag_AVM)
}
inline void RmtDiagRsp::set_diag_avm(const void* value, size_t size) {
  set_has_diag_avm();
  if (diag_avm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_avm_ = new ::std::string;
  }
  diag_avm_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RmtDiagRsp.Diag_AVM)
}
inline ::std::string* RmtDiagRsp::mutable_diag_avm() {
  set_has_diag_avm();
  if (diag_avm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_avm_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RmtDiagRsp.Diag_AVM)
  return diag_avm_;
}
inline ::std::string* RmtDiagRsp::release_diag_avm() {
  clear_has_diag_avm();
  if (diag_avm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = diag_avm_;
    diag_avm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RmtDiagRsp::set_allocated_diag_avm(::std::string* diag_avm) {
  if (diag_avm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_avm_;
  }
  if (diag_avm) {
    set_has_diag_avm();
    diag_avm_ = diag_avm;
  } else {
    clear_has_diag_avm();
    diag_avm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RmtDiagRsp.Diag_AVM)
}

// optional bytes Diag_SONAR = 5;
inline bool RmtDiagRsp::has_diag_sonar() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RmtDiagRsp::set_has_diag_sonar() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RmtDiagRsp::clear_has_diag_sonar() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RmtDiagRsp::clear_diag_sonar() {
  if (diag_sonar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_sonar_->clear();
  }
  clear_has_diag_sonar();
}
inline const ::std::string& RmtDiagRsp::diag_sonar() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RmtDiagRsp.Diag_SONAR)
  return *diag_sonar_;
}
inline void RmtDiagRsp::set_diag_sonar(const ::std::string& value) {
  set_has_diag_sonar();
  if (diag_sonar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_sonar_ = new ::std::string;
  }
  diag_sonar_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RmtDiagRsp.Diag_SONAR)
}
inline void RmtDiagRsp::set_diag_sonar(const char* value) {
  set_has_diag_sonar();
  if (diag_sonar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_sonar_ = new ::std::string;
  }
  diag_sonar_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RmtDiagRsp.Diag_SONAR)
}
inline void RmtDiagRsp::set_diag_sonar(const void* value, size_t size) {
  set_has_diag_sonar();
  if (diag_sonar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_sonar_ = new ::std::string;
  }
  diag_sonar_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RmtDiagRsp.Diag_SONAR)
}
inline ::std::string* RmtDiagRsp::mutable_diag_sonar() {
  set_has_diag_sonar();
  if (diag_sonar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_sonar_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RmtDiagRsp.Diag_SONAR)
  return diag_sonar_;
}
inline ::std::string* RmtDiagRsp::release_diag_sonar() {
  clear_has_diag_sonar();
  if (diag_sonar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = diag_sonar_;
    diag_sonar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RmtDiagRsp::set_allocated_diag_sonar(::std::string* diag_sonar) {
  if (diag_sonar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_sonar_;
  }
  if (diag_sonar) {
    set_has_diag_sonar();
    diag_sonar_ = diag_sonar;
  } else {
    clear_has_diag_sonar();
    diag_sonar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RmtDiagRsp.Diag_SONAR)
}

// optional bytes Diag_BSW = 6;
inline bool RmtDiagRsp::has_diag_bsw() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RmtDiagRsp::set_has_diag_bsw() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RmtDiagRsp::clear_has_diag_bsw() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RmtDiagRsp::clear_diag_bsw() {
  if (diag_bsw_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_bsw_->clear();
  }
  clear_has_diag_bsw();
}
inline const ::std::string& RmtDiagRsp::diag_bsw() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RmtDiagRsp.Diag_BSW)
  return *diag_bsw_;
}
inline void RmtDiagRsp::set_diag_bsw(const ::std::string& value) {
  set_has_diag_bsw();
  if (diag_bsw_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_bsw_ = new ::std::string;
  }
  diag_bsw_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RmtDiagRsp.Diag_BSW)
}
inline void RmtDiagRsp::set_diag_bsw(const char* value) {
  set_has_diag_bsw();
  if (diag_bsw_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_bsw_ = new ::std::string;
  }
  diag_bsw_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RmtDiagRsp.Diag_BSW)
}
inline void RmtDiagRsp::set_diag_bsw(const void* value, size_t size) {
  set_has_diag_bsw();
  if (diag_bsw_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_bsw_ = new ::std::string;
  }
  diag_bsw_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RmtDiagRsp.Diag_BSW)
}
inline ::std::string* RmtDiagRsp::mutable_diag_bsw() {
  set_has_diag_bsw();
  if (diag_bsw_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_bsw_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RmtDiagRsp.Diag_BSW)
  return diag_bsw_;
}
inline ::std::string* RmtDiagRsp::release_diag_bsw() {
  clear_has_diag_bsw();
  if (diag_bsw_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = diag_bsw_;
    diag_bsw_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RmtDiagRsp::set_allocated_diag_bsw(::std::string* diag_bsw) {
  if (diag_bsw_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_bsw_;
  }
  if (diag_bsw) {
    set_has_diag_bsw();
    diag_bsw_ = diag_bsw;
  } else {
    clear_has_diag_bsw();
    diag_bsw_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RmtDiagRsp.Diag_BSW)
}

// optional bytes Diag_ECM = 7;
inline bool RmtDiagRsp::has_diag_ecm() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RmtDiagRsp::set_has_diag_ecm() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RmtDiagRsp::clear_has_diag_ecm() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RmtDiagRsp::clear_diag_ecm() {
  if (diag_ecm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_ecm_->clear();
  }
  clear_has_diag_ecm();
}
inline const ::std::string& RmtDiagRsp::diag_ecm() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RmtDiagRsp.Diag_ECM)
  return *diag_ecm_;
}
inline void RmtDiagRsp::set_diag_ecm(const ::std::string& value) {
  set_has_diag_ecm();
  if (diag_ecm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_ecm_ = new ::std::string;
  }
  diag_ecm_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RmtDiagRsp.Diag_ECM)
}
inline void RmtDiagRsp::set_diag_ecm(const char* value) {
  set_has_diag_ecm();
  if (diag_ecm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_ecm_ = new ::std::string;
  }
  diag_ecm_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RmtDiagRsp.Diag_ECM)
}
inline void RmtDiagRsp::set_diag_ecm(const void* value, size_t size) {
  set_has_diag_ecm();
  if (diag_ecm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_ecm_ = new ::std::string;
  }
  diag_ecm_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RmtDiagRsp.Diag_ECM)
}
inline ::std::string* RmtDiagRsp::mutable_diag_ecm() {
  set_has_diag_ecm();
  if (diag_ecm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_ecm_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RmtDiagRsp.Diag_ECM)
  return diag_ecm_;
}
inline ::std::string* RmtDiagRsp::release_diag_ecm() {
  clear_has_diag_ecm();
  if (diag_ecm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = diag_ecm_;
    diag_ecm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RmtDiagRsp::set_allocated_diag_ecm(::std::string* diag_ecm) {
  if (diag_ecm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_ecm_;
  }
  if (diag_ecm) {
    set_has_diag_ecm();
    diag_ecm_ = diag_ecm;
  } else {
    clear_has_diag_ecm();
    diag_ecm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RmtDiagRsp.Diag_ECM)
}

// optional bytes Diag_TCM = 8;
inline bool RmtDiagRsp::has_diag_tcm() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RmtDiagRsp::set_has_diag_tcm() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RmtDiagRsp::clear_has_diag_tcm() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RmtDiagRsp::clear_diag_tcm() {
  if (diag_tcm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_tcm_->clear();
  }
  clear_has_diag_tcm();
}
inline const ::std::string& RmtDiagRsp::diag_tcm() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RmtDiagRsp.Diag_TCM)
  return *diag_tcm_;
}
inline void RmtDiagRsp::set_diag_tcm(const ::std::string& value) {
  set_has_diag_tcm();
  if (diag_tcm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_tcm_ = new ::std::string;
  }
  diag_tcm_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RmtDiagRsp.Diag_TCM)
}
inline void RmtDiagRsp::set_diag_tcm(const char* value) {
  set_has_diag_tcm();
  if (diag_tcm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_tcm_ = new ::std::string;
  }
  diag_tcm_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RmtDiagRsp.Diag_TCM)
}
inline void RmtDiagRsp::set_diag_tcm(const void* value, size_t size) {
  set_has_diag_tcm();
  if (diag_tcm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_tcm_ = new ::std::string;
  }
  diag_tcm_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RmtDiagRsp.Diag_TCM)
}
inline ::std::string* RmtDiagRsp::mutable_diag_tcm() {
  set_has_diag_tcm();
  if (diag_tcm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_tcm_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RmtDiagRsp.Diag_TCM)
  return diag_tcm_;
}
inline ::std::string* RmtDiagRsp::release_diag_tcm() {
  clear_has_diag_tcm();
  if (diag_tcm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = diag_tcm_;
    diag_tcm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RmtDiagRsp::set_allocated_diag_tcm(::std::string* diag_tcm) {
  if (diag_tcm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_tcm_;
  }
  if (diag_tcm) {
    set_has_diag_tcm();
    diag_tcm_ = diag_tcm;
  } else {
    clear_has_diag_tcm();
    diag_tcm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RmtDiagRsp.Diag_TCM)
}

// optional bytes Diag_USM = 9;
inline bool RmtDiagRsp::has_diag_usm() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RmtDiagRsp::set_has_diag_usm() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RmtDiagRsp::clear_has_diag_usm() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RmtDiagRsp::clear_diag_usm() {
  if (diag_usm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_usm_->clear();
  }
  clear_has_diag_usm();
}
inline const ::std::string& RmtDiagRsp::diag_usm() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RmtDiagRsp.Diag_USM)
  return *diag_usm_;
}
inline void RmtDiagRsp::set_diag_usm(const ::std::string& value) {
  set_has_diag_usm();
  if (diag_usm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_usm_ = new ::std::string;
  }
  diag_usm_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RmtDiagRsp.Diag_USM)
}
inline void RmtDiagRsp::set_diag_usm(const char* value) {
  set_has_diag_usm();
  if (diag_usm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_usm_ = new ::std::string;
  }
  diag_usm_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RmtDiagRsp.Diag_USM)
}
inline void RmtDiagRsp::set_diag_usm(const void* value, size_t size) {
  set_has_diag_usm();
  if (diag_usm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_usm_ = new ::std::string;
  }
  diag_usm_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RmtDiagRsp.Diag_USM)
}
inline ::std::string* RmtDiagRsp::mutable_diag_usm() {
  set_has_diag_usm();
  if (diag_usm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_usm_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RmtDiagRsp.Diag_USM)
  return diag_usm_;
}
inline ::std::string* RmtDiagRsp::release_diag_usm() {
  clear_has_diag_usm();
  if (diag_usm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = diag_usm_;
    diag_usm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RmtDiagRsp::set_allocated_diag_usm(::std::string* diag_usm) {
  if (diag_usm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_usm_;
  }
  if (diag_usm) {
    set_has_diag_usm();
    diag_usm_ = diag_usm;
  } else {
    clear_has_diag_usm();
    diag_usm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RmtDiagRsp.Diag_USM)
}

// optional bytes Diag_BCM = 10;
inline bool RmtDiagRsp::has_diag_bcm() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RmtDiagRsp::set_has_diag_bcm() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RmtDiagRsp::clear_has_diag_bcm() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RmtDiagRsp::clear_diag_bcm() {
  if (diag_bcm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_bcm_->clear();
  }
  clear_has_diag_bcm();
}
inline const ::std::string& RmtDiagRsp::diag_bcm() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RmtDiagRsp.Diag_BCM)
  return *diag_bcm_;
}
inline void RmtDiagRsp::set_diag_bcm(const ::std::string& value) {
  set_has_diag_bcm();
  if (diag_bcm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_bcm_ = new ::std::string;
  }
  diag_bcm_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RmtDiagRsp.Diag_BCM)
}
inline void RmtDiagRsp::set_diag_bcm(const char* value) {
  set_has_diag_bcm();
  if (diag_bcm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_bcm_ = new ::std::string;
  }
  diag_bcm_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RmtDiagRsp.Diag_BCM)
}
inline void RmtDiagRsp::set_diag_bcm(const void* value, size_t size) {
  set_has_diag_bcm();
  if (diag_bcm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_bcm_ = new ::std::string;
  }
  diag_bcm_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RmtDiagRsp.Diag_BCM)
}
inline ::std::string* RmtDiagRsp::mutable_diag_bcm() {
  set_has_diag_bcm();
  if (diag_bcm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_bcm_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RmtDiagRsp.Diag_BCM)
  return diag_bcm_;
}
inline ::std::string* RmtDiagRsp::release_diag_bcm() {
  clear_has_diag_bcm();
  if (diag_bcm_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = diag_bcm_;
    diag_bcm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RmtDiagRsp::set_allocated_diag_bcm(::std::string* diag_bcm) {
  if (diag_bcm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_bcm_;
  }
  if (diag_bcm) {
    set_has_diag_bcm();
    diag_bcm_ = diag_bcm;
  } else {
    clear_has_diag_bcm();
    diag_bcm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RmtDiagRsp.Diag_BCM)
}

// optional bytes Diag_FEB_CAMERA = 11;
inline bool RmtDiagRsp::has_diag_feb_camera() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RmtDiagRsp::set_has_diag_feb_camera() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RmtDiagRsp::clear_has_diag_feb_camera() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RmtDiagRsp::clear_diag_feb_camera() {
  if (diag_feb_camera_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_feb_camera_->clear();
  }
  clear_has_diag_feb_camera();
}
inline const ::std::string& RmtDiagRsp::diag_feb_camera() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RmtDiagRsp.Diag_FEB_CAMERA)
  return *diag_feb_camera_;
}
inline void RmtDiagRsp::set_diag_feb_camera(const ::std::string& value) {
  set_has_diag_feb_camera();
  if (diag_feb_camera_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_feb_camera_ = new ::std::string;
  }
  diag_feb_camera_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RmtDiagRsp.Diag_FEB_CAMERA)
}
inline void RmtDiagRsp::set_diag_feb_camera(const char* value) {
  set_has_diag_feb_camera();
  if (diag_feb_camera_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_feb_camera_ = new ::std::string;
  }
  diag_feb_camera_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RmtDiagRsp.Diag_FEB_CAMERA)
}
inline void RmtDiagRsp::set_diag_feb_camera(const void* value, size_t size) {
  set_has_diag_feb_camera();
  if (diag_feb_camera_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_feb_camera_ = new ::std::string;
  }
  diag_feb_camera_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RmtDiagRsp.Diag_FEB_CAMERA)
}
inline ::std::string* RmtDiagRsp::mutable_diag_feb_camera() {
  set_has_diag_feb_camera();
  if (diag_feb_camera_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_feb_camera_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RmtDiagRsp.Diag_FEB_CAMERA)
  return diag_feb_camera_;
}
inline ::std::string* RmtDiagRsp::release_diag_feb_camera() {
  clear_has_diag_feb_camera();
  if (diag_feb_camera_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = diag_feb_camera_;
    diag_feb_camera_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RmtDiagRsp::set_allocated_diag_feb_camera(::std::string* diag_feb_camera) {
  if (diag_feb_camera_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_feb_camera_;
  }
  if (diag_feb_camera) {
    set_has_diag_feb_camera();
    diag_feb_camera_ = diag_feb_camera;
  } else {
    clear_has_diag_feb_camera();
    diag_feb_camera_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RmtDiagRsp.Diag_FEB_CAMERA)
}

// optional bytes Diag_FEB_RADAR = 12;
inline bool RmtDiagRsp::has_diag_feb_radar() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RmtDiagRsp::set_has_diag_feb_radar() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RmtDiagRsp::clear_has_diag_feb_radar() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RmtDiagRsp::clear_diag_feb_radar() {
  if (diag_feb_radar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_feb_radar_->clear();
  }
  clear_has_diag_feb_radar();
}
inline const ::std::string& RmtDiagRsp::diag_feb_radar() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RmtDiagRsp.Diag_FEB_RADAR)
  return *diag_feb_radar_;
}
inline void RmtDiagRsp::set_diag_feb_radar(const ::std::string& value) {
  set_has_diag_feb_radar();
  if (diag_feb_radar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_feb_radar_ = new ::std::string;
  }
  diag_feb_radar_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RmtDiagRsp.Diag_FEB_RADAR)
}
inline void RmtDiagRsp::set_diag_feb_radar(const char* value) {
  set_has_diag_feb_radar();
  if (diag_feb_radar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_feb_radar_ = new ::std::string;
  }
  diag_feb_radar_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RmtDiagRsp.Diag_FEB_RADAR)
}
inline void RmtDiagRsp::set_diag_feb_radar(const void* value, size_t size) {
  set_has_diag_feb_radar();
  if (diag_feb_radar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_feb_radar_ = new ::std::string;
  }
  diag_feb_radar_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RmtDiagRsp.Diag_FEB_RADAR)
}
inline ::std::string* RmtDiagRsp::mutable_diag_feb_radar() {
  set_has_diag_feb_radar();
  if (diag_feb_radar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_feb_radar_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RmtDiagRsp.Diag_FEB_RADAR)
  return diag_feb_radar_;
}
inline ::std::string* RmtDiagRsp::release_diag_feb_radar() {
  clear_has_diag_feb_radar();
  if (diag_feb_radar_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = diag_feb_radar_;
    diag_feb_radar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RmtDiagRsp::set_allocated_diag_feb_radar(::std::string* diag_feb_radar) {
  if (diag_feb_radar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_feb_radar_;
  }
  if (diag_feb_radar) {
    set_has_diag_feb_radar();
    diag_feb_radar_ = diag_feb_radar;
  } else {
    clear_has_diag_feb_radar();
    diag_feb_radar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RmtDiagRsp.Diag_FEB_RADAR)
}

// optional bytes Diag_DVR = 13;
inline bool RmtDiagRsp::has_diag_dvr() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RmtDiagRsp::set_has_diag_dvr() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RmtDiagRsp::clear_has_diag_dvr() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RmtDiagRsp::clear_diag_dvr() {
  if (diag_dvr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_dvr_->clear();
  }
  clear_has_diag_dvr();
}
inline const ::std::string& RmtDiagRsp::diag_dvr() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RmtDiagRsp.Diag_DVR)
  return *diag_dvr_;
}
inline void RmtDiagRsp::set_diag_dvr(const ::std::string& value) {
  set_has_diag_dvr();
  if (diag_dvr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_dvr_ = new ::std::string;
  }
  diag_dvr_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RmtDiagRsp.Diag_DVR)
}
inline void RmtDiagRsp::set_diag_dvr(const char* value) {
  set_has_diag_dvr();
  if (diag_dvr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_dvr_ = new ::std::string;
  }
  diag_dvr_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RmtDiagRsp.Diag_DVR)
}
inline void RmtDiagRsp::set_diag_dvr(const void* value, size_t size) {
  set_has_diag_dvr();
  if (diag_dvr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_dvr_ = new ::std::string;
  }
  diag_dvr_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RmtDiagRsp.Diag_DVR)
}
inline ::std::string* RmtDiagRsp::mutable_diag_dvr() {
  set_has_diag_dvr();
  if (diag_dvr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_dvr_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RmtDiagRsp.Diag_DVR)
  return diag_dvr_;
}
inline ::std::string* RmtDiagRsp::release_diag_dvr() {
  clear_has_diag_dvr();
  if (diag_dvr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = diag_dvr_;
    diag_dvr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RmtDiagRsp::set_allocated_diag_dvr(::std::string* diag_dvr) {
  if (diag_dvr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_dvr_;
  }
  if (diag_dvr) {
    set_has_diag_dvr();
    diag_dvr_ = diag_dvr;
  } else {
    clear_has_diag_dvr();
    diag_dvr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RmtDiagRsp.Diag_DVR)
}

// optional bytes Diag_VDC = 14;
inline bool RmtDiagRsp::has_diag_vdc() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RmtDiagRsp::set_has_diag_vdc() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RmtDiagRsp::clear_has_diag_vdc() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RmtDiagRsp::clear_diag_vdc() {
  if (diag_vdc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_vdc_->clear();
  }
  clear_has_diag_vdc();
}
inline const ::std::string& RmtDiagRsp::diag_vdc() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RmtDiagRsp.Diag_VDC)
  return *diag_vdc_;
}
inline void RmtDiagRsp::set_diag_vdc(const ::std::string& value) {
  set_has_diag_vdc();
  if (diag_vdc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_vdc_ = new ::std::string;
  }
  diag_vdc_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RmtDiagRsp.Diag_VDC)
}
inline void RmtDiagRsp::set_diag_vdc(const char* value) {
  set_has_diag_vdc();
  if (diag_vdc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_vdc_ = new ::std::string;
  }
  diag_vdc_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RmtDiagRsp.Diag_VDC)
}
inline void RmtDiagRsp::set_diag_vdc(const void* value, size_t size) {
  set_has_diag_vdc();
  if (diag_vdc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_vdc_ = new ::std::string;
  }
  diag_vdc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RmtDiagRsp.Diag_VDC)
}
inline ::std::string* RmtDiagRsp::mutable_diag_vdc() {
  set_has_diag_vdc();
  if (diag_vdc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_vdc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RmtDiagRsp.Diag_VDC)
  return diag_vdc_;
}
inline ::std::string* RmtDiagRsp::release_diag_vdc() {
  clear_has_diag_vdc();
  if (diag_vdc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = diag_vdc_;
    diag_vdc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RmtDiagRsp::set_allocated_diag_vdc(::std::string* diag_vdc) {
  if (diag_vdc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_vdc_;
  }
  if (diag_vdc) {
    set_has_diag_vdc();
    diag_vdc_ = diag_vdc;
  } else {
    clear_has_diag_vdc();
    diag_vdc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RmtDiagRsp.Diag_VDC)
}

// optional bytes Diag_EPS = 15;
inline bool RmtDiagRsp::has_diag_eps() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RmtDiagRsp::set_has_diag_eps() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RmtDiagRsp::clear_has_diag_eps() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RmtDiagRsp::clear_diag_eps() {
  if (diag_eps_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_eps_->clear();
  }
  clear_has_diag_eps();
}
inline const ::std::string& RmtDiagRsp::diag_eps() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RmtDiagRsp.Diag_EPS)
  return *diag_eps_;
}
inline void RmtDiagRsp::set_diag_eps(const ::std::string& value) {
  set_has_diag_eps();
  if (diag_eps_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_eps_ = new ::std::string;
  }
  diag_eps_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RmtDiagRsp.Diag_EPS)
}
inline void RmtDiagRsp::set_diag_eps(const char* value) {
  set_has_diag_eps();
  if (diag_eps_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_eps_ = new ::std::string;
  }
  diag_eps_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RmtDiagRsp.Diag_EPS)
}
inline void RmtDiagRsp::set_diag_eps(const void* value, size_t size) {
  set_has_diag_eps();
  if (diag_eps_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_eps_ = new ::std::string;
  }
  diag_eps_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RmtDiagRsp.Diag_EPS)
}
inline ::std::string* RmtDiagRsp::mutable_diag_eps() {
  set_has_diag_eps();
  if (diag_eps_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_eps_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RmtDiagRsp.Diag_EPS)
  return diag_eps_;
}
inline ::std::string* RmtDiagRsp::release_diag_eps() {
  clear_has_diag_eps();
  if (diag_eps_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = diag_eps_;
    diag_eps_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RmtDiagRsp::set_allocated_diag_eps(::std::string* diag_eps) {
  if (diag_eps_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_eps_;
  }
  if (diag_eps) {
    set_has_diag_eps();
    diag_eps_ = diag_eps;
  } else {
    clear_has_diag_eps();
    diag_eps_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RmtDiagRsp.Diag_EPS)
}

// optional bytes Diag_GW = 16;
inline bool RmtDiagRsp::has_diag_gw() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RmtDiagRsp::set_has_diag_gw() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RmtDiagRsp::clear_has_diag_gw() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RmtDiagRsp::clear_diag_gw() {
  if (diag_gw_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_gw_->clear();
  }
  clear_has_diag_gw();
}
inline const ::std::string& RmtDiagRsp::diag_gw() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RmtDiagRsp.Diag_GW)
  return *diag_gw_;
}
inline void RmtDiagRsp::set_diag_gw(const ::std::string& value) {
  set_has_diag_gw();
  if (diag_gw_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_gw_ = new ::std::string;
  }
  diag_gw_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RmtDiagRsp.Diag_GW)
}
inline void RmtDiagRsp::set_diag_gw(const char* value) {
  set_has_diag_gw();
  if (diag_gw_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_gw_ = new ::std::string;
  }
  diag_gw_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RmtDiagRsp.Diag_GW)
}
inline void RmtDiagRsp::set_diag_gw(const void* value, size_t size) {
  set_has_diag_gw();
  if (diag_gw_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_gw_ = new ::std::string;
  }
  diag_gw_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RmtDiagRsp.Diag_GW)
}
inline ::std::string* RmtDiagRsp::mutable_diag_gw() {
  set_has_diag_gw();
  if (diag_gw_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_gw_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RmtDiagRsp.Diag_GW)
  return diag_gw_;
}
inline ::std::string* RmtDiagRsp::release_diag_gw() {
  clear_has_diag_gw();
  if (diag_gw_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = diag_gw_;
    diag_gw_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RmtDiagRsp::set_allocated_diag_gw(::std::string* diag_gw) {
  if (diag_gw_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_gw_;
  }
  if (diag_gw) {
    set_has_diag_gw();
    diag_gw_ = diag_gw;
  } else {
    clear_has_diag_gw();
    diag_gw_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RmtDiagRsp.Diag_GW)
}

// optional bytes Diag_TPMS = 17;
inline bool RmtDiagRsp::has_diag_tpms() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RmtDiagRsp::set_has_diag_tpms() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RmtDiagRsp::clear_has_diag_tpms() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RmtDiagRsp::clear_diag_tpms() {
  if (diag_tpms_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_tpms_->clear();
  }
  clear_has_diag_tpms();
}
inline const ::std::string& RmtDiagRsp::diag_tpms() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RmtDiagRsp.Diag_TPMS)
  return *diag_tpms_;
}
inline void RmtDiagRsp::set_diag_tpms(const ::std::string& value) {
  set_has_diag_tpms();
  if (diag_tpms_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_tpms_ = new ::std::string;
  }
  diag_tpms_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RmtDiagRsp.Diag_TPMS)
}
inline void RmtDiagRsp::set_diag_tpms(const char* value) {
  set_has_diag_tpms();
  if (diag_tpms_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_tpms_ = new ::std::string;
  }
  diag_tpms_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RmtDiagRsp.Diag_TPMS)
}
inline void RmtDiagRsp::set_diag_tpms(const void* value, size_t size) {
  set_has_diag_tpms();
  if (diag_tpms_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_tpms_ = new ::std::string;
  }
  diag_tpms_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RmtDiagRsp.Diag_TPMS)
}
inline ::std::string* RmtDiagRsp::mutable_diag_tpms() {
  set_has_diag_tpms();
  if (diag_tpms_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_tpms_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RmtDiagRsp.Diag_TPMS)
  return diag_tpms_;
}
inline ::std::string* RmtDiagRsp::release_diag_tpms() {
  clear_has_diag_tpms();
  if (diag_tpms_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = diag_tpms_;
    diag_tpms_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RmtDiagRsp::set_allocated_diag_tpms(::std::string* diag_tpms) {
  if (diag_tpms_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_tpms_;
  }
  if (diag_tpms) {
    set_has_diag_tpms();
    diag_tpms_ = diag_tpms;
  } else {
    clear_has_diag_tpms();
    diag_tpms_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RmtDiagRsp.Diag_TPMS)
}

// optional bytes Diag_METER = 18;
inline bool RmtDiagRsp::has_diag_meter() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void RmtDiagRsp::set_has_diag_meter() {
  _has_bits_[0] |= 0x00020000u;
}
inline void RmtDiagRsp::clear_has_diag_meter() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void RmtDiagRsp::clear_diag_meter() {
  if (diag_meter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_meter_->clear();
  }
  clear_has_diag_meter();
}
inline const ::std::string& RmtDiagRsp::diag_meter() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RmtDiagRsp.Diag_METER)
  return *diag_meter_;
}
inline void RmtDiagRsp::set_diag_meter(const ::std::string& value) {
  set_has_diag_meter();
  if (diag_meter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_meter_ = new ::std::string;
  }
  diag_meter_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RmtDiagRsp.Diag_METER)
}
inline void RmtDiagRsp::set_diag_meter(const char* value) {
  set_has_diag_meter();
  if (diag_meter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_meter_ = new ::std::string;
  }
  diag_meter_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RmtDiagRsp.Diag_METER)
}
inline void RmtDiagRsp::set_diag_meter(const void* value, size_t size) {
  set_has_diag_meter();
  if (diag_meter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_meter_ = new ::std::string;
  }
  diag_meter_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RmtDiagRsp.Diag_METER)
}
inline ::std::string* RmtDiagRsp::mutable_diag_meter() {
  set_has_diag_meter();
  if (diag_meter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_meter_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RmtDiagRsp.Diag_METER)
  return diag_meter_;
}
inline ::std::string* RmtDiagRsp::release_diag_meter() {
  clear_has_diag_meter();
  if (diag_meter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = diag_meter_;
    diag_meter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RmtDiagRsp::set_allocated_diag_meter(::std::string* diag_meter) {
  if (diag_meter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_meter_;
  }
  if (diag_meter) {
    set_has_diag_meter();
    diag_meter_ = diag_meter;
  } else {
    clear_has_diag_meter();
    diag_meter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RmtDiagRsp.Diag_METER)
}

// optional bytes Diag_TCU = 19;
inline bool RmtDiagRsp::has_diag_tcu() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RmtDiagRsp::set_has_diag_tcu() {
  _has_bits_[0] |= 0x00040000u;
}
inline void RmtDiagRsp::clear_has_diag_tcu() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void RmtDiagRsp::clear_diag_tcu() {
  if (diag_tcu_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_tcu_->clear();
  }
  clear_has_diag_tcu();
}
inline const ::std::string& RmtDiagRsp::diag_tcu() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RmtDiagRsp.Diag_TCU)
  return *diag_tcu_;
}
inline void RmtDiagRsp::set_diag_tcu(const ::std::string& value) {
  set_has_diag_tcu();
  if (diag_tcu_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_tcu_ = new ::std::string;
  }
  diag_tcu_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RmtDiagRsp.Diag_TCU)
}
inline void RmtDiagRsp::set_diag_tcu(const char* value) {
  set_has_diag_tcu();
  if (diag_tcu_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_tcu_ = new ::std::string;
  }
  diag_tcu_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RmtDiagRsp.Diag_TCU)
}
inline void RmtDiagRsp::set_diag_tcu(const void* value, size_t size) {
  set_has_diag_tcu();
  if (diag_tcu_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_tcu_ = new ::std::string;
  }
  diag_tcu_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RmtDiagRsp.Diag_TCU)
}
inline ::std::string* RmtDiagRsp::mutable_diag_tcu() {
  set_has_diag_tcu();
  if (diag_tcu_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_tcu_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RmtDiagRsp.Diag_TCU)
  return diag_tcu_;
}
inline ::std::string* RmtDiagRsp::release_diag_tcu() {
  clear_has_diag_tcu();
  if (diag_tcu_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = diag_tcu_;
    diag_tcu_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RmtDiagRsp::set_allocated_diag_tcu(::std::string* diag_tcu) {
  if (diag_tcu_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_tcu_;
  }
  if (diag_tcu) {
    set_has_diag_tcu();
    diag_tcu_ = diag_tcu;
  } else {
    clear_has_diag_tcu();
    diag_tcu_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RmtDiagRsp.Diag_TCU)
}

// optional bytes Diag_ACU = 20;
inline bool RmtDiagRsp::has_diag_acu() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void RmtDiagRsp::set_has_diag_acu() {
  _has_bits_[0] |= 0x00080000u;
}
inline void RmtDiagRsp::clear_has_diag_acu() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void RmtDiagRsp::clear_diag_acu() {
  if (diag_acu_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_acu_->clear();
  }
  clear_has_diag_acu();
}
inline const ::std::string& RmtDiagRsp::diag_acu() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RmtDiagRsp.Diag_ACU)
  return *diag_acu_;
}
inline void RmtDiagRsp::set_diag_acu(const ::std::string& value) {
  set_has_diag_acu();
  if (diag_acu_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_acu_ = new ::std::string;
  }
  diag_acu_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RmtDiagRsp.Diag_ACU)
}
inline void RmtDiagRsp::set_diag_acu(const char* value) {
  set_has_diag_acu();
  if (diag_acu_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_acu_ = new ::std::string;
  }
  diag_acu_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RmtDiagRsp.Diag_ACU)
}
inline void RmtDiagRsp::set_diag_acu(const void* value, size_t size) {
  set_has_diag_acu();
  if (diag_acu_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_acu_ = new ::std::string;
  }
  diag_acu_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RmtDiagRsp.Diag_ACU)
}
inline ::std::string* RmtDiagRsp::mutable_diag_acu() {
  set_has_diag_acu();
  if (diag_acu_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_acu_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RmtDiagRsp.Diag_ACU)
  return diag_acu_;
}
inline ::std::string* RmtDiagRsp::release_diag_acu() {
  clear_has_diag_acu();
  if (diag_acu_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = diag_acu_;
    diag_acu_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RmtDiagRsp::set_allocated_diag_acu(::std::string* diag_acu) {
  if (diag_acu_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_acu_;
  }
  if (diag_acu) {
    set_has_diag_acu();
    diag_acu_ = diag_acu;
  } else {
    clear_has_diag_acu();
    diag_acu_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RmtDiagRsp.Diag_ACU)
}

// optional bytes Diag_DA = 21;
inline bool RmtDiagRsp::has_diag_da() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void RmtDiagRsp::set_has_diag_da() {
  _has_bits_[0] |= 0x00100000u;
}
inline void RmtDiagRsp::clear_has_diag_da() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void RmtDiagRsp::clear_diag_da() {
  if (diag_da_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_da_->clear();
  }
  clear_has_diag_da();
}
inline const ::std::string& RmtDiagRsp::diag_da() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RmtDiagRsp.Diag_DA)
  return *diag_da_;
}
inline void RmtDiagRsp::set_diag_da(const ::std::string& value) {
  set_has_diag_da();
  if (diag_da_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_da_ = new ::std::string;
  }
  diag_da_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.RmtDiagRsp.Diag_DA)
}
inline void RmtDiagRsp::set_diag_da(const char* value) {
  set_has_diag_da();
  if (diag_da_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_da_ = new ::std::string;
  }
  diag_da_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.RmtDiagRsp.Diag_DA)
}
inline void RmtDiagRsp::set_diag_da(const void* value, size_t size) {
  set_has_diag_da();
  if (diag_da_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_da_ = new ::std::string;
  }
  diag_da_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.RmtDiagRsp.Diag_DA)
}
inline ::std::string* RmtDiagRsp::mutable_diag_da() {
  set_has_diag_da();
  if (diag_da_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    diag_da_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.RmtDiagRsp.Diag_DA)
  return diag_da_;
}
inline ::std::string* RmtDiagRsp::release_diag_da() {
  clear_has_diag_da();
  if (diag_da_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = diag_da_;
    diag_da_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RmtDiagRsp::set_allocated_diag_da(::std::string* diag_da) {
  if (diag_da_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_da_;
  }
  if (diag_da) {
    set_has_diag_da();
    diag_da_ = diag_da;
  } else {
    clear_has_diag_da();
    diag_da_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.RmtDiagRsp.Diag_DA)
}

// -------------------------------------------------------------------

// RmtDiagReq

// required uint32 serial_number = 1;
inline bool RmtDiagReq::has_serial_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RmtDiagReq::set_has_serial_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RmtDiagReq::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RmtDiagReq::clear_serial_number() {
  serial_number_ = 0u;
  clear_has_serial_number();
}
inline ::google::protobuf::uint32 RmtDiagReq::serial_number() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RmtDiagReq.serial_number)
  return serial_number_;
}
inline void RmtDiagReq::set_serial_number(::google::protobuf::uint32 value) {
  set_has_serial_number();
  serial_number_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.RmtDiagReq.serial_number)
}

// required uint32 time_stamp = 2;
inline bool RmtDiagReq::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RmtDiagReq::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RmtDiagReq::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RmtDiagReq::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 RmtDiagReq::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.RmtDiagReq.time_stamp)
  return time_stamp_;
}
inline void RmtDiagReq::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.RmtDiagReq.time_stamp)
}

// -------------------------------------------------------------------

// Fault_List_info

// optional uint32 Fault_List_one = 1;
inline bool Fault_List_info::has_fault_list_one() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Fault_List_info::set_has_fault_list_one() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Fault_List_info::clear_has_fault_list_one() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Fault_List_info::clear_fault_list_one() {
  fault_list_one_ = 0u;
  clear_has_fault_list_one();
}
inline ::google::protobuf::uint32 Fault_List_info::fault_list_one() const {
  // @@protoc_insertion_point(field_get:zna.protocol.Fault_List_info.Fault_List_one)
  return fault_list_one_;
}
inline void Fault_List_info::set_fault_list_one(::google::protobuf::uint32 value) {
  set_has_fault_list_one();
  fault_list_one_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.Fault_List_info.Fault_List_one)
}

// -------------------------------------------------------------------

// FourGExtendCmdRsp

// required uint32 serial_number = 1;
inline bool FourGExtendCmdRsp::has_serial_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FourGExtendCmdRsp::set_has_serial_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FourGExtendCmdRsp::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FourGExtendCmdRsp::clear_serial_number() {
  serial_number_ = 0u;
  clear_has_serial_number();
}
inline ::google::protobuf::uint32 FourGExtendCmdRsp::serial_number() const {
  // @@protoc_insertion_point(field_get:zna.protocol.FourGExtendCmdRsp.serial_number)
  return serial_number_;
}
inline void FourGExtendCmdRsp::set_serial_number(::google::protobuf::uint32 value) {
  set_has_serial_number();
  serial_number_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.FourGExtendCmdRsp.serial_number)
}

// required uint32 time_stamp = 2;
inline bool FourGExtendCmdRsp::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FourGExtendCmdRsp::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FourGExtendCmdRsp::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FourGExtendCmdRsp::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 FourGExtendCmdRsp::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.FourGExtendCmdRsp.time_stamp)
  return time_stamp_;
}
inline void FourGExtendCmdRsp::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.FourGExtendCmdRsp.time_stamp)
}

// required uint32 commander_id = 3;
inline bool FourGExtendCmdRsp::has_commander_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FourGExtendCmdRsp::set_has_commander_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FourGExtendCmdRsp::clear_has_commander_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FourGExtendCmdRsp::clear_commander_id() {
  commander_id_ = 0u;
  clear_has_commander_id();
}
inline ::google::protobuf::uint32 FourGExtendCmdRsp::commander_id() const {
  // @@protoc_insertion_point(field_get:zna.protocol.FourGExtendCmdRsp.commander_id)
  return commander_id_;
}
inline void FourGExtendCmdRsp::set_commander_id(::google::protobuf::uint32 value) {
  set_has_commander_id();
  commander_id_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.FourGExtendCmdRsp.commander_id)
}

// required bytes result_info = 4;
inline bool FourGExtendCmdRsp::has_result_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FourGExtendCmdRsp::set_has_result_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FourGExtendCmdRsp::clear_has_result_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FourGExtendCmdRsp::clear_result_info() {
  if (result_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_info_->clear();
  }
  clear_has_result_info();
}
inline const ::std::string& FourGExtendCmdRsp::result_info() const {
  // @@protoc_insertion_point(field_get:zna.protocol.FourGExtendCmdRsp.result_info)
  return *result_info_;
}
inline void FourGExtendCmdRsp::set_result_info(const ::std::string& value) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.FourGExtendCmdRsp.result_info)
}
inline void FourGExtendCmdRsp::set_result_info(const char* value) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.FourGExtendCmdRsp.result_info)
}
inline void FourGExtendCmdRsp::set_result_info(const void* value, size_t size) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.FourGExtendCmdRsp.result_info)
}
inline ::std::string* FourGExtendCmdRsp::mutable_result_info() {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.FourGExtendCmdRsp.result_info)
  return result_info_;
}
inline ::std::string* FourGExtendCmdRsp::release_result_info() {
  clear_has_result_info();
  if (result_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = result_info_;
    result_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FourGExtendCmdRsp::set_allocated_result_info(::std::string* result_info) {
  if (result_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete result_info_;
  }
  if (result_info) {
    set_has_result_info();
    result_info_ = result_info;
  } else {
    clear_has_result_info();
    result_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.FourGExtendCmdRsp.result_info)
}

// -------------------------------------------------------------------

// FourGExtendCmdReq

// required uint32 serial_number = 1;
inline bool FourGExtendCmdReq::has_serial_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FourGExtendCmdReq::set_has_serial_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FourGExtendCmdReq::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FourGExtendCmdReq::clear_serial_number() {
  serial_number_ = 0u;
  clear_has_serial_number();
}
inline ::google::protobuf::uint32 FourGExtendCmdReq::serial_number() const {
  // @@protoc_insertion_point(field_get:zna.protocol.FourGExtendCmdReq.serial_number)
  return serial_number_;
}
inline void FourGExtendCmdReq::set_serial_number(::google::protobuf::uint32 value) {
  set_has_serial_number();
  serial_number_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.FourGExtendCmdReq.serial_number)
}

// required uint32 time_stamp = 2;
inline bool FourGExtendCmdReq::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FourGExtendCmdReq::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FourGExtendCmdReq::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FourGExtendCmdReq::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 FourGExtendCmdReq::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.FourGExtendCmdReq.time_stamp)
  return time_stamp_;
}
inline void FourGExtendCmdReq::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.FourGExtendCmdReq.time_stamp)
}

// required uint32 commander_id = 3;
inline bool FourGExtendCmdReq::has_commander_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FourGExtendCmdReq::set_has_commander_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FourGExtendCmdReq::clear_has_commander_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FourGExtendCmdReq::clear_commander_id() {
  commander_id_ = 0u;
  clear_has_commander_id();
}
inline ::google::protobuf::uint32 FourGExtendCmdReq::commander_id() const {
  // @@protoc_insertion_point(field_get:zna.protocol.FourGExtendCmdReq.commander_id)
  return commander_id_;
}
inline void FourGExtendCmdReq::set_commander_id(::google::protobuf::uint32 value) {
  set_has_commander_id();
  commander_id_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.FourGExtendCmdReq.commander_id)
}

// required bytes result_info = 4;
inline bool FourGExtendCmdReq::has_result_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FourGExtendCmdReq::set_has_result_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FourGExtendCmdReq::clear_has_result_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FourGExtendCmdReq::clear_result_info() {
  if (result_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_info_->clear();
  }
  clear_has_result_info();
}
inline const ::std::string& FourGExtendCmdReq::result_info() const {
  // @@protoc_insertion_point(field_get:zna.protocol.FourGExtendCmdReq.result_info)
  return *result_info_;
}
inline void FourGExtendCmdReq::set_result_info(const ::std::string& value) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.FourGExtendCmdReq.result_info)
}
inline void FourGExtendCmdReq::set_result_info(const char* value) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.FourGExtendCmdReq.result_info)
}
inline void FourGExtendCmdReq::set_result_info(const void* value, size_t size) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.FourGExtendCmdReq.result_info)
}
inline ::std::string* FourGExtendCmdReq::mutable_result_info() {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.FourGExtendCmdReq.result_info)
  return result_info_;
}
inline ::std::string* FourGExtendCmdReq::release_result_info() {
  clear_has_result_info();
  if (result_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = result_info_;
    result_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FourGExtendCmdReq::set_allocated_result_info(::std::string* result_info) {
  if (result_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete result_info_;
  }
  if (result_info) {
    set_has_result_info();
    result_info_ = result_info;
  } else {
    clear_has_result_info();
    result_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.FourGExtendCmdReq.result_info)
}

// -------------------------------------------------------------------

// TCUExtendCmdReq

// required uint32 serial_number = 1;
inline bool TCUExtendCmdReq::has_serial_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TCUExtendCmdReq::set_has_serial_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TCUExtendCmdReq::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TCUExtendCmdReq::clear_serial_number() {
  serial_number_ = 0u;
  clear_has_serial_number();
}
inline ::google::protobuf::uint32 TCUExtendCmdReq::serial_number() const {
  // @@protoc_insertion_point(field_get:zna.protocol.TCUExtendCmdReq.serial_number)
  return serial_number_;
}
inline void TCUExtendCmdReq::set_serial_number(::google::protobuf::uint32 value) {
  set_has_serial_number();
  serial_number_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.TCUExtendCmdReq.serial_number)
}

// required uint32 time_stamp = 2;
inline bool TCUExtendCmdReq::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TCUExtendCmdReq::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TCUExtendCmdReq::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TCUExtendCmdReq::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 TCUExtendCmdReq::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.TCUExtendCmdReq.time_stamp)
  return time_stamp_;
}
inline void TCUExtendCmdReq::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.TCUExtendCmdReq.time_stamp)
}

// required uint32 commander_id = 3;
inline bool TCUExtendCmdReq::has_commander_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TCUExtendCmdReq::set_has_commander_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TCUExtendCmdReq::clear_has_commander_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TCUExtendCmdReq::clear_commander_id() {
  commander_id_ = 0u;
  clear_has_commander_id();
}
inline ::google::protobuf::uint32 TCUExtendCmdReq::commander_id() const {
  // @@protoc_insertion_point(field_get:zna.protocol.TCUExtendCmdReq.commander_id)
  return commander_id_;
}
inline void TCUExtendCmdReq::set_commander_id(::google::protobuf::uint32 value) {
  set_has_commander_id();
  commander_id_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.TCUExtendCmdReq.commander_id)
}

// required bytes result_info = 4;
inline bool TCUExtendCmdReq::has_result_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TCUExtendCmdReq::set_has_result_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TCUExtendCmdReq::clear_has_result_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TCUExtendCmdReq::clear_result_info() {
  if (result_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_info_->clear();
  }
  clear_has_result_info();
}
inline const ::std::string& TCUExtendCmdReq::result_info() const {
  // @@protoc_insertion_point(field_get:zna.protocol.TCUExtendCmdReq.result_info)
  return *result_info_;
}
inline void TCUExtendCmdReq::set_result_info(const ::std::string& value) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.TCUExtendCmdReq.result_info)
}
inline void TCUExtendCmdReq::set_result_info(const char* value) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.TCUExtendCmdReq.result_info)
}
inline void TCUExtendCmdReq::set_result_info(const void* value, size_t size) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.TCUExtendCmdReq.result_info)
}
inline ::std::string* TCUExtendCmdReq::mutable_result_info() {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.TCUExtendCmdReq.result_info)
  return result_info_;
}
inline ::std::string* TCUExtendCmdReq::release_result_info() {
  clear_has_result_info();
  if (result_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = result_info_;
    result_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TCUExtendCmdReq::set_allocated_result_info(::std::string* result_info) {
  if (result_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete result_info_;
  }
  if (result_info) {
    set_has_result_info();
    result_info_ = result_info;
  } else {
    clear_has_result_info();
    result_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.TCUExtendCmdReq.result_info)
}

// -------------------------------------------------------------------

// TCUExtendCmdRsp

// required uint32 serial_number = 1;
inline bool TCUExtendCmdRsp::has_serial_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TCUExtendCmdRsp::set_has_serial_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TCUExtendCmdRsp::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TCUExtendCmdRsp::clear_serial_number() {
  serial_number_ = 0u;
  clear_has_serial_number();
}
inline ::google::protobuf::uint32 TCUExtendCmdRsp::serial_number() const {
  // @@protoc_insertion_point(field_get:zna.protocol.TCUExtendCmdRsp.serial_number)
  return serial_number_;
}
inline void TCUExtendCmdRsp::set_serial_number(::google::protobuf::uint32 value) {
  set_has_serial_number();
  serial_number_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.TCUExtendCmdRsp.serial_number)
}

// required uint32 time_stamp = 2;
inline bool TCUExtendCmdRsp::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TCUExtendCmdRsp::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TCUExtendCmdRsp::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TCUExtendCmdRsp::clear_time_stamp() {
  time_stamp_ = 0u;
  clear_has_time_stamp();
}
inline ::google::protobuf::uint32 TCUExtendCmdRsp::time_stamp() const {
  // @@protoc_insertion_point(field_get:zna.protocol.TCUExtendCmdRsp.time_stamp)
  return time_stamp_;
}
inline void TCUExtendCmdRsp::set_time_stamp(::google::protobuf::uint32 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.TCUExtendCmdRsp.time_stamp)
}

// required uint32 commander_id = 3;
inline bool TCUExtendCmdRsp::has_commander_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TCUExtendCmdRsp::set_has_commander_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TCUExtendCmdRsp::clear_has_commander_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TCUExtendCmdRsp::clear_commander_id() {
  commander_id_ = 0u;
  clear_has_commander_id();
}
inline ::google::protobuf::uint32 TCUExtendCmdRsp::commander_id() const {
  // @@protoc_insertion_point(field_get:zna.protocol.TCUExtendCmdRsp.commander_id)
  return commander_id_;
}
inline void TCUExtendCmdRsp::set_commander_id(::google::protobuf::uint32 value) {
  set_has_commander_id();
  commander_id_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.TCUExtendCmdRsp.commander_id)
}

// required bytes result_info = 4;
inline bool TCUExtendCmdRsp::has_result_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TCUExtendCmdRsp::set_has_result_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TCUExtendCmdRsp::clear_has_result_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TCUExtendCmdRsp::clear_result_info() {
  if (result_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_info_->clear();
  }
  clear_has_result_info();
}
inline const ::std::string& TCUExtendCmdRsp::result_info() const {
  // @@protoc_insertion_point(field_get:zna.protocol.TCUExtendCmdRsp.result_info)
  return *result_info_;
}
inline void TCUExtendCmdRsp::set_result_info(const ::std::string& value) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(value);
  // @@protoc_insertion_point(field_set:zna.protocol.TCUExtendCmdRsp.result_info)
}
inline void TCUExtendCmdRsp::set_result_info(const char* value) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(value);
  // @@protoc_insertion_point(field_set_char:zna.protocol.TCUExtendCmdRsp.result_info)
}
inline void TCUExtendCmdRsp::set_result_info(const void* value, size_t size) {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_info_ = new ::std::string;
  }
  result_info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:zna.protocol.TCUExtendCmdRsp.result_info)
}
inline ::std::string* TCUExtendCmdRsp::mutable_result_info() {
  set_has_result_info();
  if (result_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    result_info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:zna.protocol.TCUExtendCmdRsp.result_info)
  return result_info_;
}
inline ::std::string* TCUExtendCmdRsp::release_result_info() {
  clear_has_result_info();
  if (result_info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = result_info_;
    result_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TCUExtendCmdRsp::set_allocated_result_info(::std::string* result_info) {
  if (result_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete result_info_;
  }
  if (result_info) {
    set_has_result_info();
    result_info_ = result_info;
  } else {
    clear_has_result_info();
    result_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:zna.protocol.TCUExtendCmdRsp.result_info)
}

// -------------------------------------------------------------------

// FCM_Info

// optional uint32 FCM_LKA_Sys_state = 1;
inline bool FCM_Info::has_fcm_lka_sys_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FCM_Info::set_has_fcm_lka_sys_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FCM_Info::clear_has_fcm_lka_sys_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FCM_Info::clear_fcm_lka_sys_state() {
  fcm_lka_sys_state_ = 0u;
  clear_has_fcm_lka_sys_state();
}
inline ::google::protobuf::uint32 FCM_Info::fcm_lka_sys_state() const {
  // @@protoc_insertion_point(field_get:zna.protocol.FCM_Info.FCM_LKA_Sys_state)
  return fcm_lka_sys_state_;
}
inline void FCM_Info::set_fcm_lka_sys_state(::google::protobuf::uint32 value) {
  set_has_fcm_lka_sys_state();
  fcm_lka_sys_state_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.FCM_Info.FCM_LKA_Sys_state)
}

// optional uint32 FCM_ACC_SysFailure = 2;
inline bool FCM_Info::has_fcm_acc_sysfailure() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FCM_Info::set_has_fcm_acc_sysfailure() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FCM_Info::clear_has_fcm_acc_sysfailure() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FCM_Info::clear_fcm_acc_sysfailure() {
  fcm_acc_sysfailure_ = 0u;
  clear_has_fcm_acc_sysfailure();
}
inline ::google::protobuf::uint32 FCM_Info::fcm_acc_sysfailure() const {
  // @@protoc_insertion_point(field_get:zna.protocol.FCM_Info.FCM_ACC_SysFailure)
  return fcm_acc_sysfailure_;
}
inline void FCM_Info::set_fcm_acc_sysfailure(::google::protobuf::uint32 value) {
  set_has_fcm_acc_sysfailure();
  fcm_acc_sysfailure_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.FCM_Info.FCM_ACC_SysFailure)
}

// optional uint32 FCM_AEB_Failinfo = 3;
inline bool FCM_Info::has_fcm_aeb_failinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FCM_Info::set_has_fcm_aeb_failinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FCM_Info::clear_has_fcm_aeb_failinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FCM_Info::clear_fcm_aeb_failinfo() {
  fcm_aeb_failinfo_ = 0u;
  clear_has_fcm_aeb_failinfo();
}
inline ::google::protobuf::uint32 FCM_Info::fcm_aeb_failinfo() const {
  // @@protoc_insertion_point(field_get:zna.protocol.FCM_Info.FCM_AEB_Failinfo)
  return fcm_aeb_failinfo_;
}
inline void FCM_Info::set_fcm_aeb_failinfo(::google::protobuf::uint32 value) {
  set_has_fcm_aeb_failinfo();
  fcm_aeb_failinfo_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.FCM_Info.FCM_AEB_Failinfo)
}

// -------------------------------------------------------------------

// EPS_Info

// optional uint32 EPS_FaultStates = 1;
inline bool EPS_Info::has_eps_faultstates() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EPS_Info::set_has_eps_faultstates() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EPS_Info::clear_has_eps_faultstates() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EPS_Info::clear_eps_faultstates() {
  eps_faultstates_ = 0u;
  clear_has_eps_faultstates();
}
inline ::google::protobuf::uint32 EPS_Info::eps_faultstates() const {
  // @@protoc_insertion_point(field_get:zna.protocol.EPS_Info.EPS_FaultStates)
  return eps_faultstates_;
}
inline void EPS_Info::set_eps_faultstates(::google::protobuf::uint32 value) {
  set_has_eps_faultstates();
  eps_faultstates_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.EPS_Info.EPS_FaultStates)
}

// -------------------------------------------------------------------

// ELD_Info

// optional uint32 ELDFaultSts = 1;
inline bool ELD_Info::has_eldfaultsts() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ELD_Info::set_has_eldfaultsts() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ELD_Info::clear_has_eldfaultsts() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ELD_Info::clear_eldfaultsts() {
  eldfaultsts_ = 0u;
  clear_has_eldfaultsts();
}
inline ::google::protobuf::uint32 ELD_Info::eldfaultsts() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ELD_Info.ELDFaultSts)
  return eldfaultsts_;
}
inline void ELD_Info::set_eldfaultsts(::google::protobuf::uint32 value) {
  set_has_eldfaultsts();
  eldfaultsts_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ELD_Info.ELDFaultSts)
}

// -------------------------------------------------------------------

// ECU_Info

// optional uint32 ECMD_48V_FaultStates = 1;
inline bool ECU_Info::has_ecmd_48v_faultstates() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ECU_Info::set_has_ecmd_48v_faultstates() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ECU_Info::clear_has_ecmd_48v_faultstates() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ECU_Info::clear_ecmd_48v_faultstates() {
  ecmd_48v_faultstates_ = 0u;
  clear_has_ecmd_48v_faultstates();
}
inline ::google::protobuf::uint32 ECU_Info::ecmd_48v_faultstates() const {
  // @@protoc_insertion_point(field_get:zna.protocol.ECU_Info.ECMD_48V_FaultStates)
  return ecmd_48v_faultstates_;
}
inline void ECU_Info::set_ecmd_48v_faultstates(::google::protobuf::uint32 value) {
  set_has_ecmd_48v_faultstates();
  ecmd_48v_faultstates_ = value;
  // @@protoc_insertion_point(field_set:zna.protocol.ECU_Info.ECMD_48V_FaultStates)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace zna

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::zna::protocol::RspCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zna::protocol::RspCode>() {
  return ::zna::protocol::RspCode_descriptor();
}
template <> struct is_proto_enum< ::zna::protocol::UpgradeProgressCodeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zna::protocol::UpgradeProgressCodeType>() {
  return ::zna::protocol::UpgradeProgressCodeType_descriptor();
}
template <> struct is_proto_enum< ::zna::protocol::RmtDiagRspCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zna::protocol::RmtDiagRspCode>() {
  return ::zna::protocol::RmtDiagRspCode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_zna_5fprotocol_5fmessage_2eproto__INCLUDED
