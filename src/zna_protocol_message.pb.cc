// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: zna_protocol_message.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "zna_protocol_message.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace zna {
namespace protocol {

namespace {

const ::google::protobuf::Descriptor* UpgradeInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UpgradeInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* LoginReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LoginReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* LoginRsp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LoginRsp_reflection_ = NULL;
const ::google::protobuf::Descriptor* HeartbeatReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HeartbeatReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* HeartbeatRsp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HeartbeatRsp_reflection_ = NULL;
const ::google::protobuf::Descriptor* SendRSAReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SendRSAReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* SendRC4Rsp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SendRC4Rsp_reflection_ = NULL;
const ::google::protobuf::Descriptor* SetParameterRsp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SetParameterRsp_reflection_ = NULL;
const ::google::protobuf::Descriptor* SetParameterReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SetParameterReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetParameterRsp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetParameterRsp_reflection_ = NULL;
const ::google::protobuf::Descriptor* GetParameterReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GetParameterReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* ECM_Info_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ECM_Info_reflection_ = NULL;
const ::google::protobuf::Descriptor* METER_Info_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  METER_Info_reflection_ = NULL;
const ::google::protobuf::Descriptor* BCM_Info_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BCM_Info_reflection_ = NULL;
const ::google::protobuf::Descriptor* ACU_Info_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ACU_Info_reflection_ = NULL;
const ::google::protobuf::Descriptor* ECO_Info_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ECO_Info_reflection_ = NULL;
const ::google::protobuf::Descriptor* ALARM_Info_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ALARM_Info_reflection_ = NULL;
const ::google::protobuf::Descriptor* PEPS_Info_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PEPS_Info_reflection_ = NULL;
const ::google::protobuf::Descriptor* ESP_Info_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ESP_Info_reflection_ = NULL;
const ::google::protobuf::Descriptor* EPB_Info_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EPB_Info_reflection_ = NULL;
const ::google::protobuf::Descriptor* TCU_Info_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TCU_Info_reflection_ = NULL;
const ::google::protobuf::Descriptor* AWD_Info_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AWD_Info_reflection_ = NULL;
const ::google::protobuf::Descriptor* AC_Info_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AC_Info_reflection_ = NULL;
const ::google::protobuf::Descriptor* SAS_Info_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SAS_Info_reflection_ = NULL;
const ::google::protobuf::Descriptor* Basic_Info_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Basic_Info_reflection_ = NULL;
const ::google::protobuf::Descriptor* Vehicle_Info_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Vehicle_Info_reflection_ = NULL;
const ::google::protobuf::Descriptor* Vehicle_InfoRsp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Vehicle_InfoRsp_reflection_ = NULL;
const ::google::protobuf::Descriptor* Location_Info_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Location_Info_reflection_ = NULL;
const ::google::protobuf::Descriptor* Location_InfoRsp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Location_InfoRsp_reflection_ = NULL;
const ::google::protobuf::Descriptor* RemoteControlResultRsp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RemoteControlResultRsp_reflection_ = NULL;
const ::google::protobuf::Descriptor* RemoteControlReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RemoteControlReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* FlowCountRsp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FlowCountRsp_reflection_ = NULL;
const ::google::protobuf::Descriptor* FlowCountLimitReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FlowCountLimitReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* OtaUpgradeReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OtaUpgradeReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* OtaUpgradeRsp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OtaUpgradeRsp_reflection_ = NULL;
const ::google::protobuf::Descriptor* CancelOtaUpgradeRsp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CancelOtaUpgradeRsp_reflection_ = NULL;
const ::google::protobuf::Descriptor* OtaUpgradeProgressReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OtaUpgradeProgressReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* CertCom_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CertCom_reflection_ = NULL;
const ::google::protobuf::Descriptor* TCUCertApply_Req_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TCUCertApply_Req_reflection_ = NULL;
const ::google::protobuf::Descriptor* TCUCertApply_Rsp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TCUCertApply_Rsp_reflection_ = NULL;
const ::google::protobuf::Descriptor* CertIssue_Req_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CertIssue_Req_reflection_ = NULL;
const ::google::protobuf::Descriptor* CertIssue_Rsp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CertIssue_Rsp_reflection_ = NULL;
const ::google::protobuf::Descriptor* RSALoginReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RSALoginReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* SendRSARsp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SendRSARsp_reflection_ = NULL;
const ::google::protobuf::Descriptor* SendRC4Req_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SendRC4Req_reflection_ = NULL;
const ::google::protobuf::Descriptor* SendRC4Resp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SendRC4Resp_reflection_ = NULL;
const ::google::protobuf::Descriptor* WakeUpDVRRsp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WakeUpDVRRsp_reflection_ = NULL;
const ::google::protobuf::Descriptor* WakeUpDVRReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WakeUpDVRReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* RmtDiagRsp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RmtDiagRsp_reflection_ = NULL;
const ::google::protobuf::Descriptor* RmtDiagReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RmtDiagReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* Fault_List_info_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Fault_List_info_reflection_ = NULL;
const ::google::protobuf::Descriptor* FourGExtendCmdRsp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FourGExtendCmdRsp_reflection_ = NULL;
const ::google::protobuf::Descriptor* FourGExtendCmdReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FourGExtendCmdReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* TCUExtendCmdReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TCUExtendCmdReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* TCUExtendCmdRsp_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TCUExtendCmdRsp_reflection_ = NULL;
const ::google::protobuf::Descriptor* FCM_Info_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FCM_Info_reflection_ = NULL;
const ::google::protobuf::Descriptor* EPS_Info_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  EPS_Info_reflection_ = NULL;
const ::google::protobuf::Descriptor* ELD_Info_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ELD_Info_reflection_ = NULL;
const ::google::protobuf::Descriptor* ECU_Info_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ECU_Info_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* RspCode_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* UpgradeProgressCodeType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* RmtDiagRspCode_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto() {
  protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "zna_protocol_message.proto");
  GOOGLE_CHECK(file != NULL);
  UpgradeInfo_descriptor_ = file->message_type(0);
  static const int UpgradeInfo_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpgradeInfo, filetype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpgradeInfo, filepath_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpgradeInfo, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpgradeInfo, filesize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpgradeInfo, md5_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpgradeInfo, rc4_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpgradeInfo, sign_md5_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpgradeInfo, sha2_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpgradeInfo, aes128_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpgradeInfo, sign_sha2_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpgradeInfo, prefilesize_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpgradeInfo, encrypt_type_),
  };
  UpgradeInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      UpgradeInfo_descriptor_,
      UpgradeInfo::default_instance_,
      UpgradeInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpgradeInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UpgradeInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(UpgradeInfo));
  LoginReq_descriptor_ = file->message_type(1);
  static const int LoginReq_offsets_[14] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginReq, tcu_device_sn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginReq, da_device_sn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginReq, vin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginReq, iccid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginReq, imsi_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginReq, imei_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginReq, software_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginReq, hardware_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginReq, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginReq, g4_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginReq, vehicle_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginReq, upgrading_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginReq, bcm_reg_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginReq, ota_algrithom_),
  };
  LoginReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LoginReq_descriptor_,
      LoginReq::default_instance_,
      LoginReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LoginReq));
  LoginRsp_descriptor_ = file->message_type(2);
  static const int LoginRsp_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginRsp, errcode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginRsp, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginRsp, upgradeinfo_),
  };
  LoginRsp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LoginRsp_descriptor_,
      LoginRsp::default_instance_,
      LoginRsp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginRsp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LoginRsp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LoginRsp));
  HeartbeatReq_descriptor_ = file->message_type(3);
  static const int HeartbeatReq_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatReq, time_stamp_),
  };
  HeartbeatReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HeartbeatReq_descriptor_,
      HeartbeatReq::default_instance_,
      HeartbeatReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HeartbeatReq));
  HeartbeatRsp_descriptor_ = file->message_type(4);
  static const int HeartbeatRsp_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatRsp, errcode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatRsp, time_stamp_),
  };
  HeartbeatRsp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HeartbeatRsp_descriptor_,
      HeartbeatRsp::default_instance_,
      HeartbeatRsp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatRsp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatRsp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HeartbeatRsp));
  SendRSAReq_descriptor_ = file->message_type(5);
  static const int SendRSAReq_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRSAReq, n_len_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRSAReq, n_string_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRSAReq, e1_len_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRSAReq, e1_string_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRSAReq, time_stamp_),
  };
  SendRSAReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SendRSAReq_descriptor_,
      SendRSAReq::default_instance_,
      SendRSAReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRSAReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRSAReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SendRSAReq));
  SendRC4Rsp_descriptor_ = file->message_type(6);
  static const int SendRC4Rsp_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRC4Rsp, errcode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRC4Rsp, serial_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRC4Rsp, time_stamp_),
  };
  SendRC4Rsp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SendRC4Rsp_descriptor_,
      SendRC4Rsp::default_instance_,
      SendRC4Rsp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRC4Rsp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRC4Rsp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SendRC4Rsp));
  SetParameterRsp_descriptor_ = file->message_type(7);
  static const int SetParameterRsp_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetParameterRsp, errcode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetParameterRsp, time_stamp_),
  };
  SetParameterRsp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SetParameterRsp_descriptor_,
      SetParameterRsp::default_instance_,
      SetParameterRsp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetParameterRsp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetParameterRsp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SetParameterRsp));
  SetParameterReq_descriptor_ = file->message_type(8);
  static const int SetParameterReq_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetParameterReq, local_storage_cycle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetParameterReq, upload_data_cycle_normal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetParameterReq, upload_gps_cycle_normal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetParameterReq, upload_data_cycle_alarm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetParameterReq, upload_gps_cycle_alarm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetParameterReq, heartbeat_cycle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetParameterReq, server_response_timeout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetParameterReq, box_response_timeout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetParameterReq, flowcontrolswitch_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetParameterReq, gpsconversion_),
  };
  SetParameterReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SetParameterReq_descriptor_,
      SetParameterReq::default_instance_,
      SetParameterReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetParameterReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SetParameterReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SetParameterReq));
  GetParameterRsp_descriptor_ = file->message_type(9);
  static const int GetParameterRsp_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetParameterRsp, errcode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetParameterRsp, local_storage_cycle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetParameterRsp, upload_data_cycle_normal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetParameterRsp, upload_gps_cycle_normal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetParameterRsp, upload_data_cycle_alarm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetParameterRsp, upload_gps_cycle_alarm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetParameterRsp, heartbeat_cycle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetParameterRsp, server_response_timeout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetParameterRsp, box_response_timeout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetParameterRsp, firmware_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetParameterRsp, hardware_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetParameterRsp, time_stamp_),
  };
  GetParameterRsp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetParameterRsp_descriptor_,
      GetParameterRsp::default_instance_,
      GetParameterRsp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetParameterRsp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetParameterRsp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetParameterRsp));
  GetParameterReq_descriptor_ = file->message_type(10);
  static const int GetParameterReq_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetParameterReq, time_stamp_),
  };
  GetParameterReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GetParameterReq_descriptor_,
      GetParameterReq::default_instance_,
      GetParameterReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetParameterReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GetParameterReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GetParameterReq));
  ECM_Info_descriptor_ = file->message_type(11);
  static const int ECM_Info_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECM_Info, enginerpm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECM_Info, enginestatus_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECM_Info, enginecoolanttemp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECM_Info, millamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECM_Info, svslamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECM_Info, oilpress_lamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECM_Info, urealamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECM_Info, filterwater_det_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECM_Info, batterycharge_sts_),
  };
  ECM_Info_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ECM_Info_descriptor_,
      ECM_Info::default_instance_,
      ECM_Info_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECM_Info, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECM_Info, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ECM_Info));
  METER_Info_descriptor_ = file->message_type(12);
  static const int METER_Info_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(METER_Info, average_fuel_economy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(METER_Info, distance_to_empty_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(METER_Info, distance_totalizer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(METER_Info, fuel_remain_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(METER_Info, totalodo_valid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(METER_Info, oilpres_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(METER_Info, brakefailure_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(METER_Info, instandfuel_),
  };
  METER_Info_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      METER_Info_descriptor_,
      METER_Info::default_instance_,
      METER_Info_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(METER_Info, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(METER_Info, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(METER_Info));
  BCM_Info_descriptor_ = file->message_type(13);
  static const int BCM_Info_offsets_[19] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BCM_Info, front_left_door_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BCM_Info, front_right_door_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BCM_Info, rear_left_door_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BCM_Info, rear_right_door_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BCM_Info, back_door_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BCM_Info, back_door_locked_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BCM_Info, lowbeamrequest_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BCM_Info, highbeamrequest_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BCM_Info, swiigk_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BCM_Info, dooropen_warning_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BCM_Info, lighton_warning_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BCM_Info, tpmsmil_req_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BCM_Info, stoplampfailsts_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BCM_Info, remotevecsearchsts_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BCM_Info, driverdoorlocksts_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BCM_Info, keyalarmsts_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BCM_Info, hoodstatus_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BCM_Info, accstatus_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BCM_Info, remote_enging_run_flag_),
  };
  BCM_Info_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      BCM_Info_descriptor_,
      BCM_Info::default_instance_,
      BCM_Info_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BCM_Info, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BCM_Info, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(BCM_Info));
  ACU_Info_descriptor_ = file->message_type(14);
  static const int ACU_Info_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACU_Info, airbag_crash_order_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACU_Info, airbagfail_sts_),
  };
  ACU_Info_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ACU_Info_descriptor_,
      ACU_Info::default_instance_,
      ACU_Info_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACU_Info, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ACU_Info, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ACU_Info));
  ECO_Info_descriptor_ = file->message_type(15);
  static const int ECO_Info_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECO_Info, rapid_acceleration_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECO_Info, rapid_deceleration_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECO_Info, sharp_turn_count_),
  };
  ECO_Info_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ECO_Info_descriptor_,
      ECO_Info::default_instance_,
      ECO_Info_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECO_Info, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECO_Info, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ECO_Info));
  ALARM_Info_descriptor_ = file->message_type(16);
  static const int ALARM_Info_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ALARM_Info, alarm_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ALARM_Info, alarm_typeex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ALARM_Info, transmitter_fail_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ALARM_Info, lowtirepressure_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ALARM_Info, zna_p15mc_),
  };
  ALARM_Info_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ALARM_Info_descriptor_,
      ALARM_Info::default_instance_,
      ALARM_Info_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ALARM_Info, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ALARM_Info, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ALARM_Info));
  PEPS_Info_descriptor_ = file->message_type(17);
  static const int PEPS_Info_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PEPS_Info, remotefeedback_sts_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PEPS_Info, remotepeps_mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PEPS_Info, remoteenginerun_cnt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PEPS_Info, peps_pdu_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PEPS_Info, peps_bluetooth_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PEPS_Info, peps_meteralarm_),
  };
  PEPS_Info_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PEPS_Info_descriptor_,
      PEPS_Info::default_instance_,
      PEPS_Info_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PEPS_Info, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PEPS_Info, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PEPS_Info));
  ESP_Info_descriptor_ = file->message_type(18);
  static const int ESP_Info_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ESP_Info, esp_lamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ESP_Info, abs_lamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ESP_Info, haz_active_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ESP_Info, vehiclespeed_valid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ESP_Info, longaccel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ESP_Info, vehiclespeed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ESP_Info, ebd_lamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ESP_Info, abs_acitve_),
  };
  ESP_Info_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ESP_Info_descriptor_,
      ESP_Info::default_instance_,
      ESP_Info_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ESP_Info, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ESP_Info, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ESP_Info));
  EPB_Info_descriptor_ = file->message_type(19);
  static const int EPB_Info_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EPB_Info, epb_failstatus_),
  };
  EPB_Info_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EPB_Info_descriptor_,
      EPB_Info::default_instance_,
      EPB_Info_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EPB_Info, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EPB_Info, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EPB_Info));
  TCU_Info_descriptor_ = file->message_type(20);
  static const int TCU_Info_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCU_Info, tcu_fault_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCU_Info, gearselect_pos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCU_Info, driving_mode_),
  };
  TCU_Info_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TCU_Info_descriptor_,
      TCU_Info::default_instance_,
      TCU_Info_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCU_Info, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCU_Info, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TCU_Info));
  AWD_Info_descriptor_ = file->message_type(21);
  static const int AWD_Info_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AWD_Info, awd_mode_),
  };
  AWD_Info_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AWD_Info_descriptor_,
      AWD_Info::default_instance_,
      AWD_Info_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AWD_Info, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AWD_Info, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AWD_Info));
  AC_Info_descriptor_ = file->message_type(22);
  static const int AC_Info_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AC_Info, ac_onstate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AC_Info, airdistribution_mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AC_Info, acinsidesen_temp_),
  };
  AC_Info_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AC_Info_descriptor_,
      AC_Info::default_instance_,
      AC_Info_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AC_Info, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AC_Info, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AC_Info));
  SAS_Info_descriptor_ = file->message_type(23);
  static const int SAS_Info_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SAS_Info, steeringangel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SAS_Info, steeringangel_velocity_),
  };
  SAS_Info_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SAS_Info_descriptor_,
      SAS_Info::default_instance_,
      SAS_Info_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SAS_Info, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SAS_Info, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SAS_Info));
  Basic_Info_descriptor_ = file->message_type(24);
  static const int Basic_Info_offsets_[17] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Basic_Info, ecm_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Basic_Info, meter_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Basic_Info, bcm_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Basic_Info, acu_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Basic_Info, eco_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Basic_Info, alarm_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Basic_Info, peps_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Basic_Info, esp_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Basic_Info, epb_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Basic_Info, tcu_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Basic_Info, awd_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Basic_Info, ac_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Basic_Info, sas_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Basic_Info, fcm_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Basic_Info, eps_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Basic_Info, eld_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Basic_Info, ecu_info_),
  };
  Basic_Info_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Basic_Info_descriptor_,
      Basic_Info::default_instance_,
      Basic_Info_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Basic_Info, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Basic_Info, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Basic_Info));
  Vehicle_Info_descriptor_ = file->message_type(25);
  static const int Vehicle_Info_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vehicle_Info, info_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vehicle_Info, collect_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vehicle_Info, basic_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vehicle_Info, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vehicle_Info, ignontag_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vehicle_Info, ef82_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vehicle_Info, version_),
  };
  Vehicle_Info_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Vehicle_Info_descriptor_,
      Vehicle_Info::default_instance_,
      Vehicle_Info_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vehicle_Info, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vehicle_Info, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Vehicle_Info));
  Vehicle_InfoRsp_descriptor_ = file->message_type(26);
  static const int Vehicle_InfoRsp_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vehicle_InfoRsp, errcode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vehicle_InfoRsp, time_stamp_),
  };
  Vehicle_InfoRsp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Vehicle_InfoRsp_descriptor_,
      Vehicle_InfoRsp::default_instance_,
      Vehicle_InfoRsp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vehicle_InfoRsp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Vehicle_InfoRsp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Vehicle_InfoRsp));
  Location_Info_descriptor_ = file->message_type(27);
  static const int Location_Info_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location_Info, info_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location_Info, location_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location_Info, longitude_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location_Info, latitude_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location_Info, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location_Info, isgpsconversion_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location_Info, gps_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location_Info, height_valid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location_Info, height_data_),
  };
  Location_Info_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Location_Info_descriptor_,
      Location_Info::default_instance_,
      Location_Info_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location_Info, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location_Info, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Location_Info));
  Location_InfoRsp_descriptor_ = file->message_type(28);
  static const int Location_InfoRsp_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location_InfoRsp, errcode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location_InfoRsp, time_stamp_),
  };
  Location_InfoRsp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Location_InfoRsp_descriptor_,
      Location_InfoRsp::default_instance_,
      Location_InfoRsp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location_InfoRsp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Location_InfoRsp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Location_InfoRsp));
  RemoteControlResultRsp_descriptor_ = file->message_type(29);
  static const int RemoteControlResultRsp_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RemoteControlResultRsp, control_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RemoteControlResultRsp, control_value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RemoteControlResultRsp, serial_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RemoteControlResultRsp, control_result_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RemoteControlResultRsp, time_stamp_),
  };
  RemoteControlResultRsp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RemoteControlResultRsp_descriptor_,
      RemoteControlResultRsp::default_instance_,
      RemoteControlResultRsp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RemoteControlResultRsp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RemoteControlResultRsp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RemoteControlResultRsp));
  RemoteControlReq_descriptor_ = file->message_type(30);
  static const int RemoteControlReq_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RemoteControlReq, control_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RemoteControlReq, control_value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RemoteControlReq, serial_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RemoteControlReq, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RemoteControlReq, signal_data_),
  };
  RemoteControlReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RemoteControlReq_descriptor_,
      RemoteControlReq::default_instance_,
      RemoteControlReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RemoteControlReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RemoteControlReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RemoteControlReq));
  FlowCountRsp_descriptor_ = file->message_type(31);
  static const int FlowCountRsp_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FlowCountRsp, dataallowance_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FlowCountRsp, datausage_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FlowCountRsp, dataavailable_),
  };
  FlowCountRsp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FlowCountRsp_descriptor_,
      FlowCountRsp::default_instance_,
      FlowCountRsp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FlowCountRsp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FlowCountRsp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FlowCountRsp));
  FlowCountLimitReq_descriptor_ = file->message_type(32);
  static const int FlowCountLimitReq_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FlowCountLimitReq, limitval_),
  };
  FlowCountLimitReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FlowCountLimitReq_descriptor_,
      FlowCountLimitReq::default_instance_,
      FlowCountLimitReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FlowCountLimitReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FlowCountLimitReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FlowCountLimitReq));
  OtaUpgradeReq_descriptor_ = file->message_type(33);
  static const int OtaUpgradeReq_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OtaUpgradeReq, upgradeinfo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OtaUpgradeReq, serial_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OtaUpgradeReq, time_stamp_),
  };
  OtaUpgradeReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      OtaUpgradeReq_descriptor_,
      OtaUpgradeReq::default_instance_,
      OtaUpgradeReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OtaUpgradeReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OtaUpgradeReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(OtaUpgradeReq));
  OtaUpgradeRsp_descriptor_ = file->message_type(34);
  static const int OtaUpgradeRsp_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OtaUpgradeRsp, errcode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OtaUpgradeRsp, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OtaUpgradeRsp, serial_number_),
  };
  OtaUpgradeRsp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      OtaUpgradeRsp_descriptor_,
      OtaUpgradeRsp::default_instance_,
      OtaUpgradeRsp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OtaUpgradeRsp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OtaUpgradeRsp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(OtaUpgradeRsp));
  CancelOtaUpgradeRsp_descriptor_ = file->message_type(35);
  static const int CancelOtaUpgradeRsp_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CancelOtaUpgradeRsp, errcode_),
  };
  CancelOtaUpgradeRsp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CancelOtaUpgradeRsp_descriptor_,
      CancelOtaUpgradeRsp::default_instance_,
      CancelOtaUpgradeRsp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CancelOtaUpgradeRsp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CancelOtaUpgradeRsp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CancelOtaUpgradeRsp));
  OtaUpgradeProgressReq_descriptor_ = file->message_type(36);
  static const int OtaUpgradeProgressReq_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OtaUpgradeProgressReq, upgradeprogresscode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OtaUpgradeProgressReq, errcode_),
  };
  OtaUpgradeProgressReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      OtaUpgradeProgressReq_descriptor_,
      OtaUpgradeProgressReq::default_instance_,
      OtaUpgradeProgressReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OtaUpgradeProgressReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OtaUpgradeProgressReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(OtaUpgradeProgressReq));
  CertCom_descriptor_ = file->message_type(37);
  static const int CertCom_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CertCom, serial_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CertCom, cur_cert_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CertCom, data_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CertCom, cmd_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CertCom, dcm_no_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CertCom, errcode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CertCom, data_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CertCom, sign_data_),
  };
  CertCom_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CertCom_descriptor_,
      CertCom::default_instance_,
      CertCom_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CertCom, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CertCom, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CertCom));
  TCUCertApply_Req_descriptor_ = file->message_type(38);
  static const int TCUCertApply_Req_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUCertApply_Req, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUCertApply_Req, vin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUCertApply_Req, cert_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUCertApply_Req, duration_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUCertApply_Req, p10_csr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUCertApply_Req, cst_sign_data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUCertApply_Req, cert_format_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUCertApply_Req, sign_type_),
  };
  TCUCertApply_Req_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TCUCertApply_Req_descriptor_,
      TCUCertApply_Req::default_instance_,
      TCUCertApply_Req_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUCertApply_Req, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUCertApply_Req, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TCUCertApply_Req));
  TCUCertApply_Rsp_descriptor_ = file->message_type(39);
  static const int TCUCertApply_Rsp_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUCertApply_Rsp, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUCertApply_Rsp, recv_status_),
  };
  TCUCertApply_Rsp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TCUCertApply_Rsp_descriptor_,
      TCUCertApply_Rsp::default_instance_,
      TCUCertApply_Rsp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUCertApply_Rsp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUCertApply_Rsp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TCUCertApply_Rsp));
  CertIssue_Req_descriptor_ = file->message_type(40);
  static const int CertIssue_Req_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CertIssue_Req, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CertIssue_Req, cert_apply_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CertIssue_Req, apply_cert_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CertIssue_Req, cert_data_),
  };
  CertIssue_Req_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CertIssue_Req_descriptor_,
      CertIssue_Req::default_instance_,
      CertIssue_Req_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CertIssue_Req, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CertIssue_Req, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CertIssue_Req));
  CertIssue_Rsp_descriptor_ = file->message_type(41);
  static const int CertIssue_Rsp_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CertIssue_Rsp, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CertIssue_Rsp, cert_recv_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CertIssue_Rsp, apply_cert_id_),
  };
  CertIssue_Rsp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CertIssue_Rsp_descriptor_,
      CertIssue_Rsp::default_instance_,
      CertIssue_Rsp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CertIssue_Rsp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CertIssue_Rsp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CertIssue_Rsp));
  RSALoginReq_descriptor_ = file->message_type(42);
  static const int RSALoginReq_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RSALoginReq, tcu_device_sn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RSALoginReq, imsi_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RSALoginReq, imei_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RSALoginReq, software_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RSALoginReq, hardware_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RSALoginReq, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RSALoginReq, g4_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RSALoginReq, vehicle_type_),
  };
  RSALoginReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RSALoginReq_descriptor_,
      RSALoginReq::default_instance_,
      RSALoginReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RSALoginReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RSALoginReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RSALoginReq));
  SendRSARsp_descriptor_ = file->message_type(43);
  static const int SendRSARsp_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRSARsp, errcode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRSARsp, n_len_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRSARsp, n_string_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRSARsp, e1_len_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRSARsp, e1_string_),
  };
  SendRSARsp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SendRSARsp_descriptor_,
      SendRSARsp::default_instance_,
      SendRSARsp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRSARsp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRSARsp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SendRSARsp));
  SendRC4Req_descriptor_ = file->message_type(44);
  static const int SendRC4Req_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRC4Req, da_device_sn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRC4Req, vin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRC4Req, iccid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRC4Req, serial_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRC4Req, key_len_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRC4Req, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRC4Req, upgrading_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRC4Req, bcm_reg_status_),
  };
  SendRC4Req_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SendRC4Req_descriptor_,
      SendRC4Req::default_instance_,
      SendRC4Req_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRC4Req, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRC4Req, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SendRC4Req));
  SendRC4Resp_descriptor_ = file->message_type(45);
  static const int SendRC4Resp_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRC4Resp, errcode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRC4Resp, serial_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRC4Resp, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRC4Resp, upgradeinfo_),
  };
  SendRC4Resp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SendRC4Resp_descriptor_,
      SendRC4Resp::default_instance_,
      SendRC4Resp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRC4Resp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SendRC4Resp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SendRC4Resp));
  WakeUpDVRRsp_descriptor_ = file->message_type(46);
  static const int WakeUpDVRRsp_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WakeUpDVRRsp, serial_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WakeUpDVRRsp, control_result_),
  };
  WakeUpDVRRsp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WakeUpDVRRsp_descriptor_,
      WakeUpDVRRsp::default_instance_,
      WakeUpDVRRsp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WakeUpDVRRsp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WakeUpDVRRsp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WakeUpDVRRsp));
  WakeUpDVRReq_descriptor_ = file->message_type(47);
  static const int WakeUpDVRReq_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WakeUpDVRReq, serial_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WakeUpDVRReq, time_stamp_),
  };
  WakeUpDVRReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WakeUpDVRReq_descriptor_,
      WakeUpDVRReq::default_instance_,
      WakeUpDVRReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WakeUpDVRReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WakeUpDVRReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WakeUpDVRReq));
  RmtDiagRsp_descriptor_ = file->message_type(48);
  static const int RmtDiagRsp_offsets_[21] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagRsp, result_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagRsp, serial_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagRsp, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagRsp, diag_avm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagRsp, diag_sonar_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagRsp, diag_bsw_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagRsp, diag_ecm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagRsp, diag_tcm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagRsp, diag_usm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagRsp, diag_bcm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagRsp, diag_feb_camera_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagRsp, diag_feb_radar_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagRsp, diag_dvr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagRsp, diag_vdc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagRsp, diag_eps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagRsp, diag_gw_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagRsp, diag_tpms_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagRsp, diag_meter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagRsp, diag_tcu_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagRsp, diag_acu_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagRsp, diag_da_),
  };
  RmtDiagRsp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RmtDiagRsp_descriptor_,
      RmtDiagRsp::default_instance_,
      RmtDiagRsp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagRsp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagRsp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RmtDiagRsp));
  RmtDiagReq_descriptor_ = file->message_type(49);
  static const int RmtDiagReq_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagReq, serial_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagReq, time_stamp_),
  };
  RmtDiagReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RmtDiagReq_descriptor_,
      RmtDiagReq::default_instance_,
      RmtDiagReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RmtDiagReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RmtDiagReq));
  Fault_List_info_descriptor_ = file->message_type(50);
  static const int Fault_List_info_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Fault_List_info, fault_list_one_),
  };
  Fault_List_info_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Fault_List_info_descriptor_,
      Fault_List_info::default_instance_,
      Fault_List_info_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Fault_List_info, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Fault_List_info, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Fault_List_info));
  FourGExtendCmdRsp_descriptor_ = file->message_type(51);
  static const int FourGExtendCmdRsp_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FourGExtendCmdRsp, serial_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FourGExtendCmdRsp, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FourGExtendCmdRsp, commander_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FourGExtendCmdRsp, result_info_),
  };
  FourGExtendCmdRsp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FourGExtendCmdRsp_descriptor_,
      FourGExtendCmdRsp::default_instance_,
      FourGExtendCmdRsp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FourGExtendCmdRsp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FourGExtendCmdRsp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FourGExtendCmdRsp));
  FourGExtendCmdReq_descriptor_ = file->message_type(52);
  static const int FourGExtendCmdReq_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FourGExtendCmdReq, serial_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FourGExtendCmdReq, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FourGExtendCmdReq, commander_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FourGExtendCmdReq, result_info_),
  };
  FourGExtendCmdReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FourGExtendCmdReq_descriptor_,
      FourGExtendCmdReq::default_instance_,
      FourGExtendCmdReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FourGExtendCmdReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FourGExtendCmdReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FourGExtendCmdReq));
  TCUExtendCmdReq_descriptor_ = file->message_type(53);
  static const int TCUExtendCmdReq_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUExtendCmdReq, serial_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUExtendCmdReq, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUExtendCmdReq, commander_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUExtendCmdReq, result_info_),
  };
  TCUExtendCmdReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TCUExtendCmdReq_descriptor_,
      TCUExtendCmdReq::default_instance_,
      TCUExtendCmdReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUExtendCmdReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUExtendCmdReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TCUExtendCmdReq));
  TCUExtendCmdRsp_descriptor_ = file->message_type(54);
  static const int TCUExtendCmdRsp_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUExtendCmdRsp, serial_number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUExtendCmdRsp, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUExtendCmdRsp, commander_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUExtendCmdRsp, result_info_),
  };
  TCUExtendCmdRsp_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TCUExtendCmdRsp_descriptor_,
      TCUExtendCmdRsp::default_instance_,
      TCUExtendCmdRsp_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUExtendCmdRsp, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TCUExtendCmdRsp, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TCUExtendCmdRsp));
  FCM_Info_descriptor_ = file->message_type(55);
  static const int FCM_Info_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FCM_Info, fcm_lka_sys_state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FCM_Info, fcm_acc_sysfailure_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FCM_Info, fcm_aeb_failinfo_),
  };
  FCM_Info_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FCM_Info_descriptor_,
      FCM_Info::default_instance_,
      FCM_Info_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FCM_Info, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FCM_Info, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FCM_Info));
  EPS_Info_descriptor_ = file->message_type(56);
  static const int EPS_Info_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EPS_Info, eps_faultstates_),
  };
  EPS_Info_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      EPS_Info_descriptor_,
      EPS_Info::default_instance_,
      EPS_Info_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EPS_Info, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(EPS_Info, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(EPS_Info));
  ELD_Info_descriptor_ = file->message_type(57);
  static const int ELD_Info_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ELD_Info, eldfaultsts_),
  };
  ELD_Info_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ELD_Info_descriptor_,
      ELD_Info::default_instance_,
      ELD_Info_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ELD_Info, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ELD_Info, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ELD_Info));
  ECU_Info_descriptor_ = file->message_type(58);
  static const int ECU_Info_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECU_Info, ecmd_48v_faultstates_),
  };
  ECU_Info_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ECU_Info_descriptor_,
      ECU_Info::default_instance_,
      ECU_Info_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECU_Info, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ECU_Info, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ECU_Info));
  RspCode_descriptor_ = file->enum_type(0);
  UpgradeProgressCodeType_descriptor_ = file->enum_type(1);
  RmtDiagRspCode_descriptor_ = file->enum_type(2);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_zna_5fprotocol_5fmessage_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    UpgradeInfo_descriptor_, &UpgradeInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LoginReq_descriptor_, &LoginReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LoginRsp_descriptor_, &LoginRsp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HeartbeatReq_descriptor_, &HeartbeatReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HeartbeatRsp_descriptor_, &HeartbeatRsp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SendRSAReq_descriptor_, &SendRSAReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SendRC4Rsp_descriptor_, &SendRC4Rsp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SetParameterRsp_descriptor_, &SetParameterRsp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SetParameterReq_descriptor_, &SetParameterReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetParameterRsp_descriptor_, &GetParameterRsp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GetParameterReq_descriptor_, &GetParameterReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ECM_Info_descriptor_, &ECM_Info::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    METER_Info_descriptor_, &METER_Info::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    BCM_Info_descriptor_, &BCM_Info::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ACU_Info_descriptor_, &ACU_Info::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ECO_Info_descriptor_, &ECO_Info::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ALARM_Info_descriptor_, &ALARM_Info::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PEPS_Info_descriptor_, &PEPS_Info::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ESP_Info_descriptor_, &ESP_Info::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EPB_Info_descriptor_, &EPB_Info::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TCU_Info_descriptor_, &TCU_Info::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AWD_Info_descriptor_, &AWD_Info::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AC_Info_descriptor_, &AC_Info::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SAS_Info_descriptor_, &SAS_Info::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Basic_Info_descriptor_, &Basic_Info::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Vehicle_Info_descriptor_, &Vehicle_Info::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Vehicle_InfoRsp_descriptor_, &Vehicle_InfoRsp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Location_Info_descriptor_, &Location_Info::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Location_InfoRsp_descriptor_, &Location_InfoRsp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RemoteControlResultRsp_descriptor_, &RemoteControlResultRsp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RemoteControlReq_descriptor_, &RemoteControlReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FlowCountRsp_descriptor_, &FlowCountRsp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FlowCountLimitReq_descriptor_, &FlowCountLimitReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    OtaUpgradeReq_descriptor_, &OtaUpgradeReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    OtaUpgradeRsp_descriptor_, &OtaUpgradeRsp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CancelOtaUpgradeRsp_descriptor_, &CancelOtaUpgradeRsp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    OtaUpgradeProgressReq_descriptor_, &OtaUpgradeProgressReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CertCom_descriptor_, &CertCom::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TCUCertApply_Req_descriptor_, &TCUCertApply_Req::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TCUCertApply_Rsp_descriptor_, &TCUCertApply_Rsp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CertIssue_Req_descriptor_, &CertIssue_Req::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CertIssue_Rsp_descriptor_, &CertIssue_Rsp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RSALoginReq_descriptor_, &RSALoginReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SendRSARsp_descriptor_, &SendRSARsp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SendRC4Req_descriptor_, &SendRC4Req::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SendRC4Resp_descriptor_, &SendRC4Resp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WakeUpDVRRsp_descriptor_, &WakeUpDVRRsp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WakeUpDVRReq_descriptor_, &WakeUpDVRReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RmtDiagRsp_descriptor_, &RmtDiagRsp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RmtDiagReq_descriptor_, &RmtDiagReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Fault_List_info_descriptor_, &Fault_List_info::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FourGExtendCmdRsp_descriptor_, &FourGExtendCmdRsp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FourGExtendCmdReq_descriptor_, &FourGExtendCmdReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TCUExtendCmdReq_descriptor_, &TCUExtendCmdReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TCUExtendCmdRsp_descriptor_, &TCUExtendCmdRsp::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FCM_Info_descriptor_, &FCM_Info::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    EPS_Info_descriptor_, &EPS_Info::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ELD_Info_descriptor_, &ELD_Info::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ECU_Info_descriptor_, &ECU_Info::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto() {
  delete UpgradeInfo::default_instance_;
  delete UpgradeInfo_reflection_;
  delete LoginReq::default_instance_;
  delete LoginReq_reflection_;
  delete LoginRsp::default_instance_;
  delete LoginRsp_reflection_;
  delete HeartbeatReq::default_instance_;
  delete HeartbeatReq_reflection_;
  delete HeartbeatRsp::default_instance_;
  delete HeartbeatRsp_reflection_;
  delete SendRSAReq::default_instance_;
  delete SendRSAReq_reflection_;
  delete SendRC4Rsp::default_instance_;
  delete SendRC4Rsp_reflection_;
  delete SetParameterRsp::default_instance_;
  delete SetParameterRsp_reflection_;
  delete SetParameterReq::default_instance_;
  delete SetParameterReq_reflection_;
  delete GetParameterRsp::default_instance_;
  delete GetParameterRsp_reflection_;
  delete GetParameterReq::default_instance_;
  delete GetParameterReq_reflection_;
  delete ECM_Info::default_instance_;
  delete ECM_Info_reflection_;
  delete METER_Info::default_instance_;
  delete METER_Info_reflection_;
  delete BCM_Info::default_instance_;
  delete BCM_Info_reflection_;
  delete ACU_Info::default_instance_;
  delete ACU_Info_reflection_;
  delete ECO_Info::default_instance_;
  delete ECO_Info_reflection_;
  delete ALARM_Info::default_instance_;
  delete ALARM_Info_reflection_;
  delete PEPS_Info::default_instance_;
  delete PEPS_Info_reflection_;
  delete ESP_Info::default_instance_;
  delete ESP_Info_reflection_;
  delete EPB_Info::default_instance_;
  delete EPB_Info_reflection_;
  delete TCU_Info::default_instance_;
  delete TCU_Info_reflection_;
  delete AWD_Info::default_instance_;
  delete AWD_Info_reflection_;
  delete AC_Info::default_instance_;
  delete AC_Info_reflection_;
  delete SAS_Info::default_instance_;
  delete SAS_Info_reflection_;
  delete Basic_Info::default_instance_;
  delete Basic_Info_reflection_;
  delete Vehicle_Info::default_instance_;
  delete Vehicle_Info_reflection_;
  delete Vehicle_InfoRsp::default_instance_;
  delete Vehicle_InfoRsp_reflection_;
  delete Location_Info::default_instance_;
  delete Location_Info_reflection_;
  delete Location_InfoRsp::default_instance_;
  delete Location_InfoRsp_reflection_;
  delete RemoteControlResultRsp::default_instance_;
  delete RemoteControlResultRsp_reflection_;
  delete RemoteControlReq::default_instance_;
  delete RemoteControlReq_reflection_;
  delete FlowCountRsp::default_instance_;
  delete FlowCountRsp_reflection_;
  delete FlowCountLimitReq::default_instance_;
  delete FlowCountLimitReq_reflection_;
  delete OtaUpgradeReq::default_instance_;
  delete OtaUpgradeReq_reflection_;
  delete OtaUpgradeRsp::default_instance_;
  delete OtaUpgradeRsp_reflection_;
  delete CancelOtaUpgradeRsp::default_instance_;
  delete CancelOtaUpgradeRsp_reflection_;
  delete OtaUpgradeProgressReq::default_instance_;
  delete OtaUpgradeProgressReq_reflection_;
  delete CertCom::default_instance_;
  delete CertCom_reflection_;
  delete TCUCertApply_Req::default_instance_;
  delete TCUCertApply_Req_reflection_;
  delete TCUCertApply_Rsp::default_instance_;
  delete TCUCertApply_Rsp_reflection_;
  delete CertIssue_Req::default_instance_;
  delete CertIssue_Req_reflection_;
  delete CertIssue_Rsp::default_instance_;
  delete CertIssue_Rsp_reflection_;
  delete RSALoginReq::default_instance_;
  delete RSALoginReq_reflection_;
  delete SendRSARsp::default_instance_;
  delete SendRSARsp_reflection_;
  delete SendRC4Req::default_instance_;
  delete SendRC4Req_reflection_;
  delete SendRC4Resp::default_instance_;
  delete SendRC4Resp_reflection_;
  delete WakeUpDVRRsp::default_instance_;
  delete WakeUpDVRRsp_reflection_;
  delete WakeUpDVRReq::default_instance_;
  delete WakeUpDVRReq_reflection_;
  delete RmtDiagRsp::default_instance_;
  delete RmtDiagRsp_reflection_;
  delete RmtDiagReq::default_instance_;
  delete RmtDiagReq_reflection_;
  delete Fault_List_info::default_instance_;
  delete Fault_List_info_reflection_;
  delete FourGExtendCmdRsp::default_instance_;
  delete FourGExtendCmdRsp_reflection_;
  delete FourGExtendCmdReq::default_instance_;
  delete FourGExtendCmdReq_reflection_;
  delete TCUExtendCmdReq::default_instance_;
  delete TCUExtendCmdReq_reflection_;
  delete TCUExtendCmdRsp::default_instance_;
  delete TCUExtendCmdRsp_reflection_;
  delete FCM_Info::default_instance_;
  delete FCM_Info_reflection_;
  delete EPS_Info::default_instance_;
  delete EPS_Info_reflection_;
  delete ELD_Info::default_instance_;
  delete ELD_Info_reflection_;
  delete ECU_Info::default_instance_;
  delete ECU_Info_reflection_;
}

void protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\032zna_protocol_message.proto\022\014zna.protoc"
    "ol\"\334\001\n\013UpgradeInfo\022\020\n\010filetype\030\001 \002(\t\022\020\n\010"
    "filepath\030\002 \002(\t\022\017\n\007version\030\003 \002(\t\022\020\n\010files"
    "ize\030\004 \002(\r\022\013\n\003md5\030\005 \002(\014\022\013\n\003rc4\030\006 \001(\t\022\020\n\010s"
    "ign_md5\030\007 \001(\014\022\014\n\004sha2\030\010 \001(\014\022\016\n\006aes128\030\t "
    "\001(\t\022\021\n\tsign_sha2\030\n \001(\014\022\023\n\013prefilesize\030\013 "
    "\001(\r\022\024\n\014encrypt_type\030\014 \001(\r\"\243\002\n\010LoginReq\022\025"
    "\n\rtcu_device_sn\030\001 \002(\t\022\024\n\014da_device_sn\030\002 "
    "\002(\t\022\013\n\003vin\030\003 \002(\t\022\r\n\005iccid\030\004 \002(\t\022\014\n\004imsi\030"
    "\005 \002(\t\022\014\n\004imei\030\006 \002(\t\022\030\n\020software_version\030"
    "\007 \002(\t\022\030\n\020hardware_version\030\010 \002(\t\022\022\n\ntime_"
    "stamp\030\t \002(\r\022\022\n\ng4_version\030\n \001(\t\022\024\n\014vehic"
    "le_type\030\013 \001(\t\022\021\n\tupgrading\030\014 \001(\010\022\026\n\016bcm_"
    "reg_status\030\r \001(\010\022\025\n\rota_algrithom\030\016 \001(\r\""
    "_\n\010LoginRsp\022\017\n\007errcode\030\001 \002(\r\022\022\n\ntime_sta"
    "mp\030\002 \002(\r\022.\n\013upgradeinfo\030\003 \003(\0132\031.zna.prot"
    "ocol.UpgradeInfo\"\"\n\014HeartbeatReq\022\022\n\ntime"
    "_stamp\030\001 \002(\r\"3\n\014HeartbeatRsp\022\017\n\007errcode\030"
    "\001 \002(\r\022\022\n\ntime_stamp\030\002 \002(\r\"d\n\nSendRSAReq\022"
    "\r\n\005N_len\030\001 \002(\r\022\020\n\010N_string\030\002 \002(\t\022\016\n\006E1_l"
    "en\030\003 \002(\r\022\021\n\tE1_string\030\004 \002(\t\022\022\n\ntime_stam"
    "p\030\005 \002(\r\"H\n\nSendRC4Rsp\022\017\n\007errcode\030\001 \002(\r\022\025"
    "\n\rserial_number\030\002 \002(\r\022\022\n\ntime_stamp\030\003 \002("
    "\r\"6\n\017SetParameterRsp\022\017\n\007errcode\030\001 \002(\r\022\022\n"
    "\ntime_stamp\030\002 \002(\r\"\274\002\n\017SetParameterReq\022\033\n"
    "\023local_storage_cycle\030\001 \002(\r\022 \n\030upload_dat"
    "a_cycle_normal\030\002 \002(\r\022\037\n\027upload_GPS_cycle"
    "_normal\030\003 \002(\r\022\037\n\027upload_data_cycle_alarm"
    "\030\004 \002(\r\022\036\n\026upload_GPS_cycle_alarm\030\005 \002(\r\022\027"
    "\n\017heartbeat_cycle\030\006 \001(\r\022\037\n\027server_respon"
    "se_timeout\030\007 \001(\r\022\034\n\024box_response_timeout"
    "\030\010 \001(\r\022\031\n\021FlowControlSwitch\030\t \001(\010\022\025\n\rGPS"
    "conversion\030\n \001(\r\"\343\002\n\017GetParameterRsp\022\017\n\007"
    "errcode\030\001 \002(\r\022\033\n\023local_storage_cycle\030\002 \002"
    "(\r\022 \n\030upload_data_cycle_normal\030\003 \002(\r\022\037\n\027"
    "upload_GPS_cycle_normal\030\004 \002(\r\022\037\n\027upload_"
    "data_cycle_alarm\030\005 \002(\r\022\036\n\026upload_GPS_cyc"
    "le_alarm\030\006 \002(\r\022\027\n\017heartbeat_cycle\030\007 \002(\r\022"
    "\037\n\027server_response_timeout\030\010 \002(\r\022\034\n\024box_"
    "response_timeout\030\t \002(\r\022\030\n\020firmware_versi"
    "on\030\n \002(\t\022\030\n\020hardware_version\030\013 \002(\t\022\022\n\nti"
    "me_stamp\030\014 \002(\r\"%\n\017GetParameterReq\022\022\n\ntim"
    "e_stamp\030\001 \002(\r\"\315\001\n\010ECM_Info\022\021\n\tEngineRPM\030"
    "\001 \001(\r\022\024\n\014EngineStatus\030\004 \001(\r\022\031\n\021EngineCoo"
    "lantTemp\030\005 \001(\r\022\017\n\007MILLamp\030\025 \001(\r\022\017\n\007SVSLa"
    "mp\030\026 \001(\r\022\025\n\rOilPress_Lamp\030\027 \001(\r\022\020\n\010UreaL"
    "amp\030\030 \001(\r\022\027\n\017Filterwater_Det\030\031 \001(\010\022\031\n\021Ba"
    "tteryCharge_Sts\030\032 \001(\010\"\312\001\n\nMETER_Info\022\034\n\024"
    "Average_Fuel_Economy\030\002 \001(\r\022\031\n\021Distance_t"
    "o_empty\030\003 \001(\r\022\032\n\022Distance_Totalizer\030\004 \001("
    "\r\022\023\n\013Fuel_Remain\030\005 \001(\r\022\026\n\016TotalOdo_Valid"
    "\030\r \001(\010\022\017\n\007OilPres\030\016 \001(\010\022\024\n\014BrakeFailure\030"
    "\017 \001(\r\022\023\n\013InstandFuel\030\020 \001(\r\"\372\003\n\010BCM_Info\022"
    "\036\n\026front_left_door_status\030\003 \001(\010\022\037\n\027front"
    "_right_door_status\030\004 \001(\010\022\035\n\025rear_left_do"
    "or_status\030\005 \001(\010\022\036\n\026rear_right_door_statu"
    "s\030\006 \001(\010\022\030\n\020back_door_status\030\007 \001(\010\022\037\n\027bac"
    "k_door_locked_status\030\t \001(\010\022\026\n\016LowBeamReq"
    "uest\030\n \001(\010\022\027\n\017HighBeamRequest\030\014 \001(\010\022\016\n\006S"
    "WIIGK\0303 \001(\010\022\030\n\020DoorOpen_Warning\0304 \001(\010\022\027\n"
    "\017LightOn_Warning\0305 \001(\010\022\023\n\013TPMSMIL_Req\0306 "
    "\001(\r\022\027\n\017StopLampFailSts\0307 \001(\010\022\032\n\022RemoteVe"
    "cSearchSts\0308 \001(\010\022\031\n\021DriverDoorLockSts\0309 "
    "\001(\010\022\023\n\013KeyAlarmSts\030: \001(\r\022\022\n\nHoodStatus\030;"
    " \001(\010\022\021\n\tAccStatus\030< \001(\010\022\036\n\026remote_enging"
    "_run_flag\030= \001(\010\">\n\010ACU_Info\022\032\n\022Airbag_Cr"
    "ash_Order\030\001 \001(\r\022\026\n\016AirbagFail_Sts\030\014 \001(\r\""
    "h\n\010ECO_Info\022 \n\030rapid_acceleration_count\030"
    "\001 \001(\r\022 \n\030rapid_deceleration_count\030\002 \001(\r\022"
    "\030\n\020sharp_turn_count\030\003 \001(\r\"|\n\nALARM_Info\022"
    "\022\n\nalarm_type\030\001 \001(\r\022\024\n\014alarm_typeEx\030\002 \001("
    "\014\022\030\n\020Transmitter_Fail\030\003 \001(\r\022\027\n\017LowTirePr"
    "essure\030\004 \001(\r\022\021\n\tZNA_P15MC\030\005 \001(\r\"\240\001\n\tPEPS"
    "_Info\022\032\n\022RemoteFeedback_Sts\030\001 \001(\r\022\027\n\017Rem"
    "otePEPS_Mode\030\002 \001(\r\022\033\n\023RemoteEngineRun_Cn"
    "t\030\003 \001(\r\022\020\n\010PEPS_PDU\030\004 \001(\r\022\026\n\016PEPS_Blueto"
    "oth\030\005 \001(\010\022\027\n\017PEPS_MeterAlarm\030\006 \001(\r\"\255\001\n\010E"
    "SP_Info\022\020\n\010ESP_Lamp\030\001 \001(\r\022\020\n\010ABS_Lamp\030\002 "
    "\001(\r\022\022\n\nHAZ_Active\030\003 \001(\010\022\032\n\022VehicleSpeed_"
    "Valid\030\004 \001(\010\022\021\n\tLongAccel\030\005 \001(\r\022\024\n\014Vehicl"
    "eSpeed\030\006 \001(\r\022\020\n\010EBD_Lamp\030\007 \001(\r\022\022\n\nABS_Ac"
    "itve\030\010 \001(\010\"\"\n\010EPB_Info\022\026\n\016EPB_FailStatus"
    "\030\001 \001(\r\"K\n\010TCU_Info\022\021\n\tTCU_Fault\030\001 \001(\r\022\026\n"
    "\016GearSelect_Pos\030\002 \001(\r\022\024\n\014Driving_Mode\030\003 "
    "\001(\r\"\034\n\010AWD_Info\022\020\n\010AWD_Mode\030\001 \001(\r\"U\n\007AC_"
    "Info\022\022\n\nAC_OnState\030\001 \001(\010\022\034\n\024AirDistribut"
    "ion_Mode\030\002 \001(\r\022\030\n\020ACInsideSen_Temp\030\003 \001(\r"
    "\"A\n\010SAS_Info\022\025\n\rSteeringAngel\030\001 \001(\r\022\036\n\026S"
    "teeringAngel_Velocity\030\002 \001(\r\"\336\005\n\nBasic_In"
    "fo\022(\n\010ecm_info\030\001 \001(\0132\026.zna.protocol.ECM_"
    "Info\022,\n\nmeter_info\030\003 \001(\0132\030.zna.protocol."
    "METER_Info\022(\n\010bcm_info\030\004 \001(\0132\026.zna.proto"
    "col.BCM_Info\022(\n\010acu_info\030\005 \001(\0132\026.zna.pro"
    "tocol.ACU_Info\022(\n\010eco_info\030\014 \001(\0132\026.zna.p"
    "rotocol.ECO_Info\022,\n\nalarm_info\030\r \001(\0132\030.z"
    "na.protocol.ALARM_Info\022*\n\tpeps_info\030\024 \001("
    "\0132\027.zna.protocol.PEPS_Info\022(\n\010esp_info\030\025"
    " \001(\0132\026.zna.protocol.ESP_Info\022(\n\010epb_info"
    "\030\026 \001(\0132\026.zna.protocol.EPB_Info\022(\n\010tcu_in"
    "fo\030\027 \001(\0132\026.zna.protocol.TCU_Info\022(\n\010awd_"
    "info\030\030 \001(\0132\026.zna.protocol.AWD_Info\022&\n\007ac"
    "_info\030\031 \001(\0132\025.zna.protocol.AC_Info\022(\n\010sa"
    "s_info\030\032 \001(\0132\026.zna.protocol.SAS_Info\022(\n\010"
    "fcm_info\030\033 \001(\0132\026.zna.protocol.FCM_Info\022("
    "\n\010eps_info\030\034 \001(\0132\026.zna.protocol.EPS_Info"
    "\022(\n\010eld_info\030\035 \001(\0132\026.zna.protocol.ELD_In"
    "fo\022(\n\010ecu_info\030\036 \001(\0132\026.zna.protocol.ECU_"
    "Info\"\252\001\n\014Vehicle_Info\022\021\n\tInfo_type\030\001 \002(\010"
    "\022\024\n\014collect_time\030\002 \002(\r\022,\n\nbasic_info\030\003 \002"
    "(\0132\030.zna.protocol.Basic_Info\022\022\n\ntime_sta"
    "mp\030\004 \002(\r\022\020\n\010IgnOnTag\030\005 \001(\r\022\014\n\004EF82\030\006 \001(\r"
    "\022\017\n\007Version\030\007 \001(\t\"6\n\017Vehicle_InfoRsp\022\017\n\007"
    "errcode\030\001 \002(\r\022\022\n\ntime_stamp\030\002 \002(\r\"\312\001\n\rLo"
    "cation_Info\022\021\n\tInfo_type\030\001 \002(\010\022\027\n\017locati"
    "on_status\030\003 \002(\r\022\021\n\tlongitude\030\004 \002(\r\022\020\n\010la"
    "titude\030\005 \002(\r\022\022\n\ntime_stamp\030\010 \002(\r\022\027\n\017isGP"
    "Sconversion\030\t \001(\r\022\020\n\010gps_time\030\n \002(\004\022\024\n\014h"
    "eight_valid\030\013 \002(\r\022\023\n\013height_data\030\014 \002(\r\"7"
    "\n\020Location_InfoRsp\022\017\n\007errcode\030\001 \002(\r\022\022\n\nt"
    "ime_stamp\030\002 \002(\r\"\210\001\n\026RemoteControlResultR"
    "sp\022\024\n\014control_type\030\001 \002(\r\022\025\n\rcontrol_valu"
    "e\030\002 \002(\r\022\025\n\rserial_number\030\003 \002(\r\022\026\n\016contro"
    "l_result\030\004 \002(\r\022\022\n\ntime_stamp\030\005 \002(\r\"\177\n\020Re"
    "moteControlReq\022\024\n\014control_type\030\001 \002(\r\022\025\n\r"
    "control_value\030\002 \002(\r\022\025\n\rserial_number\030\003 \002"
    "(\r\022\022\n\ntime_stamp\030\004 \002(\r\022\023\n\013signal_data\030\005 "
    "\001(\t\"O\n\014FlowCountRsp\022\025\n\rdataAllowance\030\001 \002"
    "(\r\022\021\n\tdataUsage\030\002 \002(\r\022\025\n\rdataAvailable\030\003"
    " \002(\r\"%\n\021FlowCountLimitReq\022\020\n\010limitVal\030\001 "
    "\002(\r\"j\n\rOtaUpgradeReq\022.\n\013upgradeinfo\030\001 \003("
    "\0132\031.zna.protocol.UpgradeInfo\022\025\n\rserial_n"
    "umber\030\002 \002(\r\022\022\n\ntime_stamp\030\003 \002(\r\"K\n\rOtaUp"
    "gradeRsp\022\017\n\007errcode\030\001 \002(\r\022\022\n\ntime_stamp\030"
    "\002 \002(\r\022\025\n\rserial_number\030\003 \002(\r\"&\n\023CancelOt"
    "aUpgradeRsp\022\017\n\007errcode\030\001 \002(\r\"l\n\025OtaUpgra"
    "deProgressReq\022B\n\023UpgradeProgressCode\030\001 \002"
    "(\0162%.zna.protocol.UpgradeProgressCodeTyp"
    "e\022\017\n\007errcode\030\002 \001(\r\"\241\001\n\007CertCom\022\025\n\rserial"
    "_number\030\001 \002(\r\022\023\n\013cur_cert_id\030\002 \002(\r\022\023\n\013da"
    "ta_status\030\003 \002(\r\022\016\n\006cmd_id\030\004 \002(\r\022\016\n\006dcm_n"
    "o\030\005 \002(\t\022\017\n\007errcode\030\006 \001(\r\022\021\n\tdata_info\030\007 "
    "\002(\014\022\021\n\tsign_data\030\010 \001(\014\"\252\001\n\020TCUCertApply_"
    "Req\022\022\n\ntime_stamp\030\001 \002(\r\022\013\n\003vin\030\002 \002(\t\022\023\n\013"
    "cert_status\030\003 \002(\r\022\020\n\010duration\030\004 \002(\r\022\017\n\007p"
    "10_csr\030\005 \002(\014\022\025\n\rcst_sign_data\030\006 \001(\014\022\023\n\013c"
    "ert_format\030\007 \001(\t\022\021\n\tsign_type\030\010 \001(\r\";\n\020T"
    "CUCertApply_Rsp\022\022\n\ntime_stamp\030\001 \002(\r\022\023\n\013r"
    "ecv_status\030\002 \001(\r\"h\n\rCertIssue_Req\022\022\n\ntim"
    "e_stamp\030\001 \002(\r\022\031\n\021cert_apply_status\030\002 \002(\r"
    "\022\025\n\rapply_cert_id\030\003 \001(\r\022\021\n\tcert_data\030\004 \001"
    "(\014\"T\n\rCertIssue_Rsp\022\022\n\ntime_stamp\030\001 \002(\r\022"
    "\030\n\020cert_recv_status\030\002 \002(\r\022\025\n\rapply_cert_"
    "id\030\003 \001(\r\"\262\001\n\013RSALoginReq\022\025\n\rtcu_device_s"
    "n\030\001 \002(\t\022\014\n\004imsi\030\002 \002(\t\022\014\n\004imei\030\003 \002(\t\022\030\n\020s"
    "oftware_version\030\004 \002(\t\022\030\n\020hardware_versio"
    "n\030\005 \002(\t\022\022\n\ntime_stamp\030\006 \002(\r\022\022\n\ng4_versio"
    "n\030\007 \001(\t\022\024\n\014vehicle_type\030\010 \001(\t\"a\n\nSendRSA"
    "Rsp\022\017\n\007errcode\030\001 \002(\r\022\r\n\005N_len\030\002 \001(\r\022\020\n\010N"
    "_string\030\003 \001(\014\022\016\n\006E1_len\030\004 \001(\r\022\021\n\tE1_stri"
    "ng\030\005 \001(\014\"\236\001\n\nSendRC4Req\022\024\n\014da_device_sn\030"
    "\001 \002(\t\022\013\n\003vin\030\002 \002(\t\022\r\n\005iccid\030\003 \002(\t\022\025\n\rser"
    "ial_number\030\004 \002(\r\022\017\n\007key_len\030\005 \002(\r\022\013\n\003key"
    "\030\006 \002(\014\022\021\n\tupgrading\030\007 \001(\010\022\026\n\016bcm_reg_sta"
    "tus\030\010 \001(\010\"y\n\013SendRC4Resp\022\017\n\007errcode\030\001 \002("
    "\r\022\025\n\rserial_number\030\002 \002(\r\022\022\n\ntime_stamp\030\003"
    " \002(\r\022.\n\013upgradeinfo\030\004 \003(\0132\031.zna.protocol"
    ".UpgradeInfo\"=\n\014WakeUpDVRRsp\022\025\n\rserial_n"
    "umber\030\001 \002(\r\022\026\n\016control_result\030\002 \002(\r\"9\n\014W"
    "akeUpDVRReq\022\025\n\rserial_number\030\001 \002(\r\022\022\n\nti"
    "me_stamp\030\002 \002(\r\"\271\003\n\nRmtDiagRsp\022,\n\006result\030"
    "\001 \002(\0162\034.zna.protocol.RmtDiagRspCode\022\025\n\rs"
    "erial_number\030\002 \002(\r\022\022\n\ntime_stamp\030\003 \002(\r\022\020"
    "\n\010Diag_AVM\030\004 \001(\014\022\022\n\nDiag_SONAR\030\005 \001(\014\022\020\n\010"
    "Diag_BSW\030\006 \001(\014\022\020\n\010Diag_ECM\030\007 \001(\014\022\020\n\010Diag"
    "_TCM\030\010 \001(\014\022\020\n\010Diag_USM\030\t \001(\014\022\020\n\010Diag_BCM"
    "\030\n \001(\014\022\027\n\017Diag_FEB_CAMERA\030\013 \001(\014\022\026\n\016Diag_"
    "FEB_RADAR\030\014 \001(\014\022\020\n\010Diag_DVR\030\r \001(\014\022\020\n\010Dia"
    "g_VDC\030\016 \001(\014\022\020\n\010Diag_EPS\030\017 \001(\014\022\017\n\007Diag_GW"
    "\030\020 \001(\014\022\021\n\tDiag_TPMS\030\021 \001(\014\022\022\n\nDiag_METER\030"
    "\022 \001(\014\022\020\n\010Diag_TCU\030\023 \001(\014\022\020\n\010Diag_ACU\030\024 \001("
    "\014\022\017\n\007Diag_DA\030\025 \001(\014\"7\n\nRmtDiagReq\022\025\n\rseri"
    "al_number\030\001 \002(\r\022\022\n\ntime_stamp\030\002 \002(\r\")\n\017F"
    "ault_List_info\022\026\n\016Fault_List_one\030\001 \001(\r\"i"
    "\n\021FourGExtendCmdRsp\022\025\n\rserial_number\030\001 \002"
    "(\r\022\022\n\ntime_stamp\030\002 \002(\r\022\024\n\014commander_id\030\003"
    " \002(\r\022\023\n\013result_info\030\004 \002(\014\"i\n\021FourGExtend"
    "CmdReq\022\025\n\rserial_number\030\001 \002(\r\022\022\n\ntime_st"
    "amp\030\002 \002(\r\022\024\n\014commander_id\030\003 \002(\r\022\023\n\013resul"
    "t_info\030\004 \002(\014\"g\n\017TCUExtendCmdReq\022\025\n\rseria"
    "l_number\030\001 \002(\r\022\022\n\ntime_stamp\030\002 \002(\r\022\024\n\014co"
    "mmander_id\030\003 \002(\r\022\023\n\013result_info\030\004 \002(\014\"g\n"
    "\017TCUExtendCmdRsp\022\025\n\rserial_number\030\001 \002(\r\022"
    "\022\n\ntime_stamp\030\002 \002(\r\022\024\n\014commander_id\030\003 \002("
    "\r\022\023\n\013result_info\030\004 \002(\014\"[\n\010FCM_Info\022\031\n\021FC"
    "M_LKA_Sys_state\030\001 \001(\r\022\032\n\022FCM_ACC_SysFail"
    "ure\030\002 \001(\r\022\030\n\020FCM_AEB_Failinfo\030\003 \001(\r\"#\n\010E"
    "PS_Info\022\027\n\017EPS_FaultStates\030\001 \001(\r\"\037\n\010ELD_"
    "Info\022\023\n\013ELDFaultSts\030\001 \001(\r\"(\n\010ECU_Info\022\034\n"
    "\024ECMD_48V_FaultStates\030\001 \001(\r*\"\n\007RspCode\022\n"
    "\n\006FAILED\020\000\022\013\n\007SUCCESS\020\001*\326\001\n\027UpgradeProgr"
    "essCodeType\022\034\n\030DOWNLOADING_UPGRADE_PACK\020"
    "\000\022 \n\034DOWNLOAD_UPGRADE_PACK_RESULT\020\001\022\025\n\021B"
    "ACKUPING_MCU_APP\020\002\022\031\n\025BACKUP_MCU_APP_RES"
    "ULT\020\003\022\021\n\rSTART_UPGRADE\020\004\022\022\n\016UPGRADE_RESU"
    "LT\020\005\022\"\n\036WAITING_UPDATE_CONDITION_SLEEP\020\006"
    "*X\n\016RmtDiagRspCode\022\016\n\nRMT_FAILED\020\000\022\017\n\013RM"
    "T_SUCCESS\020\001\022\022\n\016RMT_DIAGNOSING\020\002\022\021\n\rRMT_D"
    "IAGNOSED\020\003", 8290);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "zna_protocol_message.proto", &protobuf_RegisterTypes);
  UpgradeInfo::default_instance_ = new UpgradeInfo();
  LoginReq::default_instance_ = new LoginReq();
  LoginRsp::default_instance_ = new LoginRsp();
  HeartbeatReq::default_instance_ = new HeartbeatReq();
  HeartbeatRsp::default_instance_ = new HeartbeatRsp();
  SendRSAReq::default_instance_ = new SendRSAReq();
  SendRC4Rsp::default_instance_ = new SendRC4Rsp();
  SetParameterRsp::default_instance_ = new SetParameterRsp();
  SetParameterReq::default_instance_ = new SetParameterReq();
  GetParameterRsp::default_instance_ = new GetParameterRsp();
  GetParameterReq::default_instance_ = new GetParameterReq();
  ECM_Info::default_instance_ = new ECM_Info();
  METER_Info::default_instance_ = new METER_Info();
  BCM_Info::default_instance_ = new BCM_Info();
  ACU_Info::default_instance_ = new ACU_Info();
  ECO_Info::default_instance_ = new ECO_Info();
  ALARM_Info::default_instance_ = new ALARM_Info();
  PEPS_Info::default_instance_ = new PEPS_Info();
  ESP_Info::default_instance_ = new ESP_Info();
  EPB_Info::default_instance_ = new EPB_Info();
  TCU_Info::default_instance_ = new TCU_Info();
  AWD_Info::default_instance_ = new AWD_Info();
  AC_Info::default_instance_ = new AC_Info();
  SAS_Info::default_instance_ = new SAS_Info();
  Basic_Info::default_instance_ = new Basic_Info();
  Vehicle_Info::default_instance_ = new Vehicle_Info();
  Vehicle_InfoRsp::default_instance_ = new Vehicle_InfoRsp();
  Location_Info::default_instance_ = new Location_Info();
  Location_InfoRsp::default_instance_ = new Location_InfoRsp();
  RemoteControlResultRsp::default_instance_ = new RemoteControlResultRsp();
  RemoteControlReq::default_instance_ = new RemoteControlReq();
  FlowCountRsp::default_instance_ = new FlowCountRsp();
  FlowCountLimitReq::default_instance_ = new FlowCountLimitReq();
  OtaUpgradeReq::default_instance_ = new OtaUpgradeReq();
  OtaUpgradeRsp::default_instance_ = new OtaUpgradeRsp();
  CancelOtaUpgradeRsp::default_instance_ = new CancelOtaUpgradeRsp();
  OtaUpgradeProgressReq::default_instance_ = new OtaUpgradeProgressReq();
  CertCom::default_instance_ = new CertCom();
  TCUCertApply_Req::default_instance_ = new TCUCertApply_Req();
  TCUCertApply_Rsp::default_instance_ = new TCUCertApply_Rsp();
  CertIssue_Req::default_instance_ = new CertIssue_Req();
  CertIssue_Rsp::default_instance_ = new CertIssue_Rsp();
  RSALoginReq::default_instance_ = new RSALoginReq();
  SendRSARsp::default_instance_ = new SendRSARsp();
  SendRC4Req::default_instance_ = new SendRC4Req();
  SendRC4Resp::default_instance_ = new SendRC4Resp();
  WakeUpDVRRsp::default_instance_ = new WakeUpDVRRsp();
  WakeUpDVRReq::default_instance_ = new WakeUpDVRReq();
  RmtDiagRsp::default_instance_ = new RmtDiagRsp();
  RmtDiagReq::default_instance_ = new RmtDiagReq();
  Fault_List_info::default_instance_ = new Fault_List_info();
  FourGExtendCmdRsp::default_instance_ = new FourGExtendCmdRsp();
  FourGExtendCmdReq::default_instance_ = new FourGExtendCmdReq();
  TCUExtendCmdReq::default_instance_ = new TCUExtendCmdReq();
  TCUExtendCmdRsp::default_instance_ = new TCUExtendCmdRsp();
  FCM_Info::default_instance_ = new FCM_Info();
  EPS_Info::default_instance_ = new EPS_Info();
  ELD_Info::default_instance_ = new ELD_Info();
  ECU_Info::default_instance_ = new ECU_Info();
  UpgradeInfo::default_instance_->InitAsDefaultInstance();
  LoginReq::default_instance_->InitAsDefaultInstance();
  LoginRsp::default_instance_->InitAsDefaultInstance();
  HeartbeatReq::default_instance_->InitAsDefaultInstance();
  HeartbeatRsp::default_instance_->InitAsDefaultInstance();
  SendRSAReq::default_instance_->InitAsDefaultInstance();
  SendRC4Rsp::default_instance_->InitAsDefaultInstance();
  SetParameterRsp::default_instance_->InitAsDefaultInstance();
  SetParameterReq::default_instance_->InitAsDefaultInstance();
  GetParameterRsp::default_instance_->InitAsDefaultInstance();
  GetParameterReq::default_instance_->InitAsDefaultInstance();
  ECM_Info::default_instance_->InitAsDefaultInstance();
  METER_Info::default_instance_->InitAsDefaultInstance();
  BCM_Info::default_instance_->InitAsDefaultInstance();
  ACU_Info::default_instance_->InitAsDefaultInstance();
  ECO_Info::default_instance_->InitAsDefaultInstance();
  ALARM_Info::default_instance_->InitAsDefaultInstance();
  PEPS_Info::default_instance_->InitAsDefaultInstance();
  ESP_Info::default_instance_->InitAsDefaultInstance();
  EPB_Info::default_instance_->InitAsDefaultInstance();
  TCU_Info::default_instance_->InitAsDefaultInstance();
  AWD_Info::default_instance_->InitAsDefaultInstance();
  AC_Info::default_instance_->InitAsDefaultInstance();
  SAS_Info::default_instance_->InitAsDefaultInstance();
  Basic_Info::default_instance_->InitAsDefaultInstance();
  Vehicle_Info::default_instance_->InitAsDefaultInstance();
  Vehicle_InfoRsp::default_instance_->InitAsDefaultInstance();
  Location_Info::default_instance_->InitAsDefaultInstance();
  Location_InfoRsp::default_instance_->InitAsDefaultInstance();
  RemoteControlResultRsp::default_instance_->InitAsDefaultInstance();
  RemoteControlReq::default_instance_->InitAsDefaultInstance();
  FlowCountRsp::default_instance_->InitAsDefaultInstance();
  FlowCountLimitReq::default_instance_->InitAsDefaultInstance();
  OtaUpgradeReq::default_instance_->InitAsDefaultInstance();
  OtaUpgradeRsp::default_instance_->InitAsDefaultInstance();
  CancelOtaUpgradeRsp::default_instance_->InitAsDefaultInstance();
  OtaUpgradeProgressReq::default_instance_->InitAsDefaultInstance();
  CertCom::default_instance_->InitAsDefaultInstance();
  TCUCertApply_Req::default_instance_->InitAsDefaultInstance();
  TCUCertApply_Rsp::default_instance_->InitAsDefaultInstance();
  CertIssue_Req::default_instance_->InitAsDefaultInstance();
  CertIssue_Rsp::default_instance_->InitAsDefaultInstance();
  RSALoginReq::default_instance_->InitAsDefaultInstance();
  SendRSARsp::default_instance_->InitAsDefaultInstance();
  SendRC4Req::default_instance_->InitAsDefaultInstance();
  SendRC4Resp::default_instance_->InitAsDefaultInstance();
  WakeUpDVRRsp::default_instance_->InitAsDefaultInstance();
  WakeUpDVRReq::default_instance_->InitAsDefaultInstance();
  RmtDiagRsp::default_instance_->InitAsDefaultInstance();
  RmtDiagReq::default_instance_->InitAsDefaultInstance();
  Fault_List_info::default_instance_->InitAsDefaultInstance();
  FourGExtendCmdRsp::default_instance_->InitAsDefaultInstance();
  FourGExtendCmdReq::default_instance_->InitAsDefaultInstance();
  TCUExtendCmdReq::default_instance_->InitAsDefaultInstance();
  TCUExtendCmdRsp::default_instance_->InitAsDefaultInstance();
  FCM_Info::default_instance_->InitAsDefaultInstance();
  EPS_Info::default_instance_->InitAsDefaultInstance();
  ELD_Info::default_instance_->InitAsDefaultInstance();
  ECU_Info::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_zna_5fprotocol_5fmessage_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_zna_5fprotocol_5fmessage_2eproto {
  StaticDescriptorInitializer_zna_5fprotocol_5fmessage_2eproto() {
    protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  }
} static_descriptor_initializer_zna_5fprotocol_5fmessage_2eproto_;
const ::google::protobuf::EnumDescriptor* RspCode_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RspCode_descriptor_;
}
bool RspCode_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* UpgradeProgressCodeType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UpgradeProgressCodeType_descriptor_;
}
bool UpgradeProgressCodeType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* RmtDiagRspCode_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RmtDiagRspCode_descriptor_;
}
bool RmtDiagRspCode_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int UpgradeInfo::kFiletypeFieldNumber;
const int UpgradeInfo::kFilepathFieldNumber;
const int UpgradeInfo::kVersionFieldNumber;
const int UpgradeInfo::kFilesizeFieldNumber;
const int UpgradeInfo::kMd5FieldNumber;
const int UpgradeInfo::kRc4FieldNumber;
const int UpgradeInfo::kSignMd5FieldNumber;
const int UpgradeInfo::kSha2FieldNumber;
const int UpgradeInfo::kAes128FieldNumber;
const int UpgradeInfo::kSignSha2FieldNumber;
const int UpgradeInfo::kPrefilesizeFieldNumber;
const int UpgradeInfo::kEncryptTypeFieldNumber;
#endif  // !_MSC_VER

UpgradeInfo::UpgradeInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.UpgradeInfo)
}

void UpgradeInfo::InitAsDefaultInstance() {
}

UpgradeInfo::UpgradeInfo(const UpgradeInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.UpgradeInfo)
}

void UpgradeInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  filetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  filesize_ = 0u;
  md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  rc4_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sign_md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sha2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  aes128_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sign_sha2_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  prefilesize_ = 0u;
  encrypt_type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UpgradeInfo::~UpgradeInfo() {
  // @@protoc_insertion_point(destructor:zna.protocol.UpgradeInfo)
  SharedDtor();
}

void UpgradeInfo::SharedDtor() {
  if (filetype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filetype_;
  }
  if (filepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filepath_;
  }
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (md5_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete md5_;
  }
  if (rc4_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete rc4_;
  }
  if (sign_md5_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sign_md5_;
  }
  if (sha2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sha2_;
  }
  if (aes128_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete aes128_;
  }
  if (sign_sha2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sign_sha2_;
  }
  if (this != default_instance_) {
  }
}

void UpgradeInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UpgradeInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UpgradeInfo_descriptor_;
}

const UpgradeInfo& UpgradeInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

UpgradeInfo* UpgradeInfo::default_instance_ = NULL;

UpgradeInfo* UpgradeInfo::New() const {
  return new UpgradeInfo;
}

void UpgradeInfo::Clear() {
  if (_has_bits_[0 / 32] & 255) {
    if (has_filetype()) {
      if (filetype_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        filetype_->clear();
      }
    }
    if (has_filepath()) {
      if (filepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        filepath_->clear();
      }
    }
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        version_->clear();
      }
    }
    filesize_ = 0u;
    if (has_md5()) {
      if (md5_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        md5_->clear();
      }
    }
    if (has_rc4()) {
      if (rc4_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        rc4_->clear();
      }
    }
    if (has_sign_md5()) {
      if (sign_md5_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        sign_md5_->clear();
      }
    }
    if (has_sha2()) {
      if (sha2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        sha2_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & 3840) {
    if (has_aes128()) {
      if (aes128_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        aes128_->clear();
      }
    }
    if (has_sign_sha2()) {
      if (sign_sha2_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        sign_sha2_->clear();
      }
    }
    prefilesize_ = 0u;
    encrypt_type_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool UpgradeInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.UpgradeInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string filetype = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_filetype()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->filetype().data(), this->filetype().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "filetype");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_filepath;
        break;
      }

      // required string filepath = 2;
      case 2: {
        if (tag == 18) {
         parse_filepath:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_filepath()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->filepath().data(), this->filepath().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "filepath");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_version;
        break;
      }

      // required string version = 3;
      case 3: {
        if (tag == 26) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "version");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_filesize;
        break;
      }

      // required uint32 filesize = 4;
      case 4: {
        if (tag == 32) {
         parse_filesize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &filesize_)));
          set_has_filesize();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_md5;
        break;
      }

      // required bytes md5 = 5;
      case 5: {
        if (tag == 42) {
         parse_md5:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_md5()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_rc4;
        break;
      }

      // optional string rc4 = 6;
      case 6: {
        if (tag == 50) {
         parse_rc4:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_rc4()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->rc4().data(), this->rc4().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "rc4");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_sign_md5;
        break;
      }

      // optional bytes sign_md5 = 7;
      case 7: {
        if (tag == 58) {
         parse_sign_md5:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_sign_md5()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_sha2;
        break;
      }

      // optional bytes sha2 = 8;
      case 8: {
        if (tag == 66) {
         parse_sha2:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_sha2()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_aes128;
        break;
      }

      // optional string aes128 = 9;
      case 9: {
        if (tag == 74) {
         parse_aes128:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_aes128()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->aes128().data(), this->aes128().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "aes128");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_sign_sha2;
        break;
      }

      // optional bytes sign_sha2 = 10;
      case 10: {
        if (tag == 82) {
         parse_sign_sha2:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_sign_sha2()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_prefilesize;
        break;
      }

      // optional uint32 prefilesize = 11;
      case 11: {
        if (tag == 88) {
         parse_prefilesize:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &prefilesize_)));
          set_has_prefilesize();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_encrypt_type;
        break;
      }

      // optional uint32 encrypt_type = 12;
      case 12: {
        if (tag == 96) {
         parse_encrypt_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &encrypt_type_)));
          set_has_encrypt_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.UpgradeInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.UpgradeInfo)
  return false;
#undef DO_
}

void UpgradeInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.UpgradeInfo)
  // required string filetype = 1;
  if (has_filetype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->filetype().data(), this->filetype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "filetype");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->filetype(), output);
  }

  // required string filepath = 2;
  if (has_filepath()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->filepath().data(), this->filepath().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "filepath");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->filepath(), output);
  }

  // required string version = 3;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->version(), output);
  }

  // required uint32 filesize = 4;
  if (has_filesize()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->filesize(), output);
  }

  // required bytes md5 = 5;
  if (has_md5()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->md5(), output);
  }

  // optional string rc4 = 6;
  if (has_rc4()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->rc4().data(), this->rc4().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "rc4");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->rc4(), output);
  }

  // optional bytes sign_md5 = 7;
  if (has_sign_md5()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      7, this->sign_md5(), output);
  }

  // optional bytes sha2 = 8;
  if (has_sha2()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      8, this->sha2(), output);
  }

  // optional string aes128 = 9;
  if (has_aes128()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->aes128().data(), this->aes128().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "aes128");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->aes128(), output);
  }

  // optional bytes sign_sha2 = 10;
  if (has_sign_sha2()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      10, this->sign_sha2(), output);
  }

  // optional uint32 prefilesize = 11;
  if (has_prefilesize()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->prefilesize(), output);
  }

  // optional uint32 encrypt_type = 12;
  if (has_encrypt_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->encrypt_type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.UpgradeInfo)
}

::google::protobuf::uint8* UpgradeInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.UpgradeInfo)
  // required string filetype = 1;
  if (has_filetype()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->filetype().data(), this->filetype().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "filetype");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->filetype(), target);
  }

  // required string filepath = 2;
  if (has_filepath()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->filepath().data(), this->filepath().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "filepath");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->filepath(), target);
  }

  // required string version = 3;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->version(), target);
  }

  // required uint32 filesize = 4;
  if (has_filesize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->filesize(), target);
  }

  // required bytes md5 = 5;
  if (has_md5()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->md5(), target);
  }

  // optional string rc4 = 6;
  if (has_rc4()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->rc4().data(), this->rc4().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "rc4");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->rc4(), target);
  }

  // optional bytes sign_md5 = 7;
  if (has_sign_md5()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        7, this->sign_md5(), target);
  }

  // optional bytes sha2 = 8;
  if (has_sha2()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        8, this->sha2(), target);
  }

  // optional string aes128 = 9;
  if (has_aes128()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->aes128().data(), this->aes128().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "aes128");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->aes128(), target);
  }

  // optional bytes sign_sha2 = 10;
  if (has_sign_sha2()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        10, this->sign_sha2(), target);
  }

  // optional uint32 prefilesize = 11;
  if (has_prefilesize()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->prefilesize(), target);
  }

  // optional uint32 encrypt_type = 12;
  if (has_encrypt_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->encrypt_type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.UpgradeInfo)
  return target;
}

int UpgradeInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string filetype = 1;
    if (has_filetype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->filetype());
    }

    // required string filepath = 2;
    if (has_filepath()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->filepath());
    }

    // required string version = 3;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

    // required uint32 filesize = 4;
    if (has_filesize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->filesize());
    }

    // required bytes md5 = 5;
    if (has_md5()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->md5());
    }

    // optional string rc4 = 6;
    if (has_rc4()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->rc4());
    }

    // optional bytes sign_md5 = 7;
    if (has_sign_md5()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->sign_md5());
    }

    // optional bytes sha2 = 8;
    if (has_sha2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->sha2());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string aes128 = 9;
    if (has_aes128()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->aes128());
    }

    // optional bytes sign_sha2 = 10;
    if (has_sign_sha2()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->sign_sha2());
    }

    // optional uint32 prefilesize = 11;
    if (has_prefilesize()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->prefilesize());
    }

    // optional uint32 encrypt_type = 12;
    if (has_encrypt_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->encrypt_type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UpgradeInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const UpgradeInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const UpgradeInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void UpgradeInfo::MergeFrom(const UpgradeInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_filetype()) {
      set_filetype(from.filetype());
    }
    if (from.has_filepath()) {
      set_filepath(from.filepath());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_filesize()) {
      set_filesize(from.filesize());
    }
    if (from.has_md5()) {
      set_md5(from.md5());
    }
    if (from.has_rc4()) {
      set_rc4(from.rc4());
    }
    if (from.has_sign_md5()) {
      set_sign_md5(from.sign_md5());
    }
    if (from.has_sha2()) {
      set_sha2(from.sha2());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_aes128()) {
      set_aes128(from.aes128());
    }
    if (from.has_sign_sha2()) {
      set_sign_sha2(from.sign_sha2());
    }
    if (from.has_prefilesize()) {
      set_prefilesize(from.prefilesize());
    }
    if (from.has_encrypt_type()) {
      set_encrypt_type(from.encrypt_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void UpgradeInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UpgradeInfo::CopyFrom(const UpgradeInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpgradeInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void UpgradeInfo::Swap(UpgradeInfo* other) {
  if (other != this) {
    std::swap(filetype_, other->filetype_);
    std::swap(filepath_, other->filepath_);
    std::swap(version_, other->version_);
    std::swap(filesize_, other->filesize_);
    std::swap(md5_, other->md5_);
    std::swap(rc4_, other->rc4_);
    std::swap(sign_md5_, other->sign_md5_);
    std::swap(sha2_, other->sha2_);
    std::swap(aes128_, other->aes128_);
    std::swap(sign_sha2_, other->sign_sha2_);
    std::swap(prefilesize_, other->prefilesize_);
    std::swap(encrypt_type_, other->encrypt_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata UpgradeInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UpgradeInfo_descriptor_;
  metadata.reflection = UpgradeInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LoginReq::kTcuDeviceSnFieldNumber;
const int LoginReq::kDaDeviceSnFieldNumber;
const int LoginReq::kVinFieldNumber;
const int LoginReq::kIccidFieldNumber;
const int LoginReq::kImsiFieldNumber;
const int LoginReq::kImeiFieldNumber;
const int LoginReq::kSoftwareVersionFieldNumber;
const int LoginReq::kHardwareVersionFieldNumber;
const int LoginReq::kTimeStampFieldNumber;
const int LoginReq::kG4VersionFieldNumber;
const int LoginReq::kVehicleTypeFieldNumber;
const int LoginReq::kUpgradingFieldNumber;
const int LoginReq::kBcmRegStatusFieldNumber;
const int LoginReq::kOtaAlgrithomFieldNumber;
#endif  // !_MSC_VER

LoginReq::LoginReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.LoginReq)
}

void LoginReq::InitAsDefaultInstance() {
}

LoginReq::LoginReq(const LoginReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.LoginReq)
}

void LoginReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  tcu_device_sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  da_device_sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  vin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  iccid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  imsi_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  software_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hardware_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  time_stamp_ = 0u;
  g4_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  vehicle_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  upgrading_ = false;
  bcm_reg_status_ = false;
  ota_algrithom_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginReq::~LoginReq() {
  // @@protoc_insertion_point(destructor:zna.protocol.LoginReq)
  SharedDtor();
}

void LoginReq::SharedDtor() {
  if (tcu_device_sn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tcu_device_sn_;
  }
  if (da_device_sn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete da_device_sn_;
  }
  if (vin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vin_;
  }
  if (iccid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete iccid_;
  }
  if (imsi_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imsi_;
  }
  if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imei_;
  }
  if (software_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete software_version_;
  }
  if (hardware_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hardware_version_;
  }
  if (g4_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete g4_version_;
  }
  if (vehicle_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vehicle_type_;
  }
  if (this != default_instance_) {
  }
}

void LoginReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LoginReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LoginReq_descriptor_;
}

const LoginReq& LoginReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

LoginReq* LoginReq::default_instance_ = NULL;

LoginReq* LoginReq::New() const {
  return new LoginReq;
}

void LoginReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<LoginReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    if (has_tcu_device_sn()) {
      if (tcu_device_sn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        tcu_device_sn_->clear();
      }
    }
    if (has_da_device_sn()) {
      if (da_device_sn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        da_device_sn_->clear();
      }
    }
    if (has_vin()) {
      if (vin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        vin_->clear();
      }
    }
    if (has_iccid()) {
      if (iccid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        iccid_->clear();
      }
    }
    if (has_imsi()) {
      if (imsi_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        imsi_->clear();
      }
    }
    if (has_imei()) {
      if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        imei_->clear();
      }
    }
    if (has_software_version()) {
      if (software_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        software_version_->clear();
      }
    }
    if (has_hardware_version()) {
      if (hardware_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        hardware_version_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & 16128) {
    ZR_(time_stamp_, ota_algrithom_);
    if (has_g4_version()) {
      if (g4_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        g4_version_->clear();
      }
    }
    if (has_vehicle_type()) {
      if (vehicle_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        vehicle_type_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LoginReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.LoginReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string tcu_device_sn = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_tcu_device_sn()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->tcu_device_sn().data(), this->tcu_device_sn().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "tcu_device_sn");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_da_device_sn;
        break;
      }

      // required string da_device_sn = 2;
      case 2: {
        if (tag == 18) {
         parse_da_device_sn:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_da_device_sn()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->da_device_sn().data(), this->da_device_sn().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "da_device_sn");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_vin;
        break;
      }

      // required string vin = 3;
      case 3: {
        if (tag == 26) {
         parse_vin:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vin()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->vin().data(), this->vin().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "vin");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_iccid;
        break;
      }

      // required string iccid = 4;
      case 4: {
        if (tag == 34) {
         parse_iccid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_iccid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->iccid().data(), this->iccid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "iccid");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_imsi;
        break;
      }

      // required string imsi = 5;
      case 5: {
        if (tag == 42) {
         parse_imsi:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_imsi()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->imsi().data(), this->imsi().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "imsi");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_imei;
        break;
      }

      // required string imei = 6;
      case 6: {
        if (tag == 50) {
         parse_imei:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_imei()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->imei().data(), this->imei().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "imei");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_software_version;
        break;
      }

      // required string software_version = 7;
      case 7: {
        if (tag == 58) {
         parse_software_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_software_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->software_version().data(), this->software_version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "software_version");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_hardware_version;
        break;
      }

      // required string hardware_version = 8;
      case 8: {
        if (tag == 66) {
         parse_hardware_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hardware_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->hardware_version().data(), this->hardware_version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hardware_version");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_time_stamp;
        break;
      }

      // required uint32 time_stamp = 9;
      case 9: {
        if (tag == 72) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_g4_version;
        break;
      }

      // optional string g4_version = 10;
      case 10: {
        if (tag == 82) {
         parse_g4_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_g4_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->g4_version().data(), this->g4_version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "g4_version");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_vehicle_type;
        break;
      }

      // optional string vehicle_type = 11;
      case 11: {
        if (tag == 90) {
         parse_vehicle_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vehicle_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->vehicle_type().data(), this->vehicle_type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "vehicle_type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_upgrading;
        break;
      }

      // optional bool upgrading = 12;
      case 12: {
        if (tag == 96) {
         parse_upgrading:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &upgrading_)));
          set_has_upgrading();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_bcm_reg_status;
        break;
      }

      // optional bool bcm_reg_status = 13;
      case 13: {
        if (tag == 104) {
         parse_bcm_reg_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &bcm_reg_status_)));
          set_has_bcm_reg_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_ota_algrithom;
        break;
      }

      // optional uint32 ota_algrithom = 14;
      case 14: {
        if (tag == 112) {
         parse_ota_algrithom:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ota_algrithom_)));
          set_has_ota_algrithom();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.LoginReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.LoginReq)
  return false;
#undef DO_
}

void LoginReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.LoginReq)
  // required string tcu_device_sn = 1;
  if (has_tcu_device_sn()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->tcu_device_sn().data(), this->tcu_device_sn().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "tcu_device_sn");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->tcu_device_sn(), output);
  }

  // required string da_device_sn = 2;
  if (has_da_device_sn()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->da_device_sn().data(), this->da_device_sn().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "da_device_sn");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->da_device_sn(), output);
  }

  // required string vin = 3;
  if (has_vin()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->vin().data(), this->vin().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "vin");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->vin(), output);
  }

  // required string iccid = 4;
  if (has_iccid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->iccid().data(), this->iccid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "iccid");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->iccid(), output);
  }

  // required string imsi = 5;
  if (has_imsi()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->imsi().data(), this->imsi().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "imsi");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->imsi(), output);
  }

  // required string imei = 6;
  if (has_imei()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->imei().data(), this->imei().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "imei");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->imei(), output);
  }

  // required string software_version = 7;
  if (has_software_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->software_version().data(), this->software_version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "software_version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->software_version(), output);
  }

  // required string hardware_version = 8;
  if (has_hardware_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hardware_version().data(), this->hardware_version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hardware_version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->hardware_version(), output);
  }

  // required uint32 time_stamp = 9;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->time_stamp(), output);
  }

  // optional string g4_version = 10;
  if (has_g4_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->g4_version().data(), this->g4_version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "g4_version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      10, this->g4_version(), output);
  }

  // optional string vehicle_type = 11;
  if (has_vehicle_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->vehicle_type().data(), this->vehicle_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "vehicle_type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      11, this->vehicle_type(), output);
  }

  // optional bool upgrading = 12;
  if (has_upgrading()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->upgrading(), output);
  }

  // optional bool bcm_reg_status = 13;
  if (has_bcm_reg_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->bcm_reg_status(), output);
  }

  // optional uint32 ota_algrithom = 14;
  if (has_ota_algrithom()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(14, this->ota_algrithom(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.LoginReq)
}

::google::protobuf::uint8* LoginReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.LoginReq)
  // required string tcu_device_sn = 1;
  if (has_tcu_device_sn()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->tcu_device_sn().data(), this->tcu_device_sn().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "tcu_device_sn");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->tcu_device_sn(), target);
  }

  // required string da_device_sn = 2;
  if (has_da_device_sn()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->da_device_sn().data(), this->da_device_sn().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "da_device_sn");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->da_device_sn(), target);
  }

  // required string vin = 3;
  if (has_vin()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->vin().data(), this->vin().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "vin");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->vin(), target);
  }

  // required string iccid = 4;
  if (has_iccid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->iccid().data(), this->iccid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "iccid");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->iccid(), target);
  }

  // required string imsi = 5;
  if (has_imsi()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->imsi().data(), this->imsi().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "imsi");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->imsi(), target);
  }

  // required string imei = 6;
  if (has_imei()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->imei().data(), this->imei().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "imei");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->imei(), target);
  }

  // required string software_version = 7;
  if (has_software_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->software_version().data(), this->software_version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "software_version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->software_version(), target);
  }

  // required string hardware_version = 8;
  if (has_hardware_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hardware_version().data(), this->hardware_version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hardware_version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->hardware_version(), target);
  }

  // required uint32 time_stamp = 9;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->time_stamp(), target);
  }

  // optional string g4_version = 10;
  if (has_g4_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->g4_version().data(), this->g4_version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "g4_version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->g4_version(), target);
  }

  // optional string vehicle_type = 11;
  if (has_vehicle_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->vehicle_type().data(), this->vehicle_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "vehicle_type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->vehicle_type(), target);
  }

  // optional bool upgrading = 12;
  if (has_upgrading()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(12, this->upgrading(), target);
  }

  // optional bool bcm_reg_status = 13;
  if (has_bcm_reg_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(13, this->bcm_reg_status(), target);
  }

  // optional uint32 ota_algrithom = 14;
  if (has_ota_algrithom()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(14, this->ota_algrithom(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.LoginReq)
  return target;
}

int LoginReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string tcu_device_sn = 1;
    if (has_tcu_device_sn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->tcu_device_sn());
    }

    // required string da_device_sn = 2;
    if (has_da_device_sn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->da_device_sn());
    }

    // required string vin = 3;
    if (has_vin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->vin());
    }

    // required string iccid = 4;
    if (has_iccid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->iccid());
    }

    // required string imsi = 5;
    if (has_imsi()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->imsi());
    }

    // required string imei = 6;
    if (has_imei()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->imei());
    }

    // required string software_version = 7;
    if (has_software_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->software_version());
    }

    // required string hardware_version = 8;
    if (has_hardware_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hardware_version());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required uint32 time_stamp = 9;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

    // optional string g4_version = 10;
    if (has_g4_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->g4_version());
    }

    // optional string vehicle_type = 11;
    if (has_vehicle_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->vehicle_type());
    }

    // optional bool upgrading = 12;
    if (has_upgrading()) {
      total_size += 1 + 1;
    }

    // optional bool bcm_reg_status = 13;
    if (has_bcm_reg_status()) {
      total_size += 1 + 1;
    }

    // optional uint32 ota_algrithom = 14;
    if (has_ota_algrithom()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ota_algrithom());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LoginReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LoginReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LoginReq::MergeFrom(const LoginReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tcu_device_sn()) {
      set_tcu_device_sn(from.tcu_device_sn());
    }
    if (from.has_da_device_sn()) {
      set_da_device_sn(from.da_device_sn());
    }
    if (from.has_vin()) {
      set_vin(from.vin());
    }
    if (from.has_iccid()) {
      set_iccid(from.iccid());
    }
    if (from.has_imsi()) {
      set_imsi(from.imsi());
    }
    if (from.has_imei()) {
      set_imei(from.imei());
    }
    if (from.has_software_version()) {
      set_software_version(from.software_version());
    }
    if (from.has_hardware_version()) {
      set_hardware_version(from.hardware_version());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_g4_version()) {
      set_g4_version(from.g4_version());
    }
    if (from.has_vehicle_type()) {
      set_vehicle_type(from.vehicle_type());
    }
    if (from.has_upgrading()) {
      set_upgrading(from.upgrading());
    }
    if (from.has_bcm_reg_status()) {
      set_bcm_reg_status(from.bcm_reg_status());
    }
    if (from.has_ota_algrithom()) {
      set_ota_algrithom(from.ota_algrithom());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LoginReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LoginReq::CopyFrom(const LoginReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x000001ff) != 0x000001ff) return false;

  return true;
}

void LoginReq::Swap(LoginReq* other) {
  if (other != this) {
    std::swap(tcu_device_sn_, other->tcu_device_sn_);
    std::swap(da_device_sn_, other->da_device_sn_);
    std::swap(vin_, other->vin_);
    std::swap(iccid_, other->iccid_);
    std::swap(imsi_, other->imsi_);
    std::swap(imei_, other->imei_);
    std::swap(software_version_, other->software_version_);
    std::swap(hardware_version_, other->hardware_version_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(g4_version_, other->g4_version_);
    std::swap(vehicle_type_, other->vehicle_type_);
    std::swap(upgrading_, other->upgrading_);
    std::swap(bcm_reg_status_, other->bcm_reg_status_);
    std::swap(ota_algrithom_, other->ota_algrithom_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LoginReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LoginReq_descriptor_;
  metadata.reflection = LoginReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LoginRsp::kErrcodeFieldNumber;
const int LoginRsp::kTimeStampFieldNumber;
const int LoginRsp::kUpgradeinfoFieldNumber;
#endif  // !_MSC_VER

LoginRsp::LoginRsp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.LoginRsp)
}

void LoginRsp::InitAsDefaultInstance() {
}

LoginRsp::LoginRsp(const LoginRsp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.LoginRsp)
}

void LoginRsp::SharedCtor() {
  _cached_size_ = 0;
  errcode_ = 0u;
  time_stamp_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LoginRsp::~LoginRsp() {
  // @@protoc_insertion_point(destructor:zna.protocol.LoginRsp)
  SharedDtor();
}

void LoginRsp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void LoginRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LoginRsp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LoginRsp_descriptor_;
}

const LoginRsp& LoginRsp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

LoginRsp* LoginRsp::default_instance_ = NULL;

LoginRsp* LoginRsp::New() const {
  return new LoginRsp;
}

void LoginRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<LoginRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(errcode_, time_stamp_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  upgradeinfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LoginRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.LoginRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 errcode = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &errcode_)));
          set_has_errcode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_time_stamp;
        break;
      }

      // required uint32 time_stamp = 2;
      case 2: {
        if (tag == 16) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_upgradeinfo;
        break;
      }

      // repeated .zna.protocol.UpgradeInfo upgradeinfo = 3;
      case 3: {
        if (tag == 26) {
         parse_upgradeinfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_upgradeinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_upgradeinfo;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.LoginRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.LoginRsp)
  return false;
#undef DO_
}

void LoginRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.LoginRsp)
  // required uint32 errcode = 1;
  if (has_errcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->errcode(), output);
  }

  // required uint32 time_stamp = 2;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->time_stamp(), output);
  }

  // repeated .zna.protocol.UpgradeInfo upgradeinfo = 3;
  for (int i = 0; i < this->upgradeinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->upgradeinfo(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.LoginRsp)
}

::google::protobuf::uint8* LoginRsp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.LoginRsp)
  // required uint32 errcode = 1;
  if (has_errcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->errcode(), target);
  }

  // required uint32 time_stamp = 2;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->time_stamp(), target);
  }

  // repeated .zna.protocol.UpgradeInfo upgradeinfo = 3;
  for (int i = 0; i < this->upgradeinfo_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->upgradeinfo(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.LoginRsp)
  return target;
}

int LoginRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 errcode = 1;
    if (has_errcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->errcode());
    }

    // required uint32 time_stamp = 2;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

  }
  // repeated .zna.protocol.UpgradeInfo upgradeinfo = 3;
  total_size += 1 * this->upgradeinfo_size();
  for (int i = 0; i < this->upgradeinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->upgradeinfo(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LoginRsp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LoginRsp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LoginRsp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LoginRsp::MergeFrom(const LoginRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  upgradeinfo_.MergeFrom(from.upgradeinfo_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_errcode()) {
      set_errcode(from.errcode());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LoginRsp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LoginRsp::CopyFrom(const LoginRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoginRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->upgradeinfo())) return false;
  return true;
}

void LoginRsp::Swap(LoginRsp* other) {
  if (other != this) {
    std::swap(errcode_, other->errcode_);
    std::swap(time_stamp_, other->time_stamp_);
    upgradeinfo_.Swap(&other->upgradeinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LoginRsp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LoginRsp_descriptor_;
  metadata.reflection = LoginRsp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HeartbeatReq::kTimeStampFieldNumber;
#endif  // !_MSC_VER

HeartbeatReq::HeartbeatReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.HeartbeatReq)
}

void HeartbeatReq::InitAsDefaultInstance() {
}

HeartbeatReq::HeartbeatReq(const HeartbeatReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.HeartbeatReq)
}

void HeartbeatReq::SharedCtor() {
  _cached_size_ = 0;
  time_stamp_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HeartbeatReq::~HeartbeatReq() {
  // @@protoc_insertion_point(destructor:zna.protocol.HeartbeatReq)
  SharedDtor();
}

void HeartbeatReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HeartbeatReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HeartbeatReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HeartbeatReq_descriptor_;
}

const HeartbeatReq& HeartbeatReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

HeartbeatReq* HeartbeatReq::default_instance_ = NULL;

HeartbeatReq* HeartbeatReq::New() const {
  return new HeartbeatReq;
}

void HeartbeatReq::Clear() {
  time_stamp_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HeartbeatReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.HeartbeatReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 time_stamp = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.HeartbeatReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.HeartbeatReq)
  return false;
#undef DO_
}

void HeartbeatReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.HeartbeatReq)
  // required uint32 time_stamp = 1;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->time_stamp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.HeartbeatReq)
}

::google::protobuf::uint8* HeartbeatReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.HeartbeatReq)
  // required uint32 time_stamp = 1;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->time_stamp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.HeartbeatReq)
  return target;
}

int HeartbeatReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 time_stamp = 1;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HeartbeatReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HeartbeatReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HeartbeatReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HeartbeatReq::MergeFrom(const HeartbeatReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HeartbeatReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HeartbeatReq::CopyFrom(const HeartbeatReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeartbeatReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void HeartbeatReq::Swap(HeartbeatReq* other) {
  if (other != this) {
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HeartbeatReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HeartbeatReq_descriptor_;
  metadata.reflection = HeartbeatReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int HeartbeatRsp::kErrcodeFieldNumber;
const int HeartbeatRsp::kTimeStampFieldNumber;
#endif  // !_MSC_VER

HeartbeatRsp::HeartbeatRsp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.HeartbeatRsp)
}

void HeartbeatRsp::InitAsDefaultInstance() {
}

HeartbeatRsp::HeartbeatRsp(const HeartbeatRsp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.HeartbeatRsp)
}

void HeartbeatRsp::SharedCtor() {
  _cached_size_ = 0;
  errcode_ = 0u;
  time_stamp_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HeartbeatRsp::~HeartbeatRsp() {
  // @@protoc_insertion_point(destructor:zna.protocol.HeartbeatRsp)
  SharedDtor();
}

void HeartbeatRsp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HeartbeatRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HeartbeatRsp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HeartbeatRsp_descriptor_;
}

const HeartbeatRsp& HeartbeatRsp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

HeartbeatRsp* HeartbeatRsp::default_instance_ = NULL;

HeartbeatRsp* HeartbeatRsp::New() const {
  return new HeartbeatRsp;
}

void HeartbeatRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<HeartbeatRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(errcode_, time_stamp_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HeartbeatRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.HeartbeatRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 errcode = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &errcode_)));
          set_has_errcode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_time_stamp;
        break;
      }

      // required uint32 time_stamp = 2;
      case 2: {
        if (tag == 16) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.HeartbeatRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.HeartbeatRsp)
  return false;
#undef DO_
}

void HeartbeatRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.HeartbeatRsp)
  // required uint32 errcode = 1;
  if (has_errcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->errcode(), output);
  }

  // required uint32 time_stamp = 2;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->time_stamp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.HeartbeatRsp)
}

::google::protobuf::uint8* HeartbeatRsp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.HeartbeatRsp)
  // required uint32 errcode = 1;
  if (has_errcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->errcode(), target);
  }

  // required uint32 time_stamp = 2;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->time_stamp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.HeartbeatRsp)
  return target;
}

int HeartbeatRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 errcode = 1;
    if (has_errcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->errcode());
    }

    // required uint32 time_stamp = 2;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HeartbeatRsp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HeartbeatRsp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HeartbeatRsp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HeartbeatRsp::MergeFrom(const HeartbeatRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_errcode()) {
      set_errcode(from.errcode());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HeartbeatRsp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HeartbeatRsp::CopyFrom(const HeartbeatRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeartbeatRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void HeartbeatRsp::Swap(HeartbeatRsp* other) {
  if (other != this) {
    std::swap(errcode_, other->errcode_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HeartbeatRsp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HeartbeatRsp_descriptor_;
  metadata.reflection = HeartbeatRsp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SendRSAReq::kNLenFieldNumber;
const int SendRSAReq::kNStringFieldNumber;
const int SendRSAReq::kE1LenFieldNumber;
const int SendRSAReq::kE1StringFieldNumber;
const int SendRSAReq::kTimeStampFieldNumber;
#endif  // !_MSC_VER

SendRSAReq::SendRSAReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.SendRSAReq)
}

void SendRSAReq::InitAsDefaultInstance() {
}

SendRSAReq::SendRSAReq(const SendRSAReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.SendRSAReq)
}

void SendRSAReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  n_len_ = 0u;
  n_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  e1_len_ = 0u;
  e1_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  time_stamp_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SendRSAReq::~SendRSAReq() {
  // @@protoc_insertion_point(destructor:zna.protocol.SendRSAReq)
  SharedDtor();
}

void SendRSAReq::SharedDtor() {
  if (n_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete n_string_;
  }
  if (e1_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete e1_string_;
  }
  if (this != default_instance_) {
  }
}

void SendRSAReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SendRSAReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SendRSAReq_descriptor_;
}

const SendRSAReq& SendRSAReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

SendRSAReq* SendRSAReq::default_instance_ = NULL;

SendRSAReq* SendRSAReq::New() const {
  return new SendRSAReq;
}

void SendRSAReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SendRSAReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(n_len_, e1_len_);
    if (has_n_string()) {
      if (n_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        n_string_->clear();
      }
    }
    if (has_e1_string()) {
      if (e1_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        e1_string_->clear();
      }
    }
    time_stamp_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SendRSAReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.SendRSAReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 N_len = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &n_len_)));
          set_has_n_len();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_N_string;
        break;
      }

      // required string N_string = 2;
      case 2: {
        if (tag == 18) {
         parse_N_string:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_n_string()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->n_string().data(), this->n_string().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "n_string");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_E1_len;
        break;
      }

      // required uint32 E1_len = 3;
      case 3: {
        if (tag == 24) {
         parse_E1_len:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &e1_len_)));
          set_has_e1_len();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_E1_string;
        break;
      }

      // required string E1_string = 4;
      case 4: {
        if (tag == 34) {
         parse_E1_string:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_e1_string()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->e1_string().data(), this->e1_string().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "e1_string");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_time_stamp;
        break;
      }

      // required uint32 time_stamp = 5;
      case 5: {
        if (tag == 40) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.SendRSAReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.SendRSAReq)
  return false;
#undef DO_
}

void SendRSAReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.SendRSAReq)
  // required uint32 N_len = 1;
  if (has_n_len()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->n_len(), output);
  }

  // required string N_string = 2;
  if (has_n_string()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->n_string().data(), this->n_string().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "n_string");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->n_string(), output);
  }

  // required uint32 E1_len = 3;
  if (has_e1_len()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->e1_len(), output);
  }

  // required string E1_string = 4;
  if (has_e1_string()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->e1_string().data(), this->e1_string().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "e1_string");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->e1_string(), output);
  }

  // required uint32 time_stamp = 5;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->time_stamp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.SendRSAReq)
}

::google::protobuf::uint8* SendRSAReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.SendRSAReq)
  // required uint32 N_len = 1;
  if (has_n_len()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->n_len(), target);
  }

  // required string N_string = 2;
  if (has_n_string()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->n_string().data(), this->n_string().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "n_string");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->n_string(), target);
  }

  // required uint32 E1_len = 3;
  if (has_e1_len()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->e1_len(), target);
  }

  // required string E1_string = 4;
  if (has_e1_string()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->e1_string().data(), this->e1_string().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "e1_string");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->e1_string(), target);
  }

  // required uint32 time_stamp = 5;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->time_stamp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.SendRSAReq)
  return target;
}

int SendRSAReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 N_len = 1;
    if (has_n_len()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->n_len());
    }

    // required string N_string = 2;
    if (has_n_string()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->n_string());
    }

    // required uint32 E1_len = 3;
    if (has_e1_len()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->e1_len());
    }

    // required string E1_string = 4;
    if (has_e1_string()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->e1_string());
    }

    // required uint32 time_stamp = 5;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SendRSAReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SendRSAReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SendRSAReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SendRSAReq::MergeFrom(const SendRSAReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_n_len()) {
      set_n_len(from.n_len());
    }
    if (from.has_n_string()) {
      set_n_string(from.n_string());
    }
    if (from.has_e1_len()) {
      set_e1_len(from.e1_len());
    }
    if (from.has_e1_string()) {
      set_e1_string(from.e1_string());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SendRSAReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SendRSAReq::CopyFrom(const SendRSAReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendRSAReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void SendRSAReq::Swap(SendRSAReq* other) {
  if (other != this) {
    std::swap(n_len_, other->n_len_);
    std::swap(n_string_, other->n_string_);
    std::swap(e1_len_, other->e1_len_);
    std::swap(e1_string_, other->e1_string_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SendRSAReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SendRSAReq_descriptor_;
  metadata.reflection = SendRSAReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SendRC4Rsp::kErrcodeFieldNumber;
const int SendRC4Rsp::kSerialNumberFieldNumber;
const int SendRC4Rsp::kTimeStampFieldNumber;
#endif  // !_MSC_VER

SendRC4Rsp::SendRC4Rsp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.SendRC4Rsp)
}

void SendRC4Rsp::InitAsDefaultInstance() {
}

SendRC4Rsp::SendRC4Rsp(const SendRC4Rsp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.SendRC4Rsp)
}

void SendRC4Rsp::SharedCtor() {
  _cached_size_ = 0;
  errcode_ = 0u;
  serial_number_ = 0u;
  time_stamp_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SendRC4Rsp::~SendRC4Rsp() {
  // @@protoc_insertion_point(destructor:zna.protocol.SendRC4Rsp)
  SharedDtor();
}

void SendRC4Rsp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SendRC4Rsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SendRC4Rsp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SendRC4Rsp_descriptor_;
}

const SendRC4Rsp& SendRC4Rsp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

SendRC4Rsp* SendRC4Rsp::default_instance_ = NULL;

SendRC4Rsp* SendRC4Rsp::New() const {
  return new SendRC4Rsp;
}

void SendRC4Rsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SendRC4Rsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(errcode_, time_stamp_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SendRC4Rsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.SendRC4Rsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 errcode = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &errcode_)));
          set_has_errcode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_serial_number;
        break;
      }

      // required uint32 serial_number = 2;
      case 2: {
        if (tag == 16) {
         parse_serial_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serial_number_)));
          set_has_serial_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_time_stamp;
        break;
      }

      // required uint32 time_stamp = 3;
      case 3: {
        if (tag == 24) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.SendRC4Rsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.SendRC4Rsp)
  return false;
#undef DO_
}

void SendRC4Rsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.SendRC4Rsp)
  // required uint32 errcode = 1;
  if (has_errcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->errcode(), output);
  }

  // required uint32 serial_number = 2;
  if (has_serial_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->serial_number(), output);
  }

  // required uint32 time_stamp = 3;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->time_stamp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.SendRC4Rsp)
}

::google::protobuf::uint8* SendRC4Rsp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.SendRC4Rsp)
  // required uint32 errcode = 1;
  if (has_errcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->errcode(), target);
  }

  // required uint32 serial_number = 2;
  if (has_serial_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->serial_number(), target);
  }

  // required uint32 time_stamp = 3;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->time_stamp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.SendRC4Rsp)
  return target;
}

int SendRC4Rsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 errcode = 1;
    if (has_errcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->errcode());
    }

    // required uint32 serial_number = 2;
    if (has_serial_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serial_number());
    }

    // required uint32 time_stamp = 3;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SendRC4Rsp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SendRC4Rsp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SendRC4Rsp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SendRC4Rsp::MergeFrom(const SendRC4Rsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_errcode()) {
      set_errcode(from.errcode());
    }
    if (from.has_serial_number()) {
      set_serial_number(from.serial_number());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SendRC4Rsp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SendRC4Rsp::CopyFrom(const SendRC4Rsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendRC4Rsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void SendRC4Rsp::Swap(SendRC4Rsp* other) {
  if (other != this) {
    std::swap(errcode_, other->errcode_);
    std::swap(serial_number_, other->serial_number_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SendRC4Rsp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SendRC4Rsp_descriptor_;
  metadata.reflection = SendRC4Rsp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SetParameterRsp::kErrcodeFieldNumber;
const int SetParameterRsp::kTimeStampFieldNumber;
#endif  // !_MSC_VER

SetParameterRsp::SetParameterRsp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.SetParameterRsp)
}

void SetParameterRsp::InitAsDefaultInstance() {
}

SetParameterRsp::SetParameterRsp(const SetParameterRsp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.SetParameterRsp)
}

void SetParameterRsp::SharedCtor() {
  _cached_size_ = 0;
  errcode_ = 0u;
  time_stamp_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SetParameterRsp::~SetParameterRsp() {
  // @@protoc_insertion_point(destructor:zna.protocol.SetParameterRsp)
  SharedDtor();
}

void SetParameterRsp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SetParameterRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SetParameterRsp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SetParameterRsp_descriptor_;
}

const SetParameterRsp& SetParameterRsp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

SetParameterRsp* SetParameterRsp::default_instance_ = NULL;

SetParameterRsp* SetParameterRsp::New() const {
  return new SetParameterRsp;
}

void SetParameterRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SetParameterRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(errcode_, time_stamp_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SetParameterRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.SetParameterRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 errcode = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &errcode_)));
          set_has_errcode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_time_stamp;
        break;
      }

      // required uint32 time_stamp = 2;
      case 2: {
        if (tag == 16) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.SetParameterRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.SetParameterRsp)
  return false;
#undef DO_
}

void SetParameterRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.SetParameterRsp)
  // required uint32 errcode = 1;
  if (has_errcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->errcode(), output);
  }

  // required uint32 time_stamp = 2;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->time_stamp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.SetParameterRsp)
}

::google::protobuf::uint8* SetParameterRsp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.SetParameterRsp)
  // required uint32 errcode = 1;
  if (has_errcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->errcode(), target);
  }

  // required uint32 time_stamp = 2;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->time_stamp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.SetParameterRsp)
  return target;
}

int SetParameterRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 errcode = 1;
    if (has_errcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->errcode());
    }

    // required uint32 time_stamp = 2;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SetParameterRsp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SetParameterRsp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SetParameterRsp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SetParameterRsp::MergeFrom(const SetParameterRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_errcode()) {
      set_errcode(from.errcode());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SetParameterRsp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SetParameterRsp::CopyFrom(const SetParameterRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetParameterRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SetParameterRsp::Swap(SetParameterRsp* other) {
  if (other != this) {
    std::swap(errcode_, other->errcode_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SetParameterRsp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SetParameterRsp_descriptor_;
  metadata.reflection = SetParameterRsp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SetParameterReq::kLocalStorageCycleFieldNumber;
const int SetParameterReq::kUploadDataCycleNormalFieldNumber;
const int SetParameterReq::kUploadGPSCycleNormalFieldNumber;
const int SetParameterReq::kUploadDataCycleAlarmFieldNumber;
const int SetParameterReq::kUploadGPSCycleAlarmFieldNumber;
const int SetParameterReq::kHeartbeatCycleFieldNumber;
const int SetParameterReq::kServerResponseTimeoutFieldNumber;
const int SetParameterReq::kBoxResponseTimeoutFieldNumber;
const int SetParameterReq::kFlowControlSwitchFieldNumber;
const int SetParameterReq::kGPSconversionFieldNumber;
#endif  // !_MSC_VER

SetParameterReq::SetParameterReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.SetParameterReq)
}

void SetParameterReq::InitAsDefaultInstance() {
}

SetParameterReq::SetParameterReq(const SetParameterReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.SetParameterReq)
}

void SetParameterReq::SharedCtor() {
  _cached_size_ = 0;
  local_storage_cycle_ = 0u;
  upload_data_cycle_normal_ = 0u;
  upload_gps_cycle_normal_ = 0u;
  upload_data_cycle_alarm_ = 0u;
  upload_gps_cycle_alarm_ = 0u;
  heartbeat_cycle_ = 0u;
  server_response_timeout_ = 0u;
  box_response_timeout_ = 0u;
  flowcontrolswitch_ = false;
  gpsconversion_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SetParameterReq::~SetParameterReq() {
  // @@protoc_insertion_point(destructor:zna.protocol.SetParameterReq)
  SharedDtor();
}

void SetParameterReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SetParameterReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SetParameterReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SetParameterReq_descriptor_;
}

const SetParameterReq& SetParameterReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

SetParameterReq* SetParameterReq::default_instance_ = NULL;

SetParameterReq* SetParameterReq::New() const {
  return new SetParameterReq;
}

void SetParameterReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SetParameterReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(local_storage_cycle_, box_response_timeout_);
  }
  ZR_(flowcontrolswitch_, gpsconversion_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SetParameterReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.SetParameterReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 local_storage_cycle = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &local_storage_cycle_)));
          set_has_local_storage_cycle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_upload_data_cycle_normal;
        break;
      }

      // required uint32 upload_data_cycle_normal = 2;
      case 2: {
        if (tag == 16) {
         parse_upload_data_cycle_normal:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &upload_data_cycle_normal_)));
          set_has_upload_data_cycle_normal();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_upload_GPS_cycle_normal;
        break;
      }

      // required uint32 upload_GPS_cycle_normal = 3;
      case 3: {
        if (tag == 24) {
         parse_upload_GPS_cycle_normal:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &upload_gps_cycle_normal_)));
          set_has_upload_gps_cycle_normal();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_upload_data_cycle_alarm;
        break;
      }

      // required uint32 upload_data_cycle_alarm = 4;
      case 4: {
        if (tag == 32) {
         parse_upload_data_cycle_alarm:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &upload_data_cycle_alarm_)));
          set_has_upload_data_cycle_alarm();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_upload_GPS_cycle_alarm;
        break;
      }

      // required uint32 upload_GPS_cycle_alarm = 5;
      case 5: {
        if (tag == 40) {
         parse_upload_GPS_cycle_alarm:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &upload_gps_cycle_alarm_)));
          set_has_upload_gps_cycle_alarm();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_heartbeat_cycle;
        break;
      }

      // optional uint32 heartbeat_cycle = 6;
      case 6: {
        if (tag == 48) {
         parse_heartbeat_cycle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &heartbeat_cycle_)));
          set_has_heartbeat_cycle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_server_response_timeout;
        break;
      }

      // optional uint32 server_response_timeout = 7;
      case 7: {
        if (tag == 56) {
         parse_server_response_timeout:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_response_timeout_)));
          set_has_server_response_timeout();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_box_response_timeout;
        break;
      }

      // optional uint32 box_response_timeout = 8;
      case 8: {
        if (tag == 64) {
         parse_box_response_timeout:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &box_response_timeout_)));
          set_has_box_response_timeout();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_FlowControlSwitch;
        break;
      }

      // optional bool FlowControlSwitch = 9;
      case 9: {
        if (tag == 72) {
         parse_FlowControlSwitch:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &flowcontrolswitch_)));
          set_has_flowcontrolswitch();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_GPSconversion;
        break;
      }

      // optional uint32 GPSconversion = 10;
      case 10: {
        if (tag == 80) {
         parse_GPSconversion:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gpsconversion_)));
          set_has_gpsconversion();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.SetParameterReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.SetParameterReq)
  return false;
#undef DO_
}

void SetParameterReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.SetParameterReq)
  // required uint32 local_storage_cycle = 1;
  if (has_local_storage_cycle()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->local_storage_cycle(), output);
  }

  // required uint32 upload_data_cycle_normal = 2;
  if (has_upload_data_cycle_normal()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->upload_data_cycle_normal(), output);
  }

  // required uint32 upload_GPS_cycle_normal = 3;
  if (has_upload_gps_cycle_normal()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->upload_gps_cycle_normal(), output);
  }

  // required uint32 upload_data_cycle_alarm = 4;
  if (has_upload_data_cycle_alarm()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->upload_data_cycle_alarm(), output);
  }

  // required uint32 upload_GPS_cycle_alarm = 5;
  if (has_upload_gps_cycle_alarm()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->upload_gps_cycle_alarm(), output);
  }

  // optional uint32 heartbeat_cycle = 6;
  if (has_heartbeat_cycle()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->heartbeat_cycle(), output);
  }

  // optional uint32 server_response_timeout = 7;
  if (has_server_response_timeout()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->server_response_timeout(), output);
  }

  // optional uint32 box_response_timeout = 8;
  if (has_box_response_timeout()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->box_response_timeout(), output);
  }

  // optional bool FlowControlSwitch = 9;
  if (has_flowcontrolswitch()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->flowcontrolswitch(), output);
  }

  // optional uint32 GPSconversion = 10;
  if (has_gpsconversion()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(10, this->gpsconversion(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.SetParameterReq)
}

::google::protobuf::uint8* SetParameterReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.SetParameterReq)
  // required uint32 local_storage_cycle = 1;
  if (has_local_storage_cycle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->local_storage_cycle(), target);
  }

  // required uint32 upload_data_cycle_normal = 2;
  if (has_upload_data_cycle_normal()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->upload_data_cycle_normal(), target);
  }

  // required uint32 upload_GPS_cycle_normal = 3;
  if (has_upload_gps_cycle_normal()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->upload_gps_cycle_normal(), target);
  }

  // required uint32 upload_data_cycle_alarm = 4;
  if (has_upload_data_cycle_alarm()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->upload_data_cycle_alarm(), target);
  }

  // required uint32 upload_GPS_cycle_alarm = 5;
  if (has_upload_gps_cycle_alarm()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->upload_gps_cycle_alarm(), target);
  }

  // optional uint32 heartbeat_cycle = 6;
  if (has_heartbeat_cycle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->heartbeat_cycle(), target);
  }

  // optional uint32 server_response_timeout = 7;
  if (has_server_response_timeout()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->server_response_timeout(), target);
  }

  // optional uint32 box_response_timeout = 8;
  if (has_box_response_timeout()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->box_response_timeout(), target);
  }

  // optional bool FlowControlSwitch = 9;
  if (has_flowcontrolswitch()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(9, this->flowcontrolswitch(), target);
  }

  // optional uint32 GPSconversion = 10;
  if (has_gpsconversion()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(10, this->gpsconversion(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.SetParameterReq)
  return target;
}

int SetParameterReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 local_storage_cycle = 1;
    if (has_local_storage_cycle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->local_storage_cycle());
    }

    // required uint32 upload_data_cycle_normal = 2;
    if (has_upload_data_cycle_normal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->upload_data_cycle_normal());
    }

    // required uint32 upload_GPS_cycle_normal = 3;
    if (has_upload_gps_cycle_normal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->upload_gps_cycle_normal());
    }

    // required uint32 upload_data_cycle_alarm = 4;
    if (has_upload_data_cycle_alarm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->upload_data_cycle_alarm());
    }

    // required uint32 upload_GPS_cycle_alarm = 5;
    if (has_upload_gps_cycle_alarm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->upload_gps_cycle_alarm());
    }

    // optional uint32 heartbeat_cycle = 6;
    if (has_heartbeat_cycle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->heartbeat_cycle());
    }

    // optional uint32 server_response_timeout = 7;
    if (has_server_response_timeout()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_response_timeout());
    }

    // optional uint32 box_response_timeout = 8;
    if (has_box_response_timeout()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->box_response_timeout());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bool FlowControlSwitch = 9;
    if (has_flowcontrolswitch()) {
      total_size += 1 + 1;
    }

    // optional uint32 GPSconversion = 10;
    if (has_gpsconversion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gpsconversion());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SetParameterReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SetParameterReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SetParameterReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SetParameterReq::MergeFrom(const SetParameterReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_local_storage_cycle()) {
      set_local_storage_cycle(from.local_storage_cycle());
    }
    if (from.has_upload_data_cycle_normal()) {
      set_upload_data_cycle_normal(from.upload_data_cycle_normal());
    }
    if (from.has_upload_gps_cycle_normal()) {
      set_upload_gps_cycle_normal(from.upload_gps_cycle_normal());
    }
    if (from.has_upload_data_cycle_alarm()) {
      set_upload_data_cycle_alarm(from.upload_data_cycle_alarm());
    }
    if (from.has_upload_gps_cycle_alarm()) {
      set_upload_gps_cycle_alarm(from.upload_gps_cycle_alarm());
    }
    if (from.has_heartbeat_cycle()) {
      set_heartbeat_cycle(from.heartbeat_cycle());
    }
    if (from.has_server_response_timeout()) {
      set_server_response_timeout(from.server_response_timeout());
    }
    if (from.has_box_response_timeout()) {
      set_box_response_timeout(from.box_response_timeout());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_flowcontrolswitch()) {
      set_flowcontrolswitch(from.flowcontrolswitch());
    }
    if (from.has_gpsconversion()) {
      set_gpsconversion(from.gpsconversion());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SetParameterReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SetParameterReq::CopyFrom(const SetParameterReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetParameterReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void SetParameterReq::Swap(SetParameterReq* other) {
  if (other != this) {
    std::swap(local_storage_cycle_, other->local_storage_cycle_);
    std::swap(upload_data_cycle_normal_, other->upload_data_cycle_normal_);
    std::swap(upload_gps_cycle_normal_, other->upload_gps_cycle_normal_);
    std::swap(upload_data_cycle_alarm_, other->upload_data_cycle_alarm_);
    std::swap(upload_gps_cycle_alarm_, other->upload_gps_cycle_alarm_);
    std::swap(heartbeat_cycle_, other->heartbeat_cycle_);
    std::swap(server_response_timeout_, other->server_response_timeout_);
    std::swap(box_response_timeout_, other->box_response_timeout_);
    std::swap(flowcontrolswitch_, other->flowcontrolswitch_);
    std::swap(gpsconversion_, other->gpsconversion_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SetParameterReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SetParameterReq_descriptor_;
  metadata.reflection = SetParameterReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GetParameterRsp::kErrcodeFieldNumber;
const int GetParameterRsp::kLocalStorageCycleFieldNumber;
const int GetParameterRsp::kUploadDataCycleNormalFieldNumber;
const int GetParameterRsp::kUploadGPSCycleNormalFieldNumber;
const int GetParameterRsp::kUploadDataCycleAlarmFieldNumber;
const int GetParameterRsp::kUploadGPSCycleAlarmFieldNumber;
const int GetParameterRsp::kHeartbeatCycleFieldNumber;
const int GetParameterRsp::kServerResponseTimeoutFieldNumber;
const int GetParameterRsp::kBoxResponseTimeoutFieldNumber;
const int GetParameterRsp::kFirmwareVersionFieldNumber;
const int GetParameterRsp::kHardwareVersionFieldNumber;
const int GetParameterRsp::kTimeStampFieldNumber;
#endif  // !_MSC_VER

GetParameterRsp::GetParameterRsp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.GetParameterRsp)
}

void GetParameterRsp::InitAsDefaultInstance() {
}

GetParameterRsp::GetParameterRsp(const GetParameterRsp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.GetParameterRsp)
}

void GetParameterRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  errcode_ = 0u;
  local_storage_cycle_ = 0u;
  upload_data_cycle_normal_ = 0u;
  upload_gps_cycle_normal_ = 0u;
  upload_data_cycle_alarm_ = 0u;
  upload_gps_cycle_alarm_ = 0u;
  heartbeat_cycle_ = 0u;
  server_response_timeout_ = 0u;
  box_response_timeout_ = 0u;
  firmware_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hardware_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  time_stamp_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetParameterRsp::~GetParameterRsp() {
  // @@protoc_insertion_point(destructor:zna.protocol.GetParameterRsp)
  SharedDtor();
}

void GetParameterRsp::SharedDtor() {
  if (firmware_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete firmware_version_;
  }
  if (hardware_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hardware_version_;
  }
  if (this != default_instance_) {
  }
}

void GetParameterRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetParameterRsp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetParameterRsp_descriptor_;
}

const GetParameterRsp& GetParameterRsp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

GetParameterRsp* GetParameterRsp::default_instance_ = NULL;

GetParameterRsp* GetParameterRsp::New() const {
  return new GetParameterRsp;
}

void GetParameterRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GetParameterRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(errcode_, server_response_timeout_);
  }
  if (_has_bits_[8 / 32] & 3840) {
    ZR_(box_response_timeout_, time_stamp_);
    if (has_firmware_version()) {
      if (firmware_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        firmware_version_->clear();
      }
    }
    if (has_hardware_version()) {
      if (hardware_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        hardware_version_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetParameterRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.GetParameterRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 errcode = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &errcode_)));
          set_has_errcode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_local_storage_cycle;
        break;
      }

      // required uint32 local_storage_cycle = 2;
      case 2: {
        if (tag == 16) {
         parse_local_storage_cycle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &local_storage_cycle_)));
          set_has_local_storage_cycle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_upload_data_cycle_normal;
        break;
      }

      // required uint32 upload_data_cycle_normal = 3;
      case 3: {
        if (tag == 24) {
         parse_upload_data_cycle_normal:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &upload_data_cycle_normal_)));
          set_has_upload_data_cycle_normal();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_upload_GPS_cycle_normal;
        break;
      }

      // required uint32 upload_GPS_cycle_normal = 4;
      case 4: {
        if (tag == 32) {
         parse_upload_GPS_cycle_normal:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &upload_gps_cycle_normal_)));
          set_has_upload_gps_cycle_normal();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_upload_data_cycle_alarm;
        break;
      }

      // required uint32 upload_data_cycle_alarm = 5;
      case 5: {
        if (tag == 40) {
         parse_upload_data_cycle_alarm:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &upload_data_cycle_alarm_)));
          set_has_upload_data_cycle_alarm();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_upload_GPS_cycle_alarm;
        break;
      }

      // required uint32 upload_GPS_cycle_alarm = 6;
      case 6: {
        if (tag == 48) {
         parse_upload_GPS_cycle_alarm:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &upload_gps_cycle_alarm_)));
          set_has_upload_gps_cycle_alarm();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_heartbeat_cycle;
        break;
      }

      // required uint32 heartbeat_cycle = 7;
      case 7: {
        if (tag == 56) {
         parse_heartbeat_cycle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &heartbeat_cycle_)));
          set_has_heartbeat_cycle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_server_response_timeout;
        break;
      }

      // required uint32 server_response_timeout = 8;
      case 8: {
        if (tag == 64) {
         parse_server_response_timeout:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &server_response_timeout_)));
          set_has_server_response_timeout();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_box_response_timeout;
        break;
      }

      // required uint32 box_response_timeout = 9;
      case 9: {
        if (tag == 72) {
         parse_box_response_timeout:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &box_response_timeout_)));
          set_has_box_response_timeout();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_firmware_version;
        break;
      }

      // required string firmware_version = 10;
      case 10: {
        if (tag == 82) {
         parse_firmware_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_firmware_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->firmware_version().data(), this->firmware_version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "firmware_version");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_hardware_version;
        break;
      }

      // required string hardware_version = 11;
      case 11: {
        if (tag == 90) {
         parse_hardware_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hardware_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->hardware_version().data(), this->hardware_version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hardware_version");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_time_stamp;
        break;
      }

      // required uint32 time_stamp = 12;
      case 12: {
        if (tag == 96) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.GetParameterRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.GetParameterRsp)
  return false;
#undef DO_
}

void GetParameterRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.GetParameterRsp)
  // required uint32 errcode = 1;
  if (has_errcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->errcode(), output);
  }

  // required uint32 local_storage_cycle = 2;
  if (has_local_storage_cycle()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->local_storage_cycle(), output);
  }

  // required uint32 upload_data_cycle_normal = 3;
  if (has_upload_data_cycle_normal()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->upload_data_cycle_normal(), output);
  }

  // required uint32 upload_GPS_cycle_normal = 4;
  if (has_upload_gps_cycle_normal()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->upload_gps_cycle_normal(), output);
  }

  // required uint32 upload_data_cycle_alarm = 5;
  if (has_upload_data_cycle_alarm()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->upload_data_cycle_alarm(), output);
  }

  // required uint32 upload_GPS_cycle_alarm = 6;
  if (has_upload_gps_cycle_alarm()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->upload_gps_cycle_alarm(), output);
  }

  // required uint32 heartbeat_cycle = 7;
  if (has_heartbeat_cycle()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->heartbeat_cycle(), output);
  }

  // required uint32 server_response_timeout = 8;
  if (has_server_response_timeout()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->server_response_timeout(), output);
  }

  // required uint32 box_response_timeout = 9;
  if (has_box_response_timeout()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->box_response_timeout(), output);
  }

  // required string firmware_version = 10;
  if (has_firmware_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->firmware_version().data(), this->firmware_version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "firmware_version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      10, this->firmware_version(), output);
  }

  // required string hardware_version = 11;
  if (has_hardware_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hardware_version().data(), this->hardware_version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hardware_version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      11, this->hardware_version(), output);
  }

  // required uint32 time_stamp = 12;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->time_stamp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.GetParameterRsp)
}

::google::protobuf::uint8* GetParameterRsp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.GetParameterRsp)
  // required uint32 errcode = 1;
  if (has_errcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->errcode(), target);
  }

  // required uint32 local_storage_cycle = 2;
  if (has_local_storage_cycle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->local_storage_cycle(), target);
  }

  // required uint32 upload_data_cycle_normal = 3;
  if (has_upload_data_cycle_normal()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->upload_data_cycle_normal(), target);
  }

  // required uint32 upload_GPS_cycle_normal = 4;
  if (has_upload_gps_cycle_normal()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->upload_gps_cycle_normal(), target);
  }

  // required uint32 upload_data_cycle_alarm = 5;
  if (has_upload_data_cycle_alarm()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->upload_data_cycle_alarm(), target);
  }

  // required uint32 upload_GPS_cycle_alarm = 6;
  if (has_upload_gps_cycle_alarm()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->upload_gps_cycle_alarm(), target);
  }

  // required uint32 heartbeat_cycle = 7;
  if (has_heartbeat_cycle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->heartbeat_cycle(), target);
  }

  // required uint32 server_response_timeout = 8;
  if (has_server_response_timeout()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->server_response_timeout(), target);
  }

  // required uint32 box_response_timeout = 9;
  if (has_box_response_timeout()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->box_response_timeout(), target);
  }

  // required string firmware_version = 10;
  if (has_firmware_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->firmware_version().data(), this->firmware_version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "firmware_version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->firmware_version(), target);
  }

  // required string hardware_version = 11;
  if (has_hardware_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hardware_version().data(), this->hardware_version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hardware_version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->hardware_version(), target);
  }

  // required uint32 time_stamp = 12;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->time_stamp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.GetParameterRsp)
  return target;
}

int GetParameterRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 errcode = 1;
    if (has_errcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->errcode());
    }

    // required uint32 local_storage_cycle = 2;
    if (has_local_storage_cycle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->local_storage_cycle());
    }

    // required uint32 upload_data_cycle_normal = 3;
    if (has_upload_data_cycle_normal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->upload_data_cycle_normal());
    }

    // required uint32 upload_GPS_cycle_normal = 4;
    if (has_upload_gps_cycle_normal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->upload_gps_cycle_normal());
    }

    // required uint32 upload_data_cycle_alarm = 5;
    if (has_upload_data_cycle_alarm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->upload_data_cycle_alarm());
    }

    // required uint32 upload_GPS_cycle_alarm = 6;
    if (has_upload_gps_cycle_alarm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->upload_gps_cycle_alarm());
    }

    // required uint32 heartbeat_cycle = 7;
    if (has_heartbeat_cycle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->heartbeat_cycle());
    }

    // required uint32 server_response_timeout = 8;
    if (has_server_response_timeout()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->server_response_timeout());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required uint32 box_response_timeout = 9;
    if (has_box_response_timeout()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->box_response_timeout());
    }

    // required string firmware_version = 10;
    if (has_firmware_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->firmware_version());
    }

    // required string hardware_version = 11;
    if (has_hardware_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hardware_version());
    }

    // required uint32 time_stamp = 12;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetParameterRsp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetParameterRsp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetParameterRsp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetParameterRsp::MergeFrom(const GetParameterRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_errcode()) {
      set_errcode(from.errcode());
    }
    if (from.has_local_storage_cycle()) {
      set_local_storage_cycle(from.local_storage_cycle());
    }
    if (from.has_upload_data_cycle_normal()) {
      set_upload_data_cycle_normal(from.upload_data_cycle_normal());
    }
    if (from.has_upload_gps_cycle_normal()) {
      set_upload_gps_cycle_normal(from.upload_gps_cycle_normal());
    }
    if (from.has_upload_data_cycle_alarm()) {
      set_upload_data_cycle_alarm(from.upload_data_cycle_alarm());
    }
    if (from.has_upload_gps_cycle_alarm()) {
      set_upload_gps_cycle_alarm(from.upload_gps_cycle_alarm());
    }
    if (from.has_heartbeat_cycle()) {
      set_heartbeat_cycle(from.heartbeat_cycle());
    }
    if (from.has_server_response_timeout()) {
      set_server_response_timeout(from.server_response_timeout());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_box_response_timeout()) {
      set_box_response_timeout(from.box_response_timeout());
    }
    if (from.has_firmware_version()) {
      set_firmware_version(from.firmware_version());
    }
    if (from.has_hardware_version()) {
      set_hardware_version(from.hardware_version());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetParameterRsp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetParameterRsp::CopyFrom(const GetParameterRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetParameterRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000fff) != 0x00000fff) return false;

  return true;
}

void GetParameterRsp::Swap(GetParameterRsp* other) {
  if (other != this) {
    std::swap(errcode_, other->errcode_);
    std::swap(local_storage_cycle_, other->local_storage_cycle_);
    std::swap(upload_data_cycle_normal_, other->upload_data_cycle_normal_);
    std::swap(upload_gps_cycle_normal_, other->upload_gps_cycle_normal_);
    std::swap(upload_data_cycle_alarm_, other->upload_data_cycle_alarm_);
    std::swap(upload_gps_cycle_alarm_, other->upload_gps_cycle_alarm_);
    std::swap(heartbeat_cycle_, other->heartbeat_cycle_);
    std::swap(server_response_timeout_, other->server_response_timeout_);
    std::swap(box_response_timeout_, other->box_response_timeout_);
    std::swap(firmware_version_, other->firmware_version_);
    std::swap(hardware_version_, other->hardware_version_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetParameterRsp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetParameterRsp_descriptor_;
  metadata.reflection = GetParameterRsp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GetParameterReq::kTimeStampFieldNumber;
#endif  // !_MSC_VER

GetParameterReq::GetParameterReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.GetParameterReq)
}

void GetParameterReq::InitAsDefaultInstance() {
}

GetParameterReq::GetParameterReq(const GetParameterReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.GetParameterReq)
}

void GetParameterReq::SharedCtor() {
  _cached_size_ = 0;
  time_stamp_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetParameterReq::~GetParameterReq() {
  // @@protoc_insertion_point(destructor:zna.protocol.GetParameterReq)
  SharedDtor();
}

void GetParameterReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GetParameterReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GetParameterReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GetParameterReq_descriptor_;
}

const GetParameterReq& GetParameterReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

GetParameterReq* GetParameterReq::default_instance_ = NULL;

GetParameterReq* GetParameterReq::New() const {
  return new GetParameterReq;
}

void GetParameterReq::Clear() {
  time_stamp_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GetParameterReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.GetParameterReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 time_stamp = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.GetParameterReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.GetParameterReq)
  return false;
#undef DO_
}

void GetParameterReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.GetParameterReq)
  // required uint32 time_stamp = 1;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->time_stamp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.GetParameterReq)
}

::google::protobuf::uint8* GetParameterReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.GetParameterReq)
  // required uint32 time_stamp = 1;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->time_stamp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.GetParameterReq)
  return target;
}

int GetParameterReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 time_stamp = 1;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetParameterReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GetParameterReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GetParameterReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GetParameterReq::MergeFrom(const GetParameterReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GetParameterReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetParameterReq::CopyFrom(const GetParameterReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetParameterReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetParameterReq::Swap(GetParameterReq* other) {
  if (other != this) {
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GetParameterReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GetParameterReq_descriptor_;
  metadata.reflection = GetParameterReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ECM_Info::kEngineRPMFieldNumber;
const int ECM_Info::kEngineStatusFieldNumber;
const int ECM_Info::kEngineCoolantTempFieldNumber;
const int ECM_Info::kMILLampFieldNumber;
const int ECM_Info::kSVSLampFieldNumber;
const int ECM_Info::kOilPressLampFieldNumber;
const int ECM_Info::kUreaLampFieldNumber;
const int ECM_Info::kFilterwaterDetFieldNumber;
const int ECM_Info::kBatteryChargeStsFieldNumber;
#endif  // !_MSC_VER

ECM_Info::ECM_Info()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.ECM_Info)
}

void ECM_Info::InitAsDefaultInstance() {
}

ECM_Info::ECM_Info(const ECM_Info& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.ECM_Info)
}

void ECM_Info::SharedCtor() {
  _cached_size_ = 0;
  enginerpm_ = 0u;
  enginestatus_ = 0u;
  enginecoolanttemp_ = 0u;
  millamp_ = 0u;
  svslamp_ = 0u;
  oilpress_lamp_ = 0u;
  urealamp_ = 0u;
  filterwater_det_ = false;
  batterycharge_sts_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ECM_Info::~ECM_Info() {
  // @@protoc_insertion_point(destructor:zna.protocol.ECM_Info)
  SharedDtor();
}

void ECM_Info::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ECM_Info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ECM_Info::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ECM_Info_descriptor_;
}

const ECM_Info& ECM_Info::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

ECM_Info* ECM_Info::default_instance_ = NULL;

ECM_Info* ECM_Info::New() const {
  return new ECM_Info;
}

void ECM_Info::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ECM_Info*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(enginerpm_, filterwater_det_);
  }
  batterycharge_sts_ = false;

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ECM_Info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.ECM_Info)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 EngineRPM = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &enginerpm_)));
          set_has_enginerpm();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_EngineStatus;
        break;
      }

      // optional uint32 EngineStatus = 4;
      case 4: {
        if (tag == 32) {
         parse_EngineStatus:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &enginestatus_)));
          set_has_enginestatus();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_EngineCoolantTemp;
        break;
      }

      // optional uint32 EngineCoolantTemp = 5;
      case 5: {
        if (tag == 40) {
         parse_EngineCoolantTemp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &enginecoolanttemp_)));
          set_has_enginecoolanttemp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(168)) goto parse_MILLamp;
        break;
      }

      // optional uint32 MILLamp = 21;
      case 21: {
        if (tag == 168) {
         parse_MILLamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &millamp_)));
          set_has_millamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(176)) goto parse_SVSLamp;
        break;
      }

      // optional uint32 SVSLamp = 22;
      case 22: {
        if (tag == 176) {
         parse_SVSLamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &svslamp_)));
          set_has_svslamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(184)) goto parse_OilPress_Lamp;
        break;
      }

      // optional uint32 OilPress_Lamp = 23;
      case 23: {
        if (tag == 184) {
         parse_OilPress_Lamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &oilpress_lamp_)));
          set_has_oilpress_lamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(192)) goto parse_UreaLamp;
        break;
      }

      // optional uint32 UreaLamp = 24;
      case 24: {
        if (tag == 192) {
         parse_UreaLamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &urealamp_)));
          set_has_urealamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(200)) goto parse_Filterwater_Det;
        break;
      }

      // optional bool Filterwater_Det = 25;
      case 25: {
        if (tag == 200) {
         parse_Filterwater_Det:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &filterwater_det_)));
          set_has_filterwater_det();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(208)) goto parse_BatteryCharge_Sts;
        break;
      }

      // optional bool BatteryCharge_Sts = 26;
      case 26: {
        if (tag == 208) {
         parse_BatteryCharge_Sts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &batterycharge_sts_)));
          set_has_batterycharge_sts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.ECM_Info)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.ECM_Info)
  return false;
#undef DO_
}

void ECM_Info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.ECM_Info)
  // optional uint32 EngineRPM = 1;
  if (has_enginerpm()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->enginerpm(), output);
  }

  // optional uint32 EngineStatus = 4;
  if (has_enginestatus()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->enginestatus(), output);
  }

  // optional uint32 EngineCoolantTemp = 5;
  if (has_enginecoolanttemp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->enginecoolanttemp(), output);
  }

  // optional uint32 MILLamp = 21;
  if (has_millamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(21, this->millamp(), output);
  }

  // optional uint32 SVSLamp = 22;
  if (has_svslamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(22, this->svslamp(), output);
  }

  // optional uint32 OilPress_Lamp = 23;
  if (has_oilpress_lamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(23, this->oilpress_lamp(), output);
  }

  // optional uint32 UreaLamp = 24;
  if (has_urealamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(24, this->urealamp(), output);
  }

  // optional bool Filterwater_Det = 25;
  if (has_filterwater_det()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(25, this->filterwater_det(), output);
  }

  // optional bool BatteryCharge_Sts = 26;
  if (has_batterycharge_sts()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(26, this->batterycharge_sts(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.ECM_Info)
}

::google::protobuf::uint8* ECM_Info::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.ECM_Info)
  // optional uint32 EngineRPM = 1;
  if (has_enginerpm()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->enginerpm(), target);
  }

  // optional uint32 EngineStatus = 4;
  if (has_enginestatus()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->enginestatus(), target);
  }

  // optional uint32 EngineCoolantTemp = 5;
  if (has_enginecoolanttemp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->enginecoolanttemp(), target);
  }

  // optional uint32 MILLamp = 21;
  if (has_millamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(21, this->millamp(), target);
  }

  // optional uint32 SVSLamp = 22;
  if (has_svslamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(22, this->svslamp(), target);
  }

  // optional uint32 OilPress_Lamp = 23;
  if (has_oilpress_lamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(23, this->oilpress_lamp(), target);
  }

  // optional uint32 UreaLamp = 24;
  if (has_urealamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(24, this->urealamp(), target);
  }

  // optional bool Filterwater_Det = 25;
  if (has_filterwater_det()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(25, this->filterwater_det(), target);
  }

  // optional bool BatteryCharge_Sts = 26;
  if (has_batterycharge_sts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(26, this->batterycharge_sts(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.ECM_Info)
  return target;
}

int ECM_Info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 EngineRPM = 1;
    if (has_enginerpm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->enginerpm());
    }

    // optional uint32 EngineStatus = 4;
    if (has_enginestatus()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->enginestatus());
    }

    // optional uint32 EngineCoolantTemp = 5;
    if (has_enginecoolanttemp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->enginecoolanttemp());
    }

    // optional uint32 MILLamp = 21;
    if (has_millamp()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->millamp());
    }

    // optional uint32 SVSLamp = 22;
    if (has_svslamp()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->svslamp());
    }

    // optional uint32 OilPress_Lamp = 23;
    if (has_oilpress_lamp()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->oilpress_lamp());
    }

    // optional uint32 UreaLamp = 24;
    if (has_urealamp()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->urealamp());
    }

    // optional bool Filterwater_Det = 25;
    if (has_filterwater_det()) {
      total_size += 2 + 1;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bool BatteryCharge_Sts = 26;
    if (has_batterycharge_sts()) {
      total_size += 2 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ECM_Info::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ECM_Info* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ECM_Info*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ECM_Info::MergeFrom(const ECM_Info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_enginerpm()) {
      set_enginerpm(from.enginerpm());
    }
    if (from.has_enginestatus()) {
      set_enginestatus(from.enginestatus());
    }
    if (from.has_enginecoolanttemp()) {
      set_enginecoolanttemp(from.enginecoolanttemp());
    }
    if (from.has_millamp()) {
      set_millamp(from.millamp());
    }
    if (from.has_svslamp()) {
      set_svslamp(from.svslamp());
    }
    if (from.has_oilpress_lamp()) {
      set_oilpress_lamp(from.oilpress_lamp());
    }
    if (from.has_urealamp()) {
      set_urealamp(from.urealamp());
    }
    if (from.has_filterwater_det()) {
      set_filterwater_det(from.filterwater_det());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_batterycharge_sts()) {
      set_batterycharge_sts(from.batterycharge_sts());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ECM_Info::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ECM_Info::CopyFrom(const ECM_Info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ECM_Info::IsInitialized() const {

  return true;
}

void ECM_Info::Swap(ECM_Info* other) {
  if (other != this) {
    std::swap(enginerpm_, other->enginerpm_);
    std::swap(enginestatus_, other->enginestatus_);
    std::swap(enginecoolanttemp_, other->enginecoolanttemp_);
    std::swap(millamp_, other->millamp_);
    std::swap(svslamp_, other->svslamp_);
    std::swap(oilpress_lamp_, other->oilpress_lamp_);
    std::swap(urealamp_, other->urealamp_);
    std::swap(filterwater_det_, other->filterwater_det_);
    std::swap(batterycharge_sts_, other->batterycharge_sts_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ECM_Info::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ECM_Info_descriptor_;
  metadata.reflection = ECM_Info_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int METER_Info::kAverageFuelEconomyFieldNumber;
const int METER_Info::kDistanceToEmptyFieldNumber;
const int METER_Info::kDistanceTotalizerFieldNumber;
const int METER_Info::kFuelRemainFieldNumber;
const int METER_Info::kTotalOdoValidFieldNumber;
const int METER_Info::kOilPresFieldNumber;
const int METER_Info::kBrakeFailureFieldNumber;
const int METER_Info::kInstandFuelFieldNumber;
#endif  // !_MSC_VER

METER_Info::METER_Info()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.METER_Info)
}

void METER_Info::InitAsDefaultInstance() {
}

METER_Info::METER_Info(const METER_Info& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.METER_Info)
}

void METER_Info::SharedCtor() {
  _cached_size_ = 0;
  average_fuel_economy_ = 0u;
  distance_to_empty_ = 0u;
  distance_totalizer_ = 0u;
  fuel_remain_ = 0u;
  totalodo_valid_ = false;
  oilpres_ = false;
  brakefailure_ = 0u;
  instandfuel_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

METER_Info::~METER_Info() {
  // @@protoc_insertion_point(destructor:zna.protocol.METER_Info)
  SharedDtor();
}

void METER_Info::SharedDtor() {
  if (this != default_instance_) {
  }
}

void METER_Info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* METER_Info::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return METER_Info_descriptor_;
}

const METER_Info& METER_Info::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

METER_Info* METER_Info::default_instance_ = NULL;

METER_Info* METER_Info::New() const {
  return new METER_Info;
}

void METER_Info::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<METER_Info*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(average_fuel_economy_, instandfuel_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool METER_Info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.METER_Info)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 Average_Fuel_Economy = 2;
      case 2: {
        if (tag == 16) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &average_fuel_economy_)));
          set_has_average_fuel_economy();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Distance_to_empty;
        break;
      }

      // optional uint32 Distance_to_empty = 3;
      case 3: {
        if (tag == 24) {
         parse_Distance_to_empty:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &distance_to_empty_)));
          set_has_distance_to_empty();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_Distance_Totalizer;
        break;
      }

      // optional uint32 Distance_Totalizer = 4;
      case 4: {
        if (tag == 32) {
         parse_Distance_Totalizer:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &distance_totalizer_)));
          set_has_distance_totalizer();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_Fuel_Remain;
        break;
      }

      // optional uint32 Fuel_Remain = 5;
      case 5: {
        if (tag == 40) {
         parse_Fuel_Remain:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fuel_remain_)));
          set_has_fuel_remain();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_TotalOdo_Valid;
        break;
      }

      // optional bool TotalOdo_Valid = 13;
      case 13: {
        if (tag == 104) {
         parse_TotalOdo_Valid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &totalodo_valid_)));
          set_has_totalodo_valid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_OilPres;
        break;
      }

      // optional bool OilPres = 14;
      case 14: {
        if (tag == 112) {
         parse_OilPres:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &oilpres_)));
          set_has_oilpres();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_BrakeFailure;
        break;
      }

      // optional uint32 BrakeFailure = 15;
      case 15: {
        if (tag == 120) {
         parse_BrakeFailure:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &brakefailure_)));
          set_has_brakefailure();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(128)) goto parse_InstandFuel;
        break;
      }

      // optional uint32 InstandFuel = 16;
      case 16: {
        if (tag == 128) {
         parse_InstandFuel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &instandfuel_)));
          set_has_instandfuel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.METER_Info)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.METER_Info)
  return false;
#undef DO_
}

void METER_Info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.METER_Info)
  // optional uint32 Average_Fuel_Economy = 2;
  if (has_average_fuel_economy()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->average_fuel_economy(), output);
  }

  // optional uint32 Distance_to_empty = 3;
  if (has_distance_to_empty()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->distance_to_empty(), output);
  }

  // optional uint32 Distance_Totalizer = 4;
  if (has_distance_totalizer()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->distance_totalizer(), output);
  }

  // optional uint32 Fuel_Remain = 5;
  if (has_fuel_remain()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->fuel_remain(), output);
  }

  // optional bool TotalOdo_Valid = 13;
  if (has_totalodo_valid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(13, this->totalodo_valid(), output);
  }

  // optional bool OilPres = 14;
  if (has_oilpres()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(14, this->oilpres(), output);
  }

  // optional uint32 BrakeFailure = 15;
  if (has_brakefailure()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(15, this->brakefailure(), output);
  }

  // optional uint32 InstandFuel = 16;
  if (has_instandfuel()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(16, this->instandfuel(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.METER_Info)
}

::google::protobuf::uint8* METER_Info::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.METER_Info)
  // optional uint32 Average_Fuel_Economy = 2;
  if (has_average_fuel_economy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->average_fuel_economy(), target);
  }

  // optional uint32 Distance_to_empty = 3;
  if (has_distance_to_empty()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->distance_to_empty(), target);
  }

  // optional uint32 Distance_Totalizer = 4;
  if (has_distance_totalizer()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->distance_totalizer(), target);
  }

  // optional uint32 Fuel_Remain = 5;
  if (has_fuel_remain()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->fuel_remain(), target);
  }

  // optional bool TotalOdo_Valid = 13;
  if (has_totalodo_valid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(13, this->totalodo_valid(), target);
  }

  // optional bool OilPres = 14;
  if (has_oilpres()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(14, this->oilpres(), target);
  }

  // optional uint32 BrakeFailure = 15;
  if (has_brakefailure()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(15, this->brakefailure(), target);
  }

  // optional uint32 InstandFuel = 16;
  if (has_instandfuel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(16, this->instandfuel(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.METER_Info)
  return target;
}

int METER_Info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 Average_Fuel_Economy = 2;
    if (has_average_fuel_economy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->average_fuel_economy());
    }

    // optional uint32 Distance_to_empty = 3;
    if (has_distance_to_empty()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->distance_to_empty());
    }

    // optional uint32 Distance_Totalizer = 4;
    if (has_distance_totalizer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->distance_totalizer());
    }

    // optional uint32 Fuel_Remain = 5;
    if (has_fuel_remain()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fuel_remain());
    }

    // optional bool TotalOdo_Valid = 13;
    if (has_totalodo_valid()) {
      total_size += 1 + 1;
    }

    // optional bool OilPres = 14;
    if (has_oilpres()) {
      total_size += 1 + 1;
    }

    // optional uint32 BrakeFailure = 15;
    if (has_brakefailure()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->brakefailure());
    }

    // optional uint32 InstandFuel = 16;
    if (has_instandfuel()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->instandfuel());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void METER_Info::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const METER_Info* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const METER_Info*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void METER_Info::MergeFrom(const METER_Info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_average_fuel_economy()) {
      set_average_fuel_economy(from.average_fuel_economy());
    }
    if (from.has_distance_to_empty()) {
      set_distance_to_empty(from.distance_to_empty());
    }
    if (from.has_distance_totalizer()) {
      set_distance_totalizer(from.distance_totalizer());
    }
    if (from.has_fuel_remain()) {
      set_fuel_remain(from.fuel_remain());
    }
    if (from.has_totalodo_valid()) {
      set_totalodo_valid(from.totalodo_valid());
    }
    if (from.has_oilpres()) {
      set_oilpres(from.oilpres());
    }
    if (from.has_brakefailure()) {
      set_brakefailure(from.brakefailure());
    }
    if (from.has_instandfuel()) {
      set_instandfuel(from.instandfuel());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void METER_Info::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void METER_Info::CopyFrom(const METER_Info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool METER_Info::IsInitialized() const {

  return true;
}

void METER_Info::Swap(METER_Info* other) {
  if (other != this) {
    std::swap(average_fuel_economy_, other->average_fuel_economy_);
    std::swap(distance_to_empty_, other->distance_to_empty_);
    std::swap(distance_totalizer_, other->distance_totalizer_);
    std::swap(fuel_remain_, other->fuel_remain_);
    std::swap(totalodo_valid_, other->totalodo_valid_);
    std::swap(oilpres_, other->oilpres_);
    std::swap(brakefailure_, other->brakefailure_);
    std::swap(instandfuel_, other->instandfuel_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata METER_Info::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = METER_Info_descriptor_;
  metadata.reflection = METER_Info_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int BCM_Info::kFrontLeftDoorStatusFieldNumber;
const int BCM_Info::kFrontRightDoorStatusFieldNumber;
const int BCM_Info::kRearLeftDoorStatusFieldNumber;
const int BCM_Info::kRearRightDoorStatusFieldNumber;
const int BCM_Info::kBackDoorStatusFieldNumber;
const int BCM_Info::kBackDoorLockedStatusFieldNumber;
const int BCM_Info::kLowBeamRequestFieldNumber;
const int BCM_Info::kHighBeamRequestFieldNumber;
const int BCM_Info::kSWIIGKFieldNumber;
const int BCM_Info::kDoorOpenWarningFieldNumber;
const int BCM_Info::kLightOnWarningFieldNumber;
const int BCM_Info::kTPMSMILReqFieldNumber;
const int BCM_Info::kStopLampFailStsFieldNumber;
const int BCM_Info::kRemoteVecSearchStsFieldNumber;
const int BCM_Info::kDriverDoorLockStsFieldNumber;
const int BCM_Info::kKeyAlarmStsFieldNumber;
const int BCM_Info::kHoodStatusFieldNumber;
const int BCM_Info::kAccStatusFieldNumber;
const int BCM_Info::kRemoteEngingRunFlagFieldNumber;
#endif  // !_MSC_VER

BCM_Info::BCM_Info()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.BCM_Info)
}

void BCM_Info::InitAsDefaultInstance() {
}

BCM_Info::BCM_Info(const BCM_Info& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.BCM_Info)
}

void BCM_Info::SharedCtor() {
  _cached_size_ = 0;
  front_left_door_status_ = false;
  front_right_door_status_ = false;
  rear_left_door_status_ = false;
  rear_right_door_status_ = false;
  back_door_status_ = false;
  back_door_locked_status_ = false;
  lowbeamrequest_ = false;
  highbeamrequest_ = false;
  swiigk_ = false;
  dooropen_warning_ = false;
  lighton_warning_ = false;
  tpmsmil_req_ = 0u;
  stoplampfailsts_ = false;
  remotevecsearchsts_ = false;
  driverdoorlocksts_ = false;
  keyalarmsts_ = 0u;
  hoodstatus_ = false;
  accstatus_ = false;
  remote_enging_run_flag_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

BCM_Info::~BCM_Info() {
  // @@protoc_insertion_point(destructor:zna.protocol.BCM_Info)
  SharedDtor();
}

void BCM_Info::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BCM_Info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BCM_Info::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BCM_Info_descriptor_;
}

const BCM_Info& BCM_Info::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

BCM_Info* BCM_Info::default_instance_ = NULL;

BCM_Info* BCM_Info::New() const {
  return new BCM_Info;
}

void BCM_Info::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<BCM_Info*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(front_left_door_status_, highbeamrequest_);
  }
  if (_has_bits_[8 / 32] & 65280) {
    ZR_(swiigk_, driverdoorlocksts_);
  }
  ZR_(hoodstatus_, remote_enging_run_flag_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool BCM_Info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.BCM_Info)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool front_left_door_status = 3;
      case 3: {
        if (tag == 24) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &front_left_door_status_)));
          set_has_front_left_door_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_front_right_door_status;
        break;
      }

      // optional bool front_right_door_status = 4;
      case 4: {
        if (tag == 32) {
         parse_front_right_door_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &front_right_door_status_)));
          set_has_front_right_door_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_rear_left_door_status;
        break;
      }

      // optional bool rear_left_door_status = 5;
      case 5: {
        if (tag == 40) {
         parse_rear_left_door_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &rear_left_door_status_)));
          set_has_rear_left_door_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_rear_right_door_status;
        break;
      }

      // optional bool rear_right_door_status = 6;
      case 6: {
        if (tag == 48) {
         parse_rear_right_door_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &rear_right_door_status_)));
          set_has_rear_right_door_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_back_door_status;
        break;
      }

      // optional bool back_door_status = 7;
      case 7: {
        if (tag == 56) {
         parse_back_door_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &back_door_status_)));
          set_has_back_door_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_back_door_locked_status;
        break;
      }

      // optional bool back_door_locked_status = 9;
      case 9: {
        if (tag == 72) {
         parse_back_door_locked_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &back_door_locked_status_)));
          set_has_back_door_locked_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_LowBeamRequest;
        break;
      }

      // optional bool LowBeamRequest = 10;
      case 10: {
        if (tag == 80) {
         parse_LowBeamRequest:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &lowbeamrequest_)));
          set_has_lowbeamrequest();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_HighBeamRequest;
        break;
      }

      // optional bool HighBeamRequest = 12;
      case 12: {
        if (tag == 96) {
         parse_HighBeamRequest:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &highbeamrequest_)));
          set_has_highbeamrequest();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(408)) goto parse_SWIIGK;
        break;
      }

      // optional bool SWIIGK = 51;
      case 51: {
        if (tag == 408) {
         parse_SWIIGK:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &swiigk_)));
          set_has_swiigk();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(416)) goto parse_DoorOpen_Warning;
        break;
      }

      // optional bool DoorOpen_Warning = 52;
      case 52: {
        if (tag == 416) {
         parse_DoorOpen_Warning:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &dooropen_warning_)));
          set_has_dooropen_warning();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(424)) goto parse_LightOn_Warning;
        break;
      }

      // optional bool LightOn_Warning = 53;
      case 53: {
        if (tag == 424) {
         parse_LightOn_Warning:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &lighton_warning_)));
          set_has_lighton_warning();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(432)) goto parse_TPMSMIL_Req;
        break;
      }

      // optional uint32 TPMSMIL_Req = 54;
      case 54: {
        if (tag == 432) {
         parse_TPMSMIL_Req:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tpmsmil_req_)));
          set_has_tpmsmil_req();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(440)) goto parse_StopLampFailSts;
        break;
      }

      // optional bool StopLampFailSts = 55;
      case 55: {
        if (tag == 440) {
         parse_StopLampFailSts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &stoplampfailsts_)));
          set_has_stoplampfailsts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(448)) goto parse_RemoteVecSearchSts;
        break;
      }

      // optional bool RemoteVecSearchSts = 56;
      case 56: {
        if (tag == 448) {
         parse_RemoteVecSearchSts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &remotevecsearchsts_)));
          set_has_remotevecsearchsts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(456)) goto parse_DriverDoorLockSts;
        break;
      }

      // optional bool DriverDoorLockSts = 57;
      case 57: {
        if (tag == 456) {
         parse_DriverDoorLockSts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &driverdoorlocksts_)));
          set_has_driverdoorlocksts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(464)) goto parse_KeyAlarmSts;
        break;
      }

      // optional uint32 KeyAlarmSts = 58;
      case 58: {
        if (tag == 464) {
         parse_KeyAlarmSts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &keyalarmsts_)));
          set_has_keyalarmsts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(472)) goto parse_HoodStatus;
        break;
      }

      // optional bool HoodStatus = 59;
      case 59: {
        if (tag == 472) {
         parse_HoodStatus:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &hoodstatus_)));
          set_has_hoodstatus();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(480)) goto parse_AccStatus;
        break;
      }

      // optional bool AccStatus = 60;
      case 60: {
        if (tag == 480) {
         parse_AccStatus:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &accstatus_)));
          set_has_accstatus();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(488)) goto parse_remote_enging_run_flag;
        break;
      }

      // optional bool remote_enging_run_flag = 61;
      case 61: {
        if (tag == 488) {
         parse_remote_enging_run_flag:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &remote_enging_run_flag_)));
          set_has_remote_enging_run_flag();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.BCM_Info)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.BCM_Info)
  return false;
#undef DO_
}

void BCM_Info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.BCM_Info)
  // optional bool front_left_door_status = 3;
  if (has_front_left_door_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->front_left_door_status(), output);
  }

  // optional bool front_right_door_status = 4;
  if (has_front_right_door_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->front_right_door_status(), output);
  }

  // optional bool rear_left_door_status = 5;
  if (has_rear_left_door_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->rear_left_door_status(), output);
  }

  // optional bool rear_right_door_status = 6;
  if (has_rear_right_door_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->rear_right_door_status(), output);
  }

  // optional bool back_door_status = 7;
  if (has_back_door_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->back_door_status(), output);
  }

  // optional bool back_door_locked_status = 9;
  if (has_back_door_locked_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->back_door_locked_status(), output);
  }

  // optional bool LowBeamRequest = 10;
  if (has_lowbeamrequest()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->lowbeamrequest(), output);
  }

  // optional bool HighBeamRequest = 12;
  if (has_highbeamrequest()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(12, this->highbeamrequest(), output);
  }

  // optional bool SWIIGK = 51;
  if (has_swiigk()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(51, this->swiigk(), output);
  }

  // optional bool DoorOpen_Warning = 52;
  if (has_dooropen_warning()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(52, this->dooropen_warning(), output);
  }

  // optional bool LightOn_Warning = 53;
  if (has_lighton_warning()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(53, this->lighton_warning(), output);
  }

  // optional uint32 TPMSMIL_Req = 54;
  if (has_tpmsmil_req()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(54, this->tpmsmil_req(), output);
  }

  // optional bool StopLampFailSts = 55;
  if (has_stoplampfailsts()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(55, this->stoplampfailsts(), output);
  }

  // optional bool RemoteVecSearchSts = 56;
  if (has_remotevecsearchsts()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(56, this->remotevecsearchsts(), output);
  }

  // optional bool DriverDoorLockSts = 57;
  if (has_driverdoorlocksts()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(57, this->driverdoorlocksts(), output);
  }

  // optional uint32 KeyAlarmSts = 58;
  if (has_keyalarmsts()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(58, this->keyalarmsts(), output);
  }

  // optional bool HoodStatus = 59;
  if (has_hoodstatus()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(59, this->hoodstatus(), output);
  }

  // optional bool AccStatus = 60;
  if (has_accstatus()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(60, this->accstatus(), output);
  }

  // optional bool remote_enging_run_flag = 61;
  if (has_remote_enging_run_flag()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(61, this->remote_enging_run_flag(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.BCM_Info)
}

::google::protobuf::uint8* BCM_Info::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.BCM_Info)
  // optional bool front_left_door_status = 3;
  if (has_front_left_door_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->front_left_door_status(), target);
  }

  // optional bool front_right_door_status = 4;
  if (has_front_right_door_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->front_right_door_status(), target);
  }

  // optional bool rear_left_door_status = 5;
  if (has_rear_left_door_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->rear_left_door_status(), target);
  }

  // optional bool rear_right_door_status = 6;
  if (has_rear_right_door_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->rear_right_door_status(), target);
  }

  // optional bool back_door_status = 7;
  if (has_back_door_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->back_door_status(), target);
  }

  // optional bool back_door_locked_status = 9;
  if (has_back_door_locked_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(9, this->back_door_locked_status(), target);
  }

  // optional bool LowBeamRequest = 10;
  if (has_lowbeamrequest()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(10, this->lowbeamrequest(), target);
  }

  // optional bool HighBeamRequest = 12;
  if (has_highbeamrequest()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(12, this->highbeamrequest(), target);
  }

  // optional bool SWIIGK = 51;
  if (has_swiigk()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(51, this->swiigk(), target);
  }

  // optional bool DoorOpen_Warning = 52;
  if (has_dooropen_warning()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(52, this->dooropen_warning(), target);
  }

  // optional bool LightOn_Warning = 53;
  if (has_lighton_warning()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(53, this->lighton_warning(), target);
  }

  // optional uint32 TPMSMIL_Req = 54;
  if (has_tpmsmil_req()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(54, this->tpmsmil_req(), target);
  }

  // optional bool StopLampFailSts = 55;
  if (has_stoplampfailsts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(55, this->stoplampfailsts(), target);
  }

  // optional bool RemoteVecSearchSts = 56;
  if (has_remotevecsearchsts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(56, this->remotevecsearchsts(), target);
  }

  // optional bool DriverDoorLockSts = 57;
  if (has_driverdoorlocksts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(57, this->driverdoorlocksts(), target);
  }

  // optional uint32 KeyAlarmSts = 58;
  if (has_keyalarmsts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(58, this->keyalarmsts(), target);
  }

  // optional bool HoodStatus = 59;
  if (has_hoodstatus()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(59, this->hoodstatus(), target);
  }

  // optional bool AccStatus = 60;
  if (has_accstatus()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(60, this->accstatus(), target);
  }

  // optional bool remote_enging_run_flag = 61;
  if (has_remote_enging_run_flag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(61, this->remote_enging_run_flag(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.BCM_Info)
  return target;
}

int BCM_Info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool front_left_door_status = 3;
    if (has_front_left_door_status()) {
      total_size += 1 + 1;
    }

    // optional bool front_right_door_status = 4;
    if (has_front_right_door_status()) {
      total_size += 1 + 1;
    }

    // optional bool rear_left_door_status = 5;
    if (has_rear_left_door_status()) {
      total_size += 1 + 1;
    }

    // optional bool rear_right_door_status = 6;
    if (has_rear_right_door_status()) {
      total_size += 1 + 1;
    }

    // optional bool back_door_status = 7;
    if (has_back_door_status()) {
      total_size += 1 + 1;
    }

    // optional bool back_door_locked_status = 9;
    if (has_back_door_locked_status()) {
      total_size += 1 + 1;
    }

    // optional bool LowBeamRequest = 10;
    if (has_lowbeamrequest()) {
      total_size += 1 + 1;
    }

    // optional bool HighBeamRequest = 12;
    if (has_highbeamrequest()) {
      total_size += 1 + 1;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bool SWIIGK = 51;
    if (has_swiigk()) {
      total_size += 2 + 1;
    }

    // optional bool DoorOpen_Warning = 52;
    if (has_dooropen_warning()) {
      total_size += 2 + 1;
    }

    // optional bool LightOn_Warning = 53;
    if (has_lighton_warning()) {
      total_size += 2 + 1;
    }

    // optional uint32 TPMSMIL_Req = 54;
    if (has_tpmsmil_req()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tpmsmil_req());
    }

    // optional bool StopLampFailSts = 55;
    if (has_stoplampfailsts()) {
      total_size += 2 + 1;
    }

    // optional bool RemoteVecSearchSts = 56;
    if (has_remotevecsearchsts()) {
      total_size += 2 + 1;
    }

    // optional bool DriverDoorLockSts = 57;
    if (has_driverdoorlocksts()) {
      total_size += 2 + 1;
    }

    // optional uint32 KeyAlarmSts = 58;
    if (has_keyalarmsts()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->keyalarmsts());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional bool HoodStatus = 59;
    if (has_hoodstatus()) {
      total_size += 2 + 1;
    }

    // optional bool AccStatus = 60;
    if (has_accstatus()) {
      total_size += 2 + 1;
    }

    // optional bool remote_enging_run_flag = 61;
    if (has_remote_enging_run_flag()) {
      total_size += 2 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BCM_Info::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const BCM_Info* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const BCM_Info*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void BCM_Info::MergeFrom(const BCM_Info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_front_left_door_status()) {
      set_front_left_door_status(from.front_left_door_status());
    }
    if (from.has_front_right_door_status()) {
      set_front_right_door_status(from.front_right_door_status());
    }
    if (from.has_rear_left_door_status()) {
      set_rear_left_door_status(from.rear_left_door_status());
    }
    if (from.has_rear_right_door_status()) {
      set_rear_right_door_status(from.rear_right_door_status());
    }
    if (from.has_back_door_status()) {
      set_back_door_status(from.back_door_status());
    }
    if (from.has_back_door_locked_status()) {
      set_back_door_locked_status(from.back_door_locked_status());
    }
    if (from.has_lowbeamrequest()) {
      set_lowbeamrequest(from.lowbeamrequest());
    }
    if (from.has_highbeamrequest()) {
      set_highbeamrequest(from.highbeamrequest());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_swiigk()) {
      set_swiigk(from.swiigk());
    }
    if (from.has_dooropen_warning()) {
      set_dooropen_warning(from.dooropen_warning());
    }
    if (from.has_lighton_warning()) {
      set_lighton_warning(from.lighton_warning());
    }
    if (from.has_tpmsmil_req()) {
      set_tpmsmil_req(from.tpmsmil_req());
    }
    if (from.has_stoplampfailsts()) {
      set_stoplampfailsts(from.stoplampfailsts());
    }
    if (from.has_remotevecsearchsts()) {
      set_remotevecsearchsts(from.remotevecsearchsts());
    }
    if (from.has_driverdoorlocksts()) {
      set_driverdoorlocksts(from.driverdoorlocksts());
    }
    if (from.has_keyalarmsts()) {
      set_keyalarmsts(from.keyalarmsts());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_hoodstatus()) {
      set_hoodstatus(from.hoodstatus());
    }
    if (from.has_accstatus()) {
      set_accstatus(from.accstatus());
    }
    if (from.has_remote_enging_run_flag()) {
      set_remote_enging_run_flag(from.remote_enging_run_flag());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void BCM_Info::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BCM_Info::CopyFrom(const BCM_Info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BCM_Info::IsInitialized() const {

  return true;
}

void BCM_Info::Swap(BCM_Info* other) {
  if (other != this) {
    std::swap(front_left_door_status_, other->front_left_door_status_);
    std::swap(front_right_door_status_, other->front_right_door_status_);
    std::swap(rear_left_door_status_, other->rear_left_door_status_);
    std::swap(rear_right_door_status_, other->rear_right_door_status_);
    std::swap(back_door_status_, other->back_door_status_);
    std::swap(back_door_locked_status_, other->back_door_locked_status_);
    std::swap(lowbeamrequest_, other->lowbeamrequest_);
    std::swap(highbeamrequest_, other->highbeamrequest_);
    std::swap(swiigk_, other->swiigk_);
    std::swap(dooropen_warning_, other->dooropen_warning_);
    std::swap(lighton_warning_, other->lighton_warning_);
    std::swap(tpmsmil_req_, other->tpmsmil_req_);
    std::swap(stoplampfailsts_, other->stoplampfailsts_);
    std::swap(remotevecsearchsts_, other->remotevecsearchsts_);
    std::swap(driverdoorlocksts_, other->driverdoorlocksts_);
    std::swap(keyalarmsts_, other->keyalarmsts_);
    std::swap(hoodstatus_, other->hoodstatus_);
    std::swap(accstatus_, other->accstatus_);
    std::swap(remote_enging_run_flag_, other->remote_enging_run_flag_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata BCM_Info::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BCM_Info_descriptor_;
  metadata.reflection = BCM_Info_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ACU_Info::kAirbagCrashOrderFieldNumber;
const int ACU_Info::kAirbagFailStsFieldNumber;
#endif  // !_MSC_VER

ACU_Info::ACU_Info()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.ACU_Info)
}

void ACU_Info::InitAsDefaultInstance() {
}

ACU_Info::ACU_Info(const ACU_Info& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.ACU_Info)
}

void ACU_Info::SharedCtor() {
  _cached_size_ = 0;
  airbag_crash_order_ = 0u;
  airbagfail_sts_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ACU_Info::~ACU_Info() {
  // @@protoc_insertion_point(destructor:zna.protocol.ACU_Info)
  SharedDtor();
}

void ACU_Info::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ACU_Info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ACU_Info::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ACU_Info_descriptor_;
}

const ACU_Info& ACU_Info::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

ACU_Info* ACU_Info::default_instance_ = NULL;

ACU_Info* ACU_Info::New() const {
  return new ACU_Info;
}

void ACU_Info::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ACU_Info*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(airbag_crash_order_, airbagfail_sts_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ACU_Info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.ACU_Info)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 Airbag_Crash_Order = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &airbag_crash_order_)));
          set_has_airbag_crash_order();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_AirbagFail_Sts;
        break;
      }

      // optional uint32 AirbagFail_Sts = 12;
      case 12: {
        if (tag == 96) {
         parse_AirbagFail_Sts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &airbagfail_sts_)));
          set_has_airbagfail_sts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.ACU_Info)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.ACU_Info)
  return false;
#undef DO_
}

void ACU_Info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.ACU_Info)
  // optional uint32 Airbag_Crash_Order = 1;
  if (has_airbag_crash_order()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->airbag_crash_order(), output);
  }

  // optional uint32 AirbagFail_Sts = 12;
  if (has_airbagfail_sts()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->airbagfail_sts(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.ACU_Info)
}

::google::protobuf::uint8* ACU_Info::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.ACU_Info)
  // optional uint32 Airbag_Crash_Order = 1;
  if (has_airbag_crash_order()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->airbag_crash_order(), target);
  }

  // optional uint32 AirbagFail_Sts = 12;
  if (has_airbagfail_sts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->airbagfail_sts(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.ACU_Info)
  return target;
}

int ACU_Info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 Airbag_Crash_Order = 1;
    if (has_airbag_crash_order()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->airbag_crash_order());
    }

    // optional uint32 AirbagFail_Sts = 12;
    if (has_airbagfail_sts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->airbagfail_sts());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ACU_Info::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ACU_Info* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ACU_Info*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ACU_Info::MergeFrom(const ACU_Info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_airbag_crash_order()) {
      set_airbag_crash_order(from.airbag_crash_order());
    }
    if (from.has_airbagfail_sts()) {
      set_airbagfail_sts(from.airbagfail_sts());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ACU_Info::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ACU_Info::CopyFrom(const ACU_Info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ACU_Info::IsInitialized() const {

  return true;
}

void ACU_Info::Swap(ACU_Info* other) {
  if (other != this) {
    std::swap(airbag_crash_order_, other->airbag_crash_order_);
    std::swap(airbagfail_sts_, other->airbagfail_sts_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ACU_Info::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ACU_Info_descriptor_;
  metadata.reflection = ACU_Info_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ECO_Info::kRapidAccelerationCountFieldNumber;
const int ECO_Info::kRapidDecelerationCountFieldNumber;
const int ECO_Info::kSharpTurnCountFieldNumber;
#endif  // !_MSC_VER

ECO_Info::ECO_Info()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.ECO_Info)
}

void ECO_Info::InitAsDefaultInstance() {
}

ECO_Info::ECO_Info(const ECO_Info& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.ECO_Info)
}

void ECO_Info::SharedCtor() {
  _cached_size_ = 0;
  rapid_acceleration_count_ = 0u;
  rapid_deceleration_count_ = 0u;
  sharp_turn_count_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ECO_Info::~ECO_Info() {
  // @@protoc_insertion_point(destructor:zna.protocol.ECO_Info)
  SharedDtor();
}

void ECO_Info::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ECO_Info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ECO_Info::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ECO_Info_descriptor_;
}

const ECO_Info& ECO_Info::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

ECO_Info* ECO_Info::default_instance_ = NULL;

ECO_Info* ECO_Info::New() const {
  return new ECO_Info;
}

void ECO_Info::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ECO_Info*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(rapid_acceleration_count_, sharp_turn_count_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ECO_Info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.ECO_Info)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 rapid_acceleration_count = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rapid_acceleration_count_)));
          set_has_rapid_acceleration_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_rapid_deceleration_count;
        break;
      }

      // optional uint32 rapid_deceleration_count = 2;
      case 2: {
        if (tag == 16) {
         parse_rapid_deceleration_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rapid_deceleration_count_)));
          set_has_rapid_deceleration_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_sharp_turn_count;
        break;
      }

      // optional uint32 sharp_turn_count = 3;
      case 3: {
        if (tag == 24) {
         parse_sharp_turn_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sharp_turn_count_)));
          set_has_sharp_turn_count();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.ECO_Info)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.ECO_Info)
  return false;
#undef DO_
}

void ECO_Info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.ECO_Info)
  // optional uint32 rapid_acceleration_count = 1;
  if (has_rapid_acceleration_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->rapid_acceleration_count(), output);
  }

  // optional uint32 rapid_deceleration_count = 2;
  if (has_rapid_deceleration_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->rapid_deceleration_count(), output);
  }

  // optional uint32 sharp_turn_count = 3;
  if (has_sharp_turn_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->sharp_turn_count(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.ECO_Info)
}

::google::protobuf::uint8* ECO_Info::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.ECO_Info)
  // optional uint32 rapid_acceleration_count = 1;
  if (has_rapid_acceleration_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->rapid_acceleration_count(), target);
  }

  // optional uint32 rapid_deceleration_count = 2;
  if (has_rapid_deceleration_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->rapid_deceleration_count(), target);
  }

  // optional uint32 sharp_turn_count = 3;
  if (has_sharp_turn_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->sharp_turn_count(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.ECO_Info)
  return target;
}

int ECO_Info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 rapid_acceleration_count = 1;
    if (has_rapid_acceleration_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rapid_acceleration_count());
    }

    // optional uint32 rapid_deceleration_count = 2;
    if (has_rapid_deceleration_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->rapid_deceleration_count());
    }

    // optional uint32 sharp_turn_count = 3;
    if (has_sharp_turn_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sharp_turn_count());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ECO_Info::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ECO_Info* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ECO_Info*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ECO_Info::MergeFrom(const ECO_Info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rapid_acceleration_count()) {
      set_rapid_acceleration_count(from.rapid_acceleration_count());
    }
    if (from.has_rapid_deceleration_count()) {
      set_rapid_deceleration_count(from.rapid_deceleration_count());
    }
    if (from.has_sharp_turn_count()) {
      set_sharp_turn_count(from.sharp_turn_count());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ECO_Info::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ECO_Info::CopyFrom(const ECO_Info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ECO_Info::IsInitialized() const {

  return true;
}

void ECO_Info::Swap(ECO_Info* other) {
  if (other != this) {
    std::swap(rapid_acceleration_count_, other->rapid_acceleration_count_);
    std::swap(rapid_deceleration_count_, other->rapid_deceleration_count_);
    std::swap(sharp_turn_count_, other->sharp_turn_count_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ECO_Info::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ECO_Info_descriptor_;
  metadata.reflection = ECO_Info_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ALARM_Info::kAlarmTypeFieldNumber;
const int ALARM_Info::kAlarmTypeExFieldNumber;
const int ALARM_Info::kTransmitterFailFieldNumber;
const int ALARM_Info::kLowTirePressureFieldNumber;
const int ALARM_Info::kZNAP15MCFieldNumber;
#endif  // !_MSC_VER

ALARM_Info::ALARM_Info()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.ALARM_Info)
}

void ALARM_Info::InitAsDefaultInstance() {
}

ALARM_Info::ALARM_Info(const ALARM_Info& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.ALARM_Info)
}

void ALARM_Info::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  alarm_type_ = 0u;
  alarm_typeex_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  transmitter_fail_ = 0u;
  lowtirepressure_ = 0u;
  zna_p15mc_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ALARM_Info::~ALARM_Info() {
  // @@protoc_insertion_point(destructor:zna.protocol.ALARM_Info)
  SharedDtor();
}

void ALARM_Info::SharedDtor() {
  if (alarm_typeex_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete alarm_typeex_;
  }
  if (this != default_instance_) {
  }
}

void ALARM_Info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ALARM_Info::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ALARM_Info_descriptor_;
}

const ALARM_Info& ALARM_Info::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

ALARM_Info* ALARM_Info::default_instance_ = NULL;

ALARM_Info* ALARM_Info::New() const {
  return new ALARM_Info;
}

void ALARM_Info::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ALARM_Info*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(alarm_type_, zna_p15mc_);
    if (has_alarm_typeex()) {
      if (alarm_typeex_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        alarm_typeex_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ALARM_Info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.ALARM_Info)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 alarm_type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &alarm_type_)));
          set_has_alarm_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_alarm_typeEx;
        break;
      }

      // optional bytes alarm_typeEx = 2;
      case 2: {
        if (tag == 18) {
         parse_alarm_typeEx:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_alarm_typeex()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Transmitter_Fail;
        break;
      }

      // optional uint32 Transmitter_Fail = 3;
      case 3: {
        if (tag == 24) {
         parse_Transmitter_Fail:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &transmitter_fail_)));
          set_has_transmitter_fail();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_LowTirePressure;
        break;
      }

      // optional uint32 LowTirePressure = 4;
      case 4: {
        if (tag == 32) {
         parse_LowTirePressure:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lowtirepressure_)));
          set_has_lowtirepressure();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_ZNA_P15MC;
        break;
      }

      // optional uint32 ZNA_P15MC = 5;
      case 5: {
        if (tag == 40) {
         parse_ZNA_P15MC:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &zna_p15mc_)));
          set_has_zna_p15mc();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.ALARM_Info)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.ALARM_Info)
  return false;
#undef DO_
}

void ALARM_Info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.ALARM_Info)
  // optional uint32 alarm_type = 1;
  if (has_alarm_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->alarm_type(), output);
  }

  // optional bytes alarm_typeEx = 2;
  if (has_alarm_typeex()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->alarm_typeex(), output);
  }

  // optional uint32 Transmitter_Fail = 3;
  if (has_transmitter_fail()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->transmitter_fail(), output);
  }

  // optional uint32 LowTirePressure = 4;
  if (has_lowtirepressure()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->lowtirepressure(), output);
  }

  // optional uint32 ZNA_P15MC = 5;
  if (has_zna_p15mc()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->zna_p15mc(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.ALARM_Info)
}

::google::protobuf::uint8* ALARM_Info::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.ALARM_Info)
  // optional uint32 alarm_type = 1;
  if (has_alarm_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->alarm_type(), target);
  }

  // optional bytes alarm_typeEx = 2;
  if (has_alarm_typeex()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->alarm_typeex(), target);
  }

  // optional uint32 Transmitter_Fail = 3;
  if (has_transmitter_fail()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->transmitter_fail(), target);
  }

  // optional uint32 LowTirePressure = 4;
  if (has_lowtirepressure()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->lowtirepressure(), target);
  }

  // optional uint32 ZNA_P15MC = 5;
  if (has_zna_p15mc()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->zna_p15mc(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.ALARM_Info)
  return target;
}

int ALARM_Info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 alarm_type = 1;
    if (has_alarm_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->alarm_type());
    }

    // optional bytes alarm_typeEx = 2;
    if (has_alarm_typeex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->alarm_typeex());
    }

    // optional uint32 Transmitter_Fail = 3;
    if (has_transmitter_fail()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->transmitter_fail());
    }

    // optional uint32 LowTirePressure = 4;
    if (has_lowtirepressure()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->lowtirepressure());
    }

    // optional uint32 ZNA_P15MC = 5;
    if (has_zna_p15mc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->zna_p15mc());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ALARM_Info::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ALARM_Info* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ALARM_Info*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ALARM_Info::MergeFrom(const ALARM_Info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_alarm_type()) {
      set_alarm_type(from.alarm_type());
    }
    if (from.has_alarm_typeex()) {
      set_alarm_typeex(from.alarm_typeex());
    }
    if (from.has_transmitter_fail()) {
      set_transmitter_fail(from.transmitter_fail());
    }
    if (from.has_lowtirepressure()) {
      set_lowtirepressure(from.lowtirepressure());
    }
    if (from.has_zna_p15mc()) {
      set_zna_p15mc(from.zna_p15mc());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ALARM_Info::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ALARM_Info::CopyFrom(const ALARM_Info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ALARM_Info::IsInitialized() const {

  return true;
}

void ALARM_Info::Swap(ALARM_Info* other) {
  if (other != this) {
    std::swap(alarm_type_, other->alarm_type_);
    std::swap(alarm_typeex_, other->alarm_typeex_);
    std::swap(transmitter_fail_, other->transmitter_fail_);
    std::swap(lowtirepressure_, other->lowtirepressure_);
    std::swap(zna_p15mc_, other->zna_p15mc_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ALARM_Info::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ALARM_Info_descriptor_;
  metadata.reflection = ALARM_Info_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PEPS_Info::kRemoteFeedbackStsFieldNumber;
const int PEPS_Info::kRemotePEPSModeFieldNumber;
const int PEPS_Info::kRemoteEngineRunCntFieldNumber;
const int PEPS_Info::kPEPSPDUFieldNumber;
const int PEPS_Info::kPEPSBluetoothFieldNumber;
const int PEPS_Info::kPEPSMeterAlarmFieldNumber;
#endif  // !_MSC_VER

PEPS_Info::PEPS_Info()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.PEPS_Info)
}

void PEPS_Info::InitAsDefaultInstance() {
}

PEPS_Info::PEPS_Info(const PEPS_Info& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.PEPS_Info)
}

void PEPS_Info::SharedCtor() {
  _cached_size_ = 0;
  remotefeedback_sts_ = 0u;
  remotepeps_mode_ = 0u;
  remoteenginerun_cnt_ = 0u;
  peps_pdu_ = 0u;
  peps_bluetooth_ = false;
  peps_meteralarm_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PEPS_Info::~PEPS_Info() {
  // @@protoc_insertion_point(destructor:zna.protocol.PEPS_Info)
  SharedDtor();
}

void PEPS_Info::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PEPS_Info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PEPS_Info::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PEPS_Info_descriptor_;
}

const PEPS_Info& PEPS_Info::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

PEPS_Info* PEPS_Info::default_instance_ = NULL;

PEPS_Info* PEPS_Info::New() const {
  return new PEPS_Info;
}

void PEPS_Info::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PEPS_Info*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(remotefeedback_sts_, peps_meteralarm_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PEPS_Info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.PEPS_Info)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 RemoteFeedback_Sts = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &remotefeedback_sts_)));
          set_has_remotefeedback_sts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_RemotePEPS_Mode;
        break;
      }

      // optional uint32 RemotePEPS_Mode = 2;
      case 2: {
        if (tag == 16) {
         parse_RemotePEPS_Mode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &remotepeps_mode_)));
          set_has_remotepeps_mode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_RemoteEngineRun_Cnt;
        break;
      }

      // optional uint32 RemoteEngineRun_Cnt = 3;
      case 3: {
        if (tag == 24) {
         parse_RemoteEngineRun_Cnt:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &remoteenginerun_cnt_)));
          set_has_remoteenginerun_cnt();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_PEPS_PDU;
        break;
      }

      // optional uint32 PEPS_PDU = 4;
      case 4: {
        if (tag == 32) {
         parse_PEPS_PDU:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &peps_pdu_)));
          set_has_peps_pdu();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_PEPS_Bluetooth;
        break;
      }

      // optional bool PEPS_Bluetooth = 5;
      case 5: {
        if (tag == 40) {
         parse_PEPS_Bluetooth:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &peps_bluetooth_)));
          set_has_peps_bluetooth();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_PEPS_MeterAlarm;
        break;
      }

      // optional uint32 PEPS_MeterAlarm = 6;
      case 6: {
        if (tag == 48) {
         parse_PEPS_MeterAlarm:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &peps_meteralarm_)));
          set_has_peps_meteralarm();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.PEPS_Info)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.PEPS_Info)
  return false;
#undef DO_
}

void PEPS_Info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.PEPS_Info)
  // optional uint32 RemoteFeedback_Sts = 1;
  if (has_remotefeedback_sts()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->remotefeedback_sts(), output);
  }

  // optional uint32 RemotePEPS_Mode = 2;
  if (has_remotepeps_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->remotepeps_mode(), output);
  }

  // optional uint32 RemoteEngineRun_Cnt = 3;
  if (has_remoteenginerun_cnt()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->remoteenginerun_cnt(), output);
  }

  // optional uint32 PEPS_PDU = 4;
  if (has_peps_pdu()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->peps_pdu(), output);
  }

  // optional bool PEPS_Bluetooth = 5;
  if (has_peps_bluetooth()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->peps_bluetooth(), output);
  }

  // optional uint32 PEPS_MeterAlarm = 6;
  if (has_peps_meteralarm()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->peps_meteralarm(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.PEPS_Info)
}

::google::protobuf::uint8* PEPS_Info::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.PEPS_Info)
  // optional uint32 RemoteFeedback_Sts = 1;
  if (has_remotefeedback_sts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->remotefeedback_sts(), target);
  }

  // optional uint32 RemotePEPS_Mode = 2;
  if (has_remotepeps_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->remotepeps_mode(), target);
  }

  // optional uint32 RemoteEngineRun_Cnt = 3;
  if (has_remoteenginerun_cnt()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->remoteenginerun_cnt(), target);
  }

  // optional uint32 PEPS_PDU = 4;
  if (has_peps_pdu()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->peps_pdu(), target);
  }

  // optional bool PEPS_Bluetooth = 5;
  if (has_peps_bluetooth()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->peps_bluetooth(), target);
  }

  // optional uint32 PEPS_MeterAlarm = 6;
  if (has_peps_meteralarm()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->peps_meteralarm(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.PEPS_Info)
  return target;
}

int PEPS_Info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 RemoteFeedback_Sts = 1;
    if (has_remotefeedback_sts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->remotefeedback_sts());
    }

    // optional uint32 RemotePEPS_Mode = 2;
    if (has_remotepeps_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->remotepeps_mode());
    }

    // optional uint32 RemoteEngineRun_Cnt = 3;
    if (has_remoteenginerun_cnt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->remoteenginerun_cnt());
    }

    // optional uint32 PEPS_PDU = 4;
    if (has_peps_pdu()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->peps_pdu());
    }

    // optional bool PEPS_Bluetooth = 5;
    if (has_peps_bluetooth()) {
      total_size += 1 + 1;
    }

    // optional uint32 PEPS_MeterAlarm = 6;
    if (has_peps_meteralarm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->peps_meteralarm());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PEPS_Info::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PEPS_Info* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PEPS_Info*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PEPS_Info::MergeFrom(const PEPS_Info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_remotefeedback_sts()) {
      set_remotefeedback_sts(from.remotefeedback_sts());
    }
    if (from.has_remotepeps_mode()) {
      set_remotepeps_mode(from.remotepeps_mode());
    }
    if (from.has_remoteenginerun_cnt()) {
      set_remoteenginerun_cnt(from.remoteenginerun_cnt());
    }
    if (from.has_peps_pdu()) {
      set_peps_pdu(from.peps_pdu());
    }
    if (from.has_peps_bluetooth()) {
      set_peps_bluetooth(from.peps_bluetooth());
    }
    if (from.has_peps_meteralarm()) {
      set_peps_meteralarm(from.peps_meteralarm());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PEPS_Info::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PEPS_Info::CopyFrom(const PEPS_Info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PEPS_Info::IsInitialized() const {

  return true;
}

void PEPS_Info::Swap(PEPS_Info* other) {
  if (other != this) {
    std::swap(remotefeedback_sts_, other->remotefeedback_sts_);
    std::swap(remotepeps_mode_, other->remotepeps_mode_);
    std::swap(remoteenginerun_cnt_, other->remoteenginerun_cnt_);
    std::swap(peps_pdu_, other->peps_pdu_);
    std::swap(peps_bluetooth_, other->peps_bluetooth_);
    std::swap(peps_meteralarm_, other->peps_meteralarm_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PEPS_Info::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PEPS_Info_descriptor_;
  metadata.reflection = PEPS_Info_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ESP_Info::kESPLampFieldNumber;
const int ESP_Info::kABSLampFieldNumber;
const int ESP_Info::kHAZActiveFieldNumber;
const int ESP_Info::kVehicleSpeedValidFieldNumber;
const int ESP_Info::kLongAccelFieldNumber;
const int ESP_Info::kVehicleSpeedFieldNumber;
const int ESP_Info::kEBDLampFieldNumber;
const int ESP_Info::kABSAcitveFieldNumber;
#endif  // !_MSC_VER

ESP_Info::ESP_Info()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.ESP_Info)
}

void ESP_Info::InitAsDefaultInstance() {
}

ESP_Info::ESP_Info(const ESP_Info& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.ESP_Info)
}

void ESP_Info::SharedCtor() {
  _cached_size_ = 0;
  esp_lamp_ = 0u;
  abs_lamp_ = 0u;
  haz_active_ = false;
  vehiclespeed_valid_ = false;
  longaccel_ = 0u;
  vehiclespeed_ = 0u;
  ebd_lamp_ = 0u;
  abs_acitve_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ESP_Info::~ESP_Info() {
  // @@protoc_insertion_point(destructor:zna.protocol.ESP_Info)
  SharedDtor();
}

void ESP_Info::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ESP_Info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ESP_Info::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ESP_Info_descriptor_;
}

const ESP_Info& ESP_Info::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

ESP_Info* ESP_Info::default_instance_ = NULL;

ESP_Info* ESP_Info::New() const {
  return new ESP_Info;
}

void ESP_Info::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ESP_Info*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(esp_lamp_, ebd_lamp_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ESP_Info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.ESP_Info)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 ESP_Lamp = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &esp_lamp_)));
          set_has_esp_lamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_ABS_Lamp;
        break;
      }

      // optional uint32 ABS_Lamp = 2;
      case 2: {
        if (tag == 16) {
         parse_ABS_Lamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &abs_lamp_)));
          set_has_abs_lamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_HAZ_Active;
        break;
      }

      // optional bool HAZ_Active = 3;
      case 3: {
        if (tag == 24) {
         parse_HAZ_Active:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &haz_active_)));
          set_has_haz_active();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_VehicleSpeed_Valid;
        break;
      }

      // optional bool VehicleSpeed_Valid = 4;
      case 4: {
        if (tag == 32) {
         parse_VehicleSpeed_Valid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &vehiclespeed_valid_)));
          set_has_vehiclespeed_valid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_LongAccel;
        break;
      }

      // optional uint32 LongAccel = 5;
      case 5: {
        if (tag == 40) {
         parse_LongAccel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &longaccel_)));
          set_has_longaccel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_VehicleSpeed;
        break;
      }

      // optional uint32 VehicleSpeed = 6;
      case 6: {
        if (tag == 48) {
         parse_VehicleSpeed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &vehiclespeed_)));
          set_has_vehiclespeed();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_EBD_Lamp;
        break;
      }

      // optional uint32 EBD_Lamp = 7;
      case 7: {
        if (tag == 56) {
         parse_EBD_Lamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ebd_lamp_)));
          set_has_ebd_lamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_ABS_Acitve;
        break;
      }

      // optional bool ABS_Acitve = 8;
      case 8: {
        if (tag == 64) {
         parse_ABS_Acitve:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &abs_acitve_)));
          set_has_abs_acitve();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.ESP_Info)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.ESP_Info)
  return false;
#undef DO_
}

void ESP_Info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.ESP_Info)
  // optional uint32 ESP_Lamp = 1;
  if (has_esp_lamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->esp_lamp(), output);
  }

  // optional uint32 ABS_Lamp = 2;
  if (has_abs_lamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->abs_lamp(), output);
  }

  // optional bool HAZ_Active = 3;
  if (has_haz_active()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->haz_active(), output);
  }

  // optional bool VehicleSpeed_Valid = 4;
  if (has_vehiclespeed_valid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->vehiclespeed_valid(), output);
  }

  // optional uint32 LongAccel = 5;
  if (has_longaccel()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->longaccel(), output);
  }

  // optional uint32 VehicleSpeed = 6;
  if (has_vehiclespeed()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->vehiclespeed(), output);
  }

  // optional uint32 EBD_Lamp = 7;
  if (has_ebd_lamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->ebd_lamp(), output);
  }

  // optional bool ABS_Acitve = 8;
  if (has_abs_acitve()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->abs_acitve(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.ESP_Info)
}

::google::protobuf::uint8* ESP_Info::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.ESP_Info)
  // optional uint32 ESP_Lamp = 1;
  if (has_esp_lamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->esp_lamp(), target);
  }

  // optional uint32 ABS_Lamp = 2;
  if (has_abs_lamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->abs_lamp(), target);
  }

  // optional bool HAZ_Active = 3;
  if (has_haz_active()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->haz_active(), target);
  }

  // optional bool VehicleSpeed_Valid = 4;
  if (has_vehiclespeed_valid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->vehiclespeed_valid(), target);
  }

  // optional uint32 LongAccel = 5;
  if (has_longaccel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->longaccel(), target);
  }

  // optional uint32 VehicleSpeed = 6;
  if (has_vehiclespeed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->vehiclespeed(), target);
  }

  // optional uint32 EBD_Lamp = 7;
  if (has_ebd_lamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->ebd_lamp(), target);
  }

  // optional bool ABS_Acitve = 8;
  if (has_abs_acitve()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->abs_acitve(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.ESP_Info)
  return target;
}

int ESP_Info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 ESP_Lamp = 1;
    if (has_esp_lamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->esp_lamp());
    }

    // optional uint32 ABS_Lamp = 2;
    if (has_abs_lamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->abs_lamp());
    }

    // optional bool HAZ_Active = 3;
    if (has_haz_active()) {
      total_size += 1 + 1;
    }

    // optional bool VehicleSpeed_Valid = 4;
    if (has_vehiclespeed_valid()) {
      total_size += 1 + 1;
    }

    // optional uint32 LongAccel = 5;
    if (has_longaccel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->longaccel());
    }

    // optional uint32 VehicleSpeed = 6;
    if (has_vehiclespeed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->vehiclespeed());
    }

    // optional uint32 EBD_Lamp = 7;
    if (has_ebd_lamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ebd_lamp());
    }

    // optional bool ABS_Acitve = 8;
    if (has_abs_acitve()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ESP_Info::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ESP_Info* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ESP_Info*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ESP_Info::MergeFrom(const ESP_Info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_esp_lamp()) {
      set_esp_lamp(from.esp_lamp());
    }
    if (from.has_abs_lamp()) {
      set_abs_lamp(from.abs_lamp());
    }
    if (from.has_haz_active()) {
      set_haz_active(from.haz_active());
    }
    if (from.has_vehiclespeed_valid()) {
      set_vehiclespeed_valid(from.vehiclespeed_valid());
    }
    if (from.has_longaccel()) {
      set_longaccel(from.longaccel());
    }
    if (from.has_vehiclespeed()) {
      set_vehiclespeed(from.vehiclespeed());
    }
    if (from.has_ebd_lamp()) {
      set_ebd_lamp(from.ebd_lamp());
    }
    if (from.has_abs_acitve()) {
      set_abs_acitve(from.abs_acitve());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ESP_Info::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ESP_Info::CopyFrom(const ESP_Info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ESP_Info::IsInitialized() const {

  return true;
}

void ESP_Info::Swap(ESP_Info* other) {
  if (other != this) {
    std::swap(esp_lamp_, other->esp_lamp_);
    std::swap(abs_lamp_, other->abs_lamp_);
    std::swap(haz_active_, other->haz_active_);
    std::swap(vehiclespeed_valid_, other->vehiclespeed_valid_);
    std::swap(longaccel_, other->longaccel_);
    std::swap(vehiclespeed_, other->vehiclespeed_);
    std::swap(ebd_lamp_, other->ebd_lamp_);
    std::swap(abs_acitve_, other->abs_acitve_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ESP_Info::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ESP_Info_descriptor_;
  metadata.reflection = ESP_Info_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EPB_Info::kEPBFailStatusFieldNumber;
#endif  // !_MSC_VER

EPB_Info::EPB_Info()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.EPB_Info)
}

void EPB_Info::InitAsDefaultInstance() {
}

EPB_Info::EPB_Info(const EPB_Info& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.EPB_Info)
}

void EPB_Info::SharedCtor() {
  _cached_size_ = 0;
  epb_failstatus_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EPB_Info::~EPB_Info() {
  // @@protoc_insertion_point(destructor:zna.protocol.EPB_Info)
  SharedDtor();
}

void EPB_Info::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EPB_Info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EPB_Info::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EPB_Info_descriptor_;
}

const EPB_Info& EPB_Info::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

EPB_Info* EPB_Info::default_instance_ = NULL;

EPB_Info* EPB_Info::New() const {
  return new EPB_Info;
}

void EPB_Info::Clear() {
  epb_failstatus_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EPB_Info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.EPB_Info)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 EPB_FailStatus = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &epb_failstatus_)));
          set_has_epb_failstatus();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.EPB_Info)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.EPB_Info)
  return false;
#undef DO_
}

void EPB_Info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.EPB_Info)
  // optional uint32 EPB_FailStatus = 1;
  if (has_epb_failstatus()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->epb_failstatus(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.EPB_Info)
}

::google::protobuf::uint8* EPB_Info::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.EPB_Info)
  // optional uint32 EPB_FailStatus = 1;
  if (has_epb_failstatus()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->epb_failstatus(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.EPB_Info)
  return target;
}

int EPB_Info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 EPB_FailStatus = 1;
    if (has_epb_failstatus()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->epb_failstatus());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EPB_Info::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EPB_Info* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EPB_Info*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EPB_Info::MergeFrom(const EPB_Info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_epb_failstatus()) {
      set_epb_failstatus(from.epb_failstatus());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EPB_Info::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EPB_Info::CopyFrom(const EPB_Info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EPB_Info::IsInitialized() const {

  return true;
}

void EPB_Info::Swap(EPB_Info* other) {
  if (other != this) {
    std::swap(epb_failstatus_, other->epb_failstatus_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EPB_Info::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EPB_Info_descriptor_;
  metadata.reflection = EPB_Info_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TCU_Info::kTCUFaultFieldNumber;
const int TCU_Info::kGearSelectPosFieldNumber;
const int TCU_Info::kDrivingModeFieldNumber;
#endif  // !_MSC_VER

TCU_Info::TCU_Info()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.TCU_Info)
}

void TCU_Info::InitAsDefaultInstance() {
}

TCU_Info::TCU_Info(const TCU_Info& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.TCU_Info)
}

void TCU_Info::SharedCtor() {
  _cached_size_ = 0;
  tcu_fault_ = 0u;
  gearselect_pos_ = 0u;
  driving_mode_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TCU_Info::~TCU_Info() {
  // @@protoc_insertion_point(destructor:zna.protocol.TCU_Info)
  SharedDtor();
}

void TCU_Info::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TCU_Info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TCU_Info::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TCU_Info_descriptor_;
}

const TCU_Info& TCU_Info::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

TCU_Info* TCU_Info::default_instance_ = NULL;

TCU_Info* TCU_Info::New() const {
  return new TCU_Info;
}

void TCU_Info::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TCU_Info*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(tcu_fault_, driving_mode_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TCU_Info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.TCU_Info)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 TCU_Fault = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tcu_fault_)));
          set_has_tcu_fault();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_GearSelect_Pos;
        break;
      }

      // optional uint32 GearSelect_Pos = 2;
      case 2: {
        if (tag == 16) {
         parse_GearSelect_Pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gearselect_pos_)));
          set_has_gearselect_pos();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_Driving_Mode;
        break;
      }

      // optional uint32 Driving_Mode = 3;
      case 3: {
        if (tag == 24) {
         parse_Driving_Mode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &driving_mode_)));
          set_has_driving_mode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.TCU_Info)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.TCU_Info)
  return false;
#undef DO_
}

void TCU_Info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.TCU_Info)
  // optional uint32 TCU_Fault = 1;
  if (has_tcu_fault()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->tcu_fault(), output);
  }

  // optional uint32 GearSelect_Pos = 2;
  if (has_gearselect_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->gearselect_pos(), output);
  }

  // optional uint32 Driving_Mode = 3;
  if (has_driving_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->driving_mode(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.TCU_Info)
}

::google::protobuf::uint8* TCU_Info::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.TCU_Info)
  // optional uint32 TCU_Fault = 1;
  if (has_tcu_fault()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->tcu_fault(), target);
  }

  // optional uint32 GearSelect_Pos = 2;
  if (has_gearselect_pos()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->gearselect_pos(), target);
  }

  // optional uint32 Driving_Mode = 3;
  if (has_driving_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->driving_mode(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.TCU_Info)
  return target;
}

int TCU_Info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 TCU_Fault = 1;
    if (has_tcu_fault()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tcu_fault());
    }

    // optional uint32 GearSelect_Pos = 2;
    if (has_gearselect_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gearselect_pos());
    }

    // optional uint32 Driving_Mode = 3;
    if (has_driving_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->driving_mode());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TCU_Info::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TCU_Info* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TCU_Info*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TCU_Info::MergeFrom(const TCU_Info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tcu_fault()) {
      set_tcu_fault(from.tcu_fault());
    }
    if (from.has_gearselect_pos()) {
      set_gearselect_pos(from.gearselect_pos());
    }
    if (from.has_driving_mode()) {
      set_driving_mode(from.driving_mode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TCU_Info::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TCU_Info::CopyFrom(const TCU_Info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TCU_Info::IsInitialized() const {

  return true;
}

void TCU_Info::Swap(TCU_Info* other) {
  if (other != this) {
    std::swap(tcu_fault_, other->tcu_fault_);
    std::swap(gearselect_pos_, other->gearselect_pos_);
    std::swap(driving_mode_, other->driving_mode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TCU_Info::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TCU_Info_descriptor_;
  metadata.reflection = TCU_Info_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AWD_Info::kAWDModeFieldNumber;
#endif  // !_MSC_VER

AWD_Info::AWD_Info()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.AWD_Info)
}

void AWD_Info::InitAsDefaultInstance() {
}

AWD_Info::AWD_Info(const AWD_Info& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.AWD_Info)
}

void AWD_Info::SharedCtor() {
  _cached_size_ = 0;
  awd_mode_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AWD_Info::~AWD_Info() {
  // @@protoc_insertion_point(destructor:zna.protocol.AWD_Info)
  SharedDtor();
}

void AWD_Info::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AWD_Info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AWD_Info::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AWD_Info_descriptor_;
}

const AWD_Info& AWD_Info::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

AWD_Info* AWD_Info::default_instance_ = NULL;

AWD_Info* AWD_Info::New() const {
  return new AWD_Info;
}

void AWD_Info::Clear() {
  awd_mode_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AWD_Info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.AWD_Info)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 AWD_Mode = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &awd_mode_)));
          set_has_awd_mode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.AWD_Info)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.AWD_Info)
  return false;
#undef DO_
}

void AWD_Info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.AWD_Info)
  // optional uint32 AWD_Mode = 1;
  if (has_awd_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->awd_mode(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.AWD_Info)
}

::google::protobuf::uint8* AWD_Info::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.AWD_Info)
  // optional uint32 AWD_Mode = 1;
  if (has_awd_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->awd_mode(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.AWD_Info)
  return target;
}

int AWD_Info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 AWD_Mode = 1;
    if (has_awd_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->awd_mode());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AWD_Info::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AWD_Info* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AWD_Info*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AWD_Info::MergeFrom(const AWD_Info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_awd_mode()) {
      set_awd_mode(from.awd_mode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AWD_Info::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AWD_Info::CopyFrom(const AWD_Info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AWD_Info::IsInitialized() const {

  return true;
}

void AWD_Info::Swap(AWD_Info* other) {
  if (other != this) {
    std::swap(awd_mode_, other->awd_mode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AWD_Info::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AWD_Info_descriptor_;
  metadata.reflection = AWD_Info_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AC_Info::kACOnStateFieldNumber;
const int AC_Info::kAirDistributionModeFieldNumber;
const int AC_Info::kACInsideSenTempFieldNumber;
#endif  // !_MSC_VER

AC_Info::AC_Info()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.AC_Info)
}

void AC_Info::InitAsDefaultInstance() {
}

AC_Info::AC_Info(const AC_Info& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.AC_Info)
}

void AC_Info::SharedCtor() {
  _cached_size_ = 0;
  ac_onstate_ = false;
  airdistribution_mode_ = 0u;
  acinsidesen_temp_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AC_Info::~AC_Info() {
  // @@protoc_insertion_point(destructor:zna.protocol.AC_Info)
  SharedDtor();
}

void AC_Info::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AC_Info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AC_Info::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AC_Info_descriptor_;
}

const AC_Info& AC_Info::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

AC_Info* AC_Info::default_instance_ = NULL;

AC_Info* AC_Info::New() const {
  return new AC_Info;
}

void AC_Info::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<AC_Info*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(ac_onstate_, acinsidesen_temp_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AC_Info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.AC_Info)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool AC_OnState = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &ac_onstate_)));
          set_has_ac_onstate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_AirDistribution_Mode;
        break;
      }

      // optional uint32 AirDistribution_Mode = 2;
      case 2: {
        if (tag == 16) {
         parse_AirDistribution_Mode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &airdistribution_mode_)));
          set_has_airdistribution_mode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_ACInsideSen_Temp;
        break;
      }

      // optional uint32 ACInsideSen_Temp = 3;
      case 3: {
        if (tag == 24) {
         parse_ACInsideSen_Temp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &acinsidesen_temp_)));
          set_has_acinsidesen_temp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.AC_Info)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.AC_Info)
  return false;
#undef DO_
}

void AC_Info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.AC_Info)
  // optional bool AC_OnState = 1;
  if (has_ac_onstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->ac_onstate(), output);
  }

  // optional uint32 AirDistribution_Mode = 2;
  if (has_airdistribution_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->airdistribution_mode(), output);
  }

  // optional uint32 ACInsideSen_Temp = 3;
  if (has_acinsidesen_temp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->acinsidesen_temp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.AC_Info)
}

::google::protobuf::uint8* AC_Info::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.AC_Info)
  // optional bool AC_OnState = 1;
  if (has_ac_onstate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->ac_onstate(), target);
  }

  // optional uint32 AirDistribution_Mode = 2;
  if (has_airdistribution_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->airdistribution_mode(), target);
  }

  // optional uint32 ACInsideSen_Temp = 3;
  if (has_acinsidesen_temp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->acinsidesen_temp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.AC_Info)
  return target;
}

int AC_Info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool AC_OnState = 1;
    if (has_ac_onstate()) {
      total_size += 1 + 1;
    }

    // optional uint32 AirDistribution_Mode = 2;
    if (has_airdistribution_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->airdistribution_mode());
    }

    // optional uint32 ACInsideSen_Temp = 3;
    if (has_acinsidesen_temp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->acinsidesen_temp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AC_Info::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AC_Info* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AC_Info*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AC_Info::MergeFrom(const AC_Info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ac_onstate()) {
      set_ac_onstate(from.ac_onstate());
    }
    if (from.has_airdistribution_mode()) {
      set_airdistribution_mode(from.airdistribution_mode());
    }
    if (from.has_acinsidesen_temp()) {
      set_acinsidesen_temp(from.acinsidesen_temp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AC_Info::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AC_Info::CopyFrom(const AC_Info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AC_Info::IsInitialized() const {

  return true;
}

void AC_Info::Swap(AC_Info* other) {
  if (other != this) {
    std::swap(ac_onstate_, other->ac_onstate_);
    std::swap(airdistribution_mode_, other->airdistribution_mode_);
    std::swap(acinsidesen_temp_, other->acinsidesen_temp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AC_Info::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AC_Info_descriptor_;
  metadata.reflection = AC_Info_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SAS_Info::kSteeringAngelFieldNumber;
const int SAS_Info::kSteeringAngelVelocityFieldNumber;
#endif  // !_MSC_VER

SAS_Info::SAS_Info()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.SAS_Info)
}

void SAS_Info::InitAsDefaultInstance() {
}

SAS_Info::SAS_Info(const SAS_Info& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.SAS_Info)
}

void SAS_Info::SharedCtor() {
  _cached_size_ = 0;
  steeringangel_ = 0u;
  steeringangel_velocity_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SAS_Info::~SAS_Info() {
  // @@protoc_insertion_point(destructor:zna.protocol.SAS_Info)
  SharedDtor();
}

void SAS_Info::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SAS_Info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SAS_Info::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SAS_Info_descriptor_;
}

const SAS_Info& SAS_Info::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

SAS_Info* SAS_Info::default_instance_ = NULL;

SAS_Info* SAS_Info::New() const {
  return new SAS_Info;
}

void SAS_Info::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SAS_Info*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(steeringangel_, steeringangel_velocity_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SAS_Info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.SAS_Info)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 SteeringAngel = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &steeringangel_)));
          set_has_steeringangel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_SteeringAngel_Velocity;
        break;
      }

      // optional uint32 SteeringAngel_Velocity = 2;
      case 2: {
        if (tag == 16) {
         parse_SteeringAngel_Velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &steeringangel_velocity_)));
          set_has_steeringangel_velocity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.SAS_Info)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.SAS_Info)
  return false;
#undef DO_
}

void SAS_Info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.SAS_Info)
  // optional uint32 SteeringAngel = 1;
  if (has_steeringangel()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->steeringangel(), output);
  }

  // optional uint32 SteeringAngel_Velocity = 2;
  if (has_steeringangel_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->steeringangel_velocity(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.SAS_Info)
}

::google::protobuf::uint8* SAS_Info::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.SAS_Info)
  // optional uint32 SteeringAngel = 1;
  if (has_steeringangel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->steeringangel(), target);
  }

  // optional uint32 SteeringAngel_Velocity = 2;
  if (has_steeringangel_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->steeringangel_velocity(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.SAS_Info)
  return target;
}

int SAS_Info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 SteeringAngel = 1;
    if (has_steeringangel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->steeringangel());
    }

    // optional uint32 SteeringAngel_Velocity = 2;
    if (has_steeringangel_velocity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->steeringangel_velocity());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SAS_Info::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SAS_Info* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SAS_Info*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SAS_Info::MergeFrom(const SAS_Info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_steeringangel()) {
      set_steeringangel(from.steeringangel());
    }
    if (from.has_steeringangel_velocity()) {
      set_steeringangel_velocity(from.steeringangel_velocity());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SAS_Info::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SAS_Info::CopyFrom(const SAS_Info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SAS_Info::IsInitialized() const {

  return true;
}

void SAS_Info::Swap(SAS_Info* other) {
  if (other != this) {
    std::swap(steeringangel_, other->steeringangel_);
    std::swap(steeringangel_velocity_, other->steeringangel_velocity_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SAS_Info::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SAS_Info_descriptor_;
  metadata.reflection = SAS_Info_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Basic_Info::kEcmInfoFieldNumber;
const int Basic_Info::kMeterInfoFieldNumber;
const int Basic_Info::kBcmInfoFieldNumber;
const int Basic_Info::kAcuInfoFieldNumber;
const int Basic_Info::kEcoInfoFieldNumber;
const int Basic_Info::kAlarmInfoFieldNumber;
const int Basic_Info::kPepsInfoFieldNumber;
const int Basic_Info::kEspInfoFieldNumber;
const int Basic_Info::kEpbInfoFieldNumber;
const int Basic_Info::kTcuInfoFieldNumber;
const int Basic_Info::kAwdInfoFieldNumber;
const int Basic_Info::kAcInfoFieldNumber;
const int Basic_Info::kSasInfoFieldNumber;
const int Basic_Info::kFcmInfoFieldNumber;
const int Basic_Info::kEpsInfoFieldNumber;
const int Basic_Info::kEldInfoFieldNumber;
const int Basic_Info::kEcuInfoFieldNumber;
#endif  // !_MSC_VER

Basic_Info::Basic_Info()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.Basic_Info)
}

void Basic_Info::InitAsDefaultInstance() {
  ecm_info_ = const_cast< ::zna::protocol::ECM_Info*>(&::zna::protocol::ECM_Info::default_instance());
  meter_info_ = const_cast< ::zna::protocol::METER_Info*>(&::zna::protocol::METER_Info::default_instance());
  bcm_info_ = const_cast< ::zna::protocol::BCM_Info*>(&::zna::protocol::BCM_Info::default_instance());
  acu_info_ = const_cast< ::zna::protocol::ACU_Info*>(&::zna::protocol::ACU_Info::default_instance());
  eco_info_ = const_cast< ::zna::protocol::ECO_Info*>(&::zna::protocol::ECO_Info::default_instance());
  alarm_info_ = const_cast< ::zna::protocol::ALARM_Info*>(&::zna::protocol::ALARM_Info::default_instance());
  peps_info_ = const_cast< ::zna::protocol::PEPS_Info*>(&::zna::protocol::PEPS_Info::default_instance());
  esp_info_ = const_cast< ::zna::protocol::ESP_Info*>(&::zna::protocol::ESP_Info::default_instance());
  epb_info_ = const_cast< ::zna::protocol::EPB_Info*>(&::zna::protocol::EPB_Info::default_instance());
  tcu_info_ = const_cast< ::zna::protocol::TCU_Info*>(&::zna::protocol::TCU_Info::default_instance());
  awd_info_ = const_cast< ::zna::protocol::AWD_Info*>(&::zna::protocol::AWD_Info::default_instance());
  ac_info_ = const_cast< ::zna::protocol::AC_Info*>(&::zna::protocol::AC_Info::default_instance());
  sas_info_ = const_cast< ::zna::protocol::SAS_Info*>(&::zna::protocol::SAS_Info::default_instance());
  fcm_info_ = const_cast< ::zna::protocol::FCM_Info*>(&::zna::protocol::FCM_Info::default_instance());
  eps_info_ = const_cast< ::zna::protocol::EPS_Info*>(&::zna::protocol::EPS_Info::default_instance());
  eld_info_ = const_cast< ::zna::protocol::ELD_Info*>(&::zna::protocol::ELD_Info::default_instance());
  ecu_info_ = const_cast< ::zna::protocol::ECU_Info*>(&::zna::protocol::ECU_Info::default_instance());
}

Basic_Info::Basic_Info(const Basic_Info& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.Basic_Info)
}

void Basic_Info::SharedCtor() {
  _cached_size_ = 0;
  ecm_info_ = NULL;
  meter_info_ = NULL;
  bcm_info_ = NULL;
  acu_info_ = NULL;
  eco_info_ = NULL;
  alarm_info_ = NULL;
  peps_info_ = NULL;
  esp_info_ = NULL;
  epb_info_ = NULL;
  tcu_info_ = NULL;
  awd_info_ = NULL;
  ac_info_ = NULL;
  sas_info_ = NULL;
  fcm_info_ = NULL;
  eps_info_ = NULL;
  eld_info_ = NULL;
  ecu_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Basic_Info::~Basic_Info() {
  // @@protoc_insertion_point(destructor:zna.protocol.Basic_Info)
  SharedDtor();
}

void Basic_Info::SharedDtor() {
  if (this != default_instance_) {
    delete ecm_info_;
    delete meter_info_;
    delete bcm_info_;
    delete acu_info_;
    delete eco_info_;
    delete alarm_info_;
    delete peps_info_;
    delete esp_info_;
    delete epb_info_;
    delete tcu_info_;
    delete awd_info_;
    delete ac_info_;
    delete sas_info_;
    delete fcm_info_;
    delete eps_info_;
    delete eld_info_;
    delete ecu_info_;
  }
}

void Basic_Info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Basic_Info::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Basic_Info_descriptor_;
}

const Basic_Info& Basic_Info::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

Basic_Info* Basic_Info::default_instance_ = NULL;

Basic_Info* Basic_Info::New() const {
  return new Basic_Info;
}

void Basic_Info::Clear() {
  if (_has_bits_[0 / 32] & 255) {
    if (has_ecm_info()) {
      if (ecm_info_ != NULL) ecm_info_->::zna::protocol::ECM_Info::Clear();
    }
    if (has_meter_info()) {
      if (meter_info_ != NULL) meter_info_->::zna::protocol::METER_Info::Clear();
    }
    if (has_bcm_info()) {
      if (bcm_info_ != NULL) bcm_info_->::zna::protocol::BCM_Info::Clear();
    }
    if (has_acu_info()) {
      if (acu_info_ != NULL) acu_info_->::zna::protocol::ACU_Info::Clear();
    }
    if (has_eco_info()) {
      if (eco_info_ != NULL) eco_info_->::zna::protocol::ECO_Info::Clear();
    }
    if (has_alarm_info()) {
      if (alarm_info_ != NULL) alarm_info_->::zna::protocol::ALARM_Info::Clear();
    }
    if (has_peps_info()) {
      if (peps_info_ != NULL) peps_info_->::zna::protocol::PEPS_Info::Clear();
    }
    if (has_esp_info()) {
      if (esp_info_ != NULL) esp_info_->::zna::protocol::ESP_Info::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 65280) {
    if (has_epb_info()) {
      if (epb_info_ != NULL) epb_info_->::zna::protocol::EPB_Info::Clear();
    }
    if (has_tcu_info()) {
      if (tcu_info_ != NULL) tcu_info_->::zna::protocol::TCU_Info::Clear();
    }
    if (has_awd_info()) {
      if (awd_info_ != NULL) awd_info_->::zna::protocol::AWD_Info::Clear();
    }
    if (has_ac_info()) {
      if (ac_info_ != NULL) ac_info_->::zna::protocol::AC_Info::Clear();
    }
    if (has_sas_info()) {
      if (sas_info_ != NULL) sas_info_->::zna::protocol::SAS_Info::Clear();
    }
    if (has_fcm_info()) {
      if (fcm_info_ != NULL) fcm_info_->::zna::protocol::FCM_Info::Clear();
    }
    if (has_eps_info()) {
      if (eps_info_ != NULL) eps_info_->::zna::protocol::EPS_Info::Clear();
    }
    if (has_eld_info()) {
      if (eld_info_ != NULL) eld_info_->::zna::protocol::ELD_Info::Clear();
    }
  }
  if (has_ecu_info()) {
    if (ecu_info_ != NULL) ecu_info_->::zna::protocol::ECU_Info::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Basic_Info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.Basic_Info)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .zna.protocol.ECM_Info ecm_info = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ecm_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_meter_info;
        break;
      }

      // optional .zna.protocol.METER_Info meter_info = 3;
      case 3: {
        if (tag == 26) {
         parse_meter_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_meter_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_bcm_info;
        break;
      }

      // optional .zna.protocol.BCM_Info bcm_info = 4;
      case 4: {
        if (tag == 34) {
         parse_bcm_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bcm_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_acu_info;
        break;
      }

      // optional .zna.protocol.ACU_Info acu_info = 5;
      case 5: {
        if (tag == 42) {
         parse_acu_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_acu_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_eco_info;
        break;
      }

      // optional .zna.protocol.ECO_Info eco_info = 12;
      case 12: {
        if (tag == 98) {
         parse_eco_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_eco_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_alarm_info;
        break;
      }

      // optional .zna.protocol.ALARM_Info alarm_info = 13;
      case 13: {
        if (tag == 106) {
         parse_alarm_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_alarm_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_peps_info;
        break;
      }

      // optional .zna.protocol.PEPS_Info peps_info = 20;
      case 20: {
        if (tag == 162) {
         parse_peps_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_peps_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(170)) goto parse_esp_info;
        break;
      }

      // optional .zna.protocol.ESP_Info esp_info = 21;
      case 21: {
        if (tag == 170) {
         parse_esp_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_esp_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(178)) goto parse_epb_info;
        break;
      }

      // optional .zna.protocol.EPB_Info epb_info = 22;
      case 22: {
        if (tag == 178) {
         parse_epb_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_epb_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(186)) goto parse_tcu_info;
        break;
      }

      // optional .zna.protocol.TCU_Info tcu_info = 23;
      case 23: {
        if (tag == 186) {
         parse_tcu_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tcu_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(194)) goto parse_awd_info;
        break;
      }

      // optional .zna.protocol.AWD_Info awd_info = 24;
      case 24: {
        if (tag == 194) {
         parse_awd_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_awd_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(202)) goto parse_ac_info;
        break;
      }

      // optional .zna.protocol.AC_Info ac_info = 25;
      case 25: {
        if (tag == 202) {
         parse_ac_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ac_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(210)) goto parse_sas_info;
        break;
      }

      // optional .zna.protocol.SAS_Info sas_info = 26;
      case 26: {
        if (tag == 210) {
         parse_sas_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sas_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(218)) goto parse_fcm_info;
        break;
      }

      // optional .zna.protocol.FCM_Info fcm_info = 27;
      case 27: {
        if (tag == 218) {
         parse_fcm_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_fcm_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(226)) goto parse_eps_info;
        break;
      }

      // optional .zna.protocol.EPS_Info eps_info = 28;
      case 28: {
        if (tag == 226) {
         parse_eps_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_eps_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(234)) goto parse_eld_info;
        break;
      }

      // optional .zna.protocol.ELD_Info eld_info = 29;
      case 29: {
        if (tag == 234) {
         parse_eld_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_eld_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(242)) goto parse_ecu_info;
        break;
      }

      // optional .zna.protocol.ECU_Info ecu_info = 30;
      case 30: {
        if (tag == 242) {
         parse_ecu_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ecu_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.Basic_Info)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.Basic_Info)
  return false;
#undef DO_
}

void Basic_Info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.Basic_Info)
  // optional .zna.protocol.ECM_Info ecm_info = 1;
  if (has_ecm_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->ecm_info(), output);
  }

  // optional .zna.protocol.METER_Info meter_info = 3;
  if (has_meter_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->meter_info(), output);
  }

  // optional .zna.protocol.BCM_Info bcm_info = 4;
  if (has_bcm_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->bcm_info(), output);
  }

  // optional .zna.protocol.ACU_Info acu_info = 5;
  if (has_acu_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->acu_info(), output);
  }

  // optional .zna.protocol.ECO_Info eco_info = 12;
  if (has_eco_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->eco_info(), output);
  }

  // optional .zna.protocol.ALARM_Info alarm_info = 13;
  if (has_alarm_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, this->alarm_info(), output);
  }

  // optional .zna.protocol.PEPS_Info peps_info = 20;
  if (has_peps_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      20, this->peps_info(), output);
  }

  // optional .zna.protocol.ESP_Info esp_info = 21;
  if (has_esp_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      21, this->esp_info(), output);
  }

  // optional .zna.protocol.EPB_Info epb_info = 22;
  if (has_epb_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      22, this->epb_info(), output);
  }

  // optional .zna.protocol.TCU_Info tcu_info = 23;
  if (has_tcu_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      23, this->tcu_info(), output);
  }

  // optional .zna.protocol.AWD_Info awd_info = 24;
  if (has_awd_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      24, this->awd_info(), output);
  }

  // optional .zna.protocol.AC_Info ac_info = 25;
  if (has_ac_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      25, this->ac_info(), output);
  }

  // optional .zna.protocol.SAS_Info sas_info = 26;
  if (has_sas_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      26, this->sas_info(), output);
  }

  // optional .zna.protocol.FCM_Info fcm_info = 27;
  if (has_fcm_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      27, this->fcm_info(), output);
  }

  // optional .zna.protocol.EPS_Info eps_info = 28;
  if (has_eps_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      28, this->eps_info(), output);
  }

  // optional .zna.protocol.ELD_Info eld_info = 29;
  if (has_eld_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      29, this->eld_info(), output);
  }

  // optional .zna.protocol.ECU_Info ecu_info = 30;
  if (has_ecu_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      30, this->ecu_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.Basic_Info)
}

::google::protobuf::uint8* Basic_Info::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.Basic_Info)
  // optional .zna.protocol.ECM_Info ecm_info = 1;
  if (has_ecm_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->ecm_info(), target);
  }

  // optional .zna.protocol.METER_Info meter_info = 3;
  if (has_meter_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->meter_info(), target);
  }

  // optional .zna.protocol.BCM_Info bcm_info = 4;
  if (has_bcm_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->bcm_info(), target);
  }

  // optional .zna.protocol.ACU_Info acu_info = 5;
  if (has_acu_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->acu_info(), target);
  }

  // optional .zna.protocol.ECO_Info eco_info = 12;
  if (has_eco_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->eco_info(), target);
  }

  // optional .zna.protocol.ALARM_Info alarm_info = 13;
  if (has_alarm_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, this->alarm_info(), target);
  }

  // optional .zna.protocol.PEPS_Info peps_info = 20;
  if (has_peps_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        20, this->peps_info(), target);
  }

  // optional .zna.protocol.ESP_Info esp_info = 21;
  if (has_esp_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        21, this->esp_info(), target);
  }

  // optional .zna.protocol.EPB_Info epb_info = 22;
  if (has_epb_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        22, this->epb_info(), target);
  }

  // optional .zna.protocol.TCU_Info tcu_info = 23;
  if (has_tcu_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        23, this->tcu_info(), target);
  }

  // optional .zna.protocol.AWD_Info awd_info = 24;
  if (has_awd_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        24, this->awd_info(), target);
  }

  // optional .zna.protocol.AC_Info ac_info = 25;
  if (has_ac_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        25, this->ac_info(), target);
  }

  // optional .zna.protocol.SAS_Info sas_info = 26;
  if (has_sas_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        26, this->sas_info(), target);
  }

  // optional .zna.protocol.FCM_Info fcm_info = 27;
  if (has_fcm_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        27, this->fcm_info(), target);
  }

  // optional .zna.protocol.EPS_Info eps_info = 28;
  if (has_eps_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        28, this->eps_info(), target);
  }

  // optional .zna.protocol.ELD_Info eld_info = 29;
  if (has_eld_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        29, this->eld_info(), target);
  }

  // optional .zna.protocol.ECU_Info ecu_info = 30;
  if (has_ecu_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        30, this->ecu_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.Basic_Info)
  return target;
}

int Basic_Info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .zna.protocol.ECM_Info ecm_info = 1;
    if (has_ecm_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ecm_info());
    }

    // optional .zna.protocol.METER_Info meter_info = 3;
    if (has_meter_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->meter_info());
    }

    // optional .zna.protocol.BCM_Info bcm_info = 4;
    if (has_bcm_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->bcm_info());
    }

    // optional .zna.protocol.ACU_Info acu_info = 5;
    if (has_acu_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->acu_info());
    }

    // optional .zna.protocol.ECO_Info eco_info = 12;
    if (has_eco_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->eco_info());
    }

    // optional .zna.protocol.ALARM_Info alarm_info = 13;
    if (has_alarm_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->alarm_info());
    }

    // optional .zna.protocol.PEPS_Info peps_info = 20;
    if (has_peps_info()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->peps_info());
    }

    // optional .zna.protocol.ESP_Info esp_info = 21;
    if (has_esp_info()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->esp_info());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .zna.protocol.EPB_Info epb_info = 22;
    if (has_epb_info()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->epb_info());
    }

    // optional .zna.protocol.TCU_Info tcu_info = 23;
    if (has_tcu_info()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->tcu_info());
    }

    // optional .zna.protocol.AWD_Info awd_info = 24;
    if (has_awd_info()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->awd_info());
    }

    // optional .zna.protocol.AC_Info ac_info = 25;
    if (has_ac_info()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ac_info());
    }

    // optional .zna.protocol.SAS_Info sas_info = 26;
    if (has_sas_info()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sas_info());
    }

    // optional .zna.protocol.FCM_Info fcm_info = 27;
    if (has_fcm_info()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->fcm_info());
    }

    // optional .zna.protocol.EPS_Info eps_info = 28;
    if (has_eps_info()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->eps_info());
    }

    // optional .zna.protocol.ELD_Info eld_info = 29;
    if (has_eld_info()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->eld_info());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional .zna.protocol.ECU_Info ecu_info = 30;
    if (has_ecu_info()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ecu_info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Basic_Info::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Basic_Info* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Basic_Info*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Basic_Info::MergeFrom(const Basic_Info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ecm_info()) {
      mutable_ecm_info()->::zna::protocol::ECM_Info::MergeFrom(from.ecm_info());
    }
    if (from.has_meter_info()) {
      mutable_meter_info()->::zna::protocol::METER_Info::MergeFrom(from.meter_info());
    }
    if (from.has_bcm_info()) {
      mutable_bcm_info()->::zna::protocol::BCM_Info::MergeFrom(from.bcm_info());
    }
    if (from.has_acu_info()) {
      mutable_acu_info()->::zna::protocol::ACU_Info::MergeFrom(from.acu_info());
    }
    if (from.has_eco_info()) {
      mutable_eco_info()->::zna::protocol::ECO_Info::MergeFrom(from.eco_info());
    }
    if (from.has_alarm_info()) {
      mutable_alarm_info()->::zna::protocol::ALARM_Info::MergeFrom(from.alarm_info());
    }
    if (from.has_peps_info()) {
      mutable_peps_info()->::zna::protocol::PEPS_Info::MergeFrom(from.peps_info());
    }
    if (from.has_esp_info()) {
      mutable_esp_info()->::zna::protocol::ESP_Info::MergeFrom(from.esp_info());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_epb_info()) {
      mutable_epb_info()->::zna::protocol::EPB_Info::MergeFrom(from.epb_info());
    }
    if (from.has_tcu_info()) {
      mutable_tcu_info()->::zna::protocol::TCU_Info::MergeFrom(from.tcu_info());
    }
    if (from.has_awd_info()) {
      mutable_awd_info()->::zna::protocol::AWD_Info::MergeFrom(from.awd_info());
    }
    if (from.has_ac_info()) {
      mutable_ac_info()->::zna::protocol::AC_Info::MergeFrom(from.ac_info());
    }
    if (from.has_sas_info()) {
      mutable_sas_info()->::zna::protocol::SAS_Info::MergeFrom(from.sas_info());
    }
    if (from.has_fcm_info()) {
      mutable_fcm_info()->::zna::protocol::FCM_Info::MergeFrom(from.fcm_info());
    }
    if (from.has_eps_info()) {
      mutable_eps_info()->::zna::protocol::EPS_Info::MergeFrom(from.eps_info());
    }
    if (from.has_eld_info()) {
      mutable_eld_info()->::zna::protocol::ELD_Info::MergeFrom(from.eld_info());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_ecu_info()) {
      mutable_ecu_info()->::zna::protocol::ECU_Info::MergeFrom(from.ecu_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Basic_Info::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Basic_Info::CopyFrom(const Basic_Info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Basic_Info::IsInitialized() const {

  return true;
}

void Basic_Info::Swap(Basic_Info* other) {
  if (other != this) {
    std::swap(ecm_info_, other->ecm_info_);
    std::swap(meter_info_, other->meter_info_);
    std::swap(bcm_info_, other->bcm_info_);
    std::swap(acu_info_, other->acu_info_);
    std::swap(eco_info_, other->eco_info_);
    std::swap(alarm_info_, other->alarm_info_);
    std::swap(peps_info_, other->peps_info_);
    std::swap(esp_info_, other->esp_info_);
    std::swap(epb_info_, other->epb_info_);
    std::swap(tcu_info_, other->tcu_info_);
    std::swap(awd_info_, other->awd_info_);
    std::swap(ac_info_, other->ac_info_);
    std::swap(sas_info_, other->sas_info_);
    std::swap(fcm_info_, other->fcm_info_);
    std::swap(eps_info_, other->eps_info_);
    std::swap(eld_info_, other->eld_info_);
    std::swap(ecu_info_, other->ecu_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Basic_Info::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Basic_Info_descriptor_;
  metadata.reflection = Basic_Info_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Vehicle_Info::kInfoTypeFieldNumber;
const int Vehicle_Info::kCollectTimeFieldNumber;
const int Vehicle_Info::kBasicInfoFieldNumber;
const int Vehicle_Info::kTimeStampFieldNumber;
const int Vehicle_Info::kIgnOnTagFieldNumber;
const int Vehicle_Info::kEF82FieldNumber;
const int Vehicle_Info::kVersionFieldNumber;
#endif  // !_MSC_VER

Vehicle_Info::Vehicle_Info()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.Vehicle_Info)
}

void Vehicle_Info::InitAsDefaultInstance() {
  basic_info_ = const_cast< ::zna::protocol::Basic_Info*>(&::zna::protocol::Basic_Info::default_instance());
}

Vehicle_Info::Vehicle_Info(const Vehicle_Info& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.Vehicle_Info)
}

void Vehicle_Info::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  info_type_ = false;
  collect_time_ = 0u;
  basic_info_ = NULL;
  time_stamp_ = 0u;
  ignontag_ = 0u;
  ef82_ = 0u;
  version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Vehicle_Info::~Vehicle_Info() {
  // @@protoc_insertion_point(destructor:zna.protocol.Vehicle_Info)
  SharedDtor();
}

void Vehicle_Info::SharedDtor() {
  if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete version_;
  }
  if (this != default_instance_) {
    delete basic_info_;
  }
}

void Vehicle_Info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Vehicle_Info::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Vehicle_Info_descriptor_;
}

const Vehicle_Info& Vehicle_Info::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

Vehicle_Info* Vehicle_Info::default_instance_ = NULL;

Vehicle_Info* Vehicle_Info::New() const {
  return new Vehicle_Info;
}

void Vehicle_Info::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Vehicle_Info*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 127) {
    ZR_(info_type_, collect_time_);
    ZR_(time_stamp_, ignontag_);
    if (has_basic_info()) {
      if (basic_info_ != NULL) basic_info_->::zna::protocol::Basic_Info::Clear();
    }
    ef82_ = 0u;
    if (has_version()) {
      if (version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        version_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Vehicle_Info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.Vehicle_Info)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool Info_type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &info_type_)));
          set_has_info_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_collect_time;
        break;
      }

      // required uint32 collect_time = 2;
      case 2: {
        if (tag == 16) {
         parse_collect_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &collect_time_)));
          set_has_collect_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_basic_info;
        break;
      }

      // required .zna.protocol.Basic_Info basic_info = 3;
      case 3: {
        if (tag == 26) {
         parse_basic_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_basic_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_time_stamp;
        break;
      }

      // required uint32 time_stamp = 4;
      case 4: {
        if (tag == 32) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_IgnOnTag;
        break;
      }

      // optional uint32 IgnOnTag = 5;
      case 5: {
        if (tag == 40) {
         parse_IgnOnTag:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ignontag_)));
          set_has_ignontag();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_EF82;
        break;
      }

      // optional uint32 EF82 = 6;
      case 6: {
        if (tag == 48) {
         parse_EF82:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ef82_)));
          set_has_ef82();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_Version;
        break;
      }

      // optional string Version = 7;
      case 7: {
        if (tag == 58) {
         parse_Version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "version");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.Vehicle_Info)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.Vehicle_Info)
  return false;
#undef DO_
}

void Vehicle_Info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.Vehicle_Info)
  // required bool Info_type = 1;
  if (has_info_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->info_type(), output);
  }

  // required uint32 collect_time = 2;
  if (has_collect_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->collect_time(), output);
  }

  // required .zna.protocol.Basic_Info basic_info = 3;
  if (has_basic_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->basic_info(), output);
  }

  // required uint32 time_stamp = 4;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->time_stamp(), output);
  }

  // optional uint32 IgnOnTag = 5;
  if (has_ignontag()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->ignontag(), output);
  }

  // optional uint32 EF82 = 6;
  if (has_ef82()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->ef82(), output);
  }

  // optional string Version = 7;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->version(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.Vehicle_Info)
}

::google::protobuf::uint8* Vehicle_Info::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.Vehicle_Info)
  // required bool Info_type = 1;
  if (has_info_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->info_type(), target);
  }

  // required uint32 collect_time = 2;
  if (has_collect_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->collect_time(), target);
  }

  // required .zna.protocol.Basic_Info basic_info = 3;
  if (has_basic_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->basic_info(), target);
  }

  // required uint32 time_stamp = 4;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->time_stamp(), target);
  }

  // optional uint32 IgnOnTag = 5;
  if (has_ignontag()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->ignontag(), target);
  }

  // optional uint32 EF82 = 6;
  if (has_ef82()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->ef82(), target);
  }

  // optional string Version = 7;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->version(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.Vehicle_Info)
  return target;
}

int Vehicle_Info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool Info_type = 1;
    if (has_info_type()) {
      total_size += 1 + 1;
    }

    // required uint32 collect_time = 2;
    if (has_collect_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->collect_time());
    }

    // required .zna.protocol.Basic_Info basic_info = 3;
    if (has_basic_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->basic_info());
    }

    // required uint32 time_stamp = 4;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

    // optional uint32 IgnOnTag = 5;
    if (has_ignontag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ignontag());
    }

    // optional uint32 EF82 = 6;
    if (has_ef82()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ef82());
    }

    // optional string Version = 7;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Vehicle_Info::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Vehicle_Info* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Vehicle_Info*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Vehicle_Info::MergeFrom(const Vehicle_Info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_info_type()) {
      set_info_type(from.info_type());
    }
    if (from.has_collect_time()) {
      set_collect_time(from.collect_time());
    }
    if (from.has_basic_info()) {
      mutable_basic_info()->::zna::protocol::Basic_Info::MergeFrom(from.basic_info());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_ignontag()) {
      set_ignontag(from.ignontag());
    }
    if (from.has_ef82()) {
      set_ef82(from.ef82());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Vehicle_Info::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Vehicle_Info::CopyFrom(const Vehicle_Info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vehicle_Info::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void Vehicle_Info::Swap(Vehicle_Info* other) {
  if (other != this) {
    std::swap(info_type_, other->info_type_);
    std::swap(collect_time_, other->collect_time_);
    std::swap(basic_info_, other->basic_info_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(ignontag_, other->ignontag_);
    std::swap(ef82_, other->ef82_);
    std::swap(version_, other->version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Vehicle_Info::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Vehicle_Info_descriptor_;
  metadata.reflection = Vehicle_Info_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Vehicle_InfoRsp::kErrcodeFieldNumber;
const int Vehicle_InfoRsp::kTimeStampFieldNumber;
#endif  // !_MSC_VER

Vehicle_InfoRsp::Vehicle_InfoRsp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.Vehicle_InfoRsp)
}

void Vehicle_InfoRsp::InitAsDefaultInstance() {
}

Vehicle_InfoRsp::Vehicle_InfoRsp(const Vehicle_InfoRsp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.Vehicle_InfoRsp)
}

void Vehicle_InfoRsp::SharedCtor() {
  _cached_size_ = 0;
  errcode_ = 0u;
  time_stamp_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Vehicle_InfoRsp::~Vehicle_InfoRsp() {
  // @@protoc_insertion_point(destructor:zna.protocol.Vehicle_InfoRsp)
  SharedDtor();
}

void Vehicle_InfoRsp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Vehicle_InfoRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Vehicle_InfoRsp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Vehicle_InfoRsp_descriptor_;
}

const Vehicle_InfoRsp& Vehicle_InfoRsp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

Vehicle_InfoRsp* Vehicle_InfoRsp::default_instance_ = NULL;

Vehicle_InfoRsp* Vehicle_InfoRsp::New() const {
  return new Vehicle_InfoRsp;
}

void Vehicle_InfoRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Vehicle_InfoRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(errcode_, time_stamp_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Vehicle_InfoRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.Vehicle_InfoRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 errcode = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &errcode_)));
          set_has_errcode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_time_stamp;
        break;
      }

      // required uint32 time_stamp = 2;
      case 2: {
        if (tag == 16) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.Vehicle_InfoRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.Vehicle_InfoRsp)
  return false;
#undef DO_
}

void Vehicle_InfoRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.Vehicle_InfoRsp)
  // required uint32 errcode = 1;
  if (has_errcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->errcode(), output);
  }

  // required uint32 time_stamp = 2;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->time_stamp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.Vehicle_InfoRsp)
}

::google::protobuf::uint8* Vehicle_InfoRsp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.Vehicle_InfoRsp)
  // required uint32 errcode = 1;
  if (has_errcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->errcode(), target);
  }

  // required uint32 time_stamp = 2;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->time_stamp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.Vehicle_InfoRsp)
  return target;
}

int Vehicle_InfoRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 errcode = 1;
    if (has_errcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->errcode());
    }

    // required uint32 time_stamp = 2;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Vehicle_InfoRsp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Vehicle_InfoRsp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Vehicle_InfoRsp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Vehicle_InfoRsp::MergeFrom(const Vehicle_InfoRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_errcode()) {
      set_errcode(from.errcode());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Vehicle_InfoRsp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Vehicle_InfoRsp::CopyFrom(const Vehicle_InfoRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vehicle_InfoRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Vehicle_InfoRsp::Swap(Vehicle_InfoRsp* other) {
  if (other != this) {
    std::swap(errcode_, other->errcode_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Vehicle_InfoRsp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Vehicle_InfoRsp_descriptor_;
  metadata.reflection = Vehicle_InfoRsp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Location_Info::kInfoTypeFieldNumber;
const int Location_Info::kLocationStatusFieldNumber;
const int Location_Info::kLongitudeFieldNumber;
const int Location_Info::kLatitudeFieldNumber;
const int Location_Info::kTimeStampFieldNumber;
const int Location_Info::kIsGPSconversionFieldNumber;
const int Location_Info::kGpsTimeFieldNumber;
const int Location_Info::kHeightValidFieldNumber;
const int Location_Info::kHeightDataFieldNumber;
#endif  // !_MSC_VER

Location_Info::Location_Info()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.Location_Info)
}

void Location_Info::InitAsDefaultInstance() {
}

Location_Info::Location_Info(const Location_Info& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.Location_Info)
}

void Location_Info::SharedCtor() {
  _cached_size_ = 0;
  info_type_ = false;
  location_status_ = 0u;
  longitude_ = 0u;
  latitude_ = 0u;
  time_stamp_ = 0u;
  isgpsconversion_ = 0u;
  gps_time_ = GOOGLE_ULONGLONG(0);
  height_valid_ = 0u;
  height_data_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Location_Info::~Location_Info() {
  // @@protoc_insertion_point(destructor:zna.protocol.Location_Info)
  SharedDtor();
}

void Location_Info::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Location_Info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Location_Info::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Location_Info_descriptor_;
}

const Location_Info& Location_Info::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

Location_Info* Location_Info::default_instance_ = NULL;

Location_Info* Location_Info::New() const {
  return new Location_Info;
}

void Location_Info::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Location_Info*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(info_type_, height_valid_);
  }
  height_data_ = 0u;

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Location_Info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.Location_Info)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool Info_type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &info_type_)));
          set_has_info_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_location_status;
        break;
      }

      // required uint32 location_status = 3;
      case 3: {
        if (tag == 24) {
         parse_location_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &location_status_)));
          set_has_location_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_longitude;
        break;
      }

      // required uint32 longitude = 4;
      case 4: {
        if (tag == 32) {
         parse_longitude:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &longitude_)));
          set_has_longitude();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_latitude;
        break;
      }

      // required uint32 latitude = 5;
      case 5: {
        if (tag == 40) {
         parse_latitude:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &latitude_)));
          set_has_latitude();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_time_stamp;
        break;
      }

      // required uint32 time_stamp = 8;
      case 8: {
        if (tag == 64) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_isGPSconversion;
        break;
      }

      // optional uint32 isGPSconversion = 9;
      case 9: {
        if (tag == 72) {
         parse_isGPSconversion:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &isgpsconversion_)));
          set_has_isgpsconversion();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_gps_time;
        break;
      }

      // required uint64 gps_time = 10;
      case 10: {
        if (tag == 80) {
         parse_gps_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &gps_time_)));
          set_has_gps_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_height_valid;
        break;
      }

      // required uint32 height_valid = 11;
      case 11: {
        if (tag == 88) {
         parse_height_valid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &height_valid_)));
          set_has_height_valid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_height_data;
        break;
      }

      // required uint32 height_data = 12;
      case 12: {
        if (tag == 96) {
         parse_height_data:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &height_data_)));
          set_has_height_data();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.Location_Info)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.Location_Info)
  return false;
#undef DO_
}

void Location_Info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.Location_Info)
  // required bool Info_type = 1;
  if (has_info_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->info_type(), output);
  }

  // required uint32 location_status = 3;
  if (has_location_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->location_status(), output);
  }

  // required uint32 longitude = 4;
  if (has_longitude()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->longitude(), output);
  }

  // required uint32 latitude = 5;
  if (has_latitude()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->latitude(), output);
  }

  // required uint32 time_stamp = 8;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->time_stamp(), output);
  }

  // optional uint32 isGPSconversion = 9;
  if (has_isgpsconversion()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->isgpsconversion(), output);
  }

  // required uint64 gps_time = 10;
  if (has_gps_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(10, this->gps_time(), output);
  }

  // required uint32 height_valid = 11;
  if (has_height_valid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(11, this->height_valid(), output);
  }

  // required uint32 height_data = 12;
  if (has_height_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(12, this->height_data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.Location_Info)
}

::google::protobuf::uint8* Location_Info::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.Location_Info)
  // required bool Info_type = 1;
  if (has_info_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->info_type(), target);
  }

  // required uint32 location_status = 3;
  if (has_location_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->location_status(), target);
  }

  // required uint32 longitude = 4;
  if (has_longitude()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->longitude(), target);
  }

  // required uint32 latitude = 5;
  if (has_latitude()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->latitude(), target);
  }

  // required uint32 time_stamp = 8;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->time_stamp(), target);
  }

  // optional uint32 isGPSconversion = 9;
  if (has_isgpsconversion()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(9, this->isgpsconversion(), target);
  }

  // required uint64 gps_time = 10;
  if (has_gps_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(10, this->gps_time(), target);
  }

  // required uint32 height_valid = 11;
  if (has_height_valid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(11, this->height_valid(), target);
  }

  // required uint32 height_data = 12;
  if (has_height_data()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(12, this->height_data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.Location_Info)
  return target;
}

int Location_Info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool Info_type = 1;
    if (has_info_type()) {
      total_size += 1 + 1;
    }

    // required uint32 location_status = 3;
    if (has_location_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->location_status());
    }

    // required uint32 longitude = 4;
    if (has_longitude()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->longitude());
    }

    // required uint32 latitude = 5;
    if (has_latitude()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->latitude());
    }

    // required uint32 time_stamp = 8;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

    // optional uint32 isGPSconversion = 9;
    if (has_isgpsconversion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->isgpsconversion());
    }

    // required uint64 gps_time = 10;
    if (has_gps_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->gps_time());
    }

    // required uint32 height_valid = 11;
    if (has_height_valid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->height_valid());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required uint32 height_data = 12;
    if (has_height_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->height_data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Location_Info::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Location_Info* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Location_Info*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Location_Info::MergeFrom(const Location_Info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_info_type()) {
      set_info_type(from.info_type());
    }
    if (from.has_location_status()) {
      set_location_status(from.location_status());
    }
    if (from.has_longitude()) {
      set_longitude(from.longitude());
    }
    if (from.has_latitude()) {
      set_latitude(from.latitude());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_isgpsconversion()) {
      set_isgpsconversion(from.isgpsconversion());
    }
    if (from.has_gps_time()) {
      set_gps_time(from.gps_time());
    }
    if (from.has_height_valid()) {
      set_height_valid(from.height_valid());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_height_data()) {
      set_height_data(from.height_data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Location_Info::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Location_Info::CopyFrom(const Location_Info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Location_Info::IsInitialized() const {
  if ((_has_bits_[0] & 0x000001df) != 0x000001df) return false;

  return true;
}

void Location_Info::Swap(Location_Info* other) {
  if (other != this) {
    std::swap(info_type_, other->info_type_);
    std::swap(location_status_, other->location_status_);
    std::swap(longitude_, other->longitude_);
    std::swap(latitude_, other->latitude_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(isgpsconversion_, other->isgpsconversion_);
    std::swap(gps_time_, other->gps_time_);
    std::swap(height_valid_, other->height_valid_);
    std::swap(height_data_, other->height_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Location_Info::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Location_Info_descriptor_;
  metadata.reflection = Location_Info_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Location_InfoRsp::kErrcodeFieldNumber;
const int Location_InfoRsp::kTimeStampFieldNumber;
#endif  // !_MSC_VER

Location_InfoRsp::Location_InfoRsp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.Location_InfoRsp)
}

void Location_InfoRsp::InitAsDefaultInstance() {
}

Location_InfoRsp::Location_InfoRsp(const Location_InfoRsp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.Location_InfoRsp)
}

void Location_InfoRsp::SharedCtor() {
  _cached_size_ = 0;
  errcode_ = 0u;
  time_stamp_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Location_InfoRsp::~Location_InfoRsp() {
  // @@protoc_insertion_point(destructor:zna.protocol.Location_InfoRsp)
  SharedDtor();
}

void Location_InfoRsp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Location_InfoRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Location_InfoRsp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Location_InfoRsp_descriptor_;
}

const Location_InfoRsp& Location_InfoRsp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

Location_InfoRsp* Location_InfoRsp::default_instance_ = NULL;

Location_InfoRsp* Location_InfoRsp::New() const {
  return new Location_InfoRsp;
}

void Location_InfoRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Location_InfoRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(errcode_, time_stamp_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Location_InfoRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.Location_InfoRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 errcode = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &errcode_)));
          set_has_errcode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_time_stamp;
        break;
      }

      // required uint32 time_stamp = 2;
      case 2: {
        if (tag == 16) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.Location_InfoRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.Location_InfoRsp)
  return false;
#undef DO_
}

void Location_InfoRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.Location_InfoRsp)
  // required uint32 errcode = 1;
  if (has_errcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->errcode(), output);
  }

  // required uint32 time_stamp = 2;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->time_stamp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.Location_InfoRsp)
}

::google::protobuf::uint8* Location_InfoRsp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.Location_InfoRsp)
  // required uint32 errcode = 1;
  if (has_errcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->errcode(), target);
  }

  // required uint32 time_stamp = 2;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->time_stamp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.Location_InfoRsp)
  return target;
}

int Location_InfoRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 errcode = 1;
    if (has_errcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->errcode());
    }

    // required uint32 time_stamp = 2;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Location_InfoRsp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Location_InfoRsp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Location_InfoRsp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Location_InfoRsp::MergeFrom(const Location_InfoRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_errcode()) {
      set_errcode(from.errcode());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Location_InfoRsp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Location_InfoRsp::CopyFrom(const Location_InfoRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Location_InfoRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Location_InfoRsp::Swap(Location_InfoRsp* other) {
  if (other != this) {
    std::swap(errcode_, other->errcode_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Location_InfoRsp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Location_InfoRsp_descriptor_;
  metadata.reflection = Location_InfoRsp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RemoteControlResultRsp::kControlTypeFieldNumber;
const int RemoteControlResultRsp::kControlValueFieldNumber;
const int RemoteControlResultRsp::kSerialNumberFieldNumber;
const int RemoteControlResultRsp::kControlResultFieldNumber;
const int RemoteControlResultRsp::kTimeStampFieldNumber;
#endif  // !_MSC_VER

RemoteControlResultRsp::RemoteControlResultRsp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.RemoteControlResultRsp)
}

void RemoteControlResultRsp::InitAsDefaultInstance() {
}

RemoteControlResultRsp::RemoteControlResultRsp(const RemoteControlResultRsp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.RemoteControlResultRsp)
}

void RemoteControlResultRsp::SharedCtor() {
  _cached_size_ = 0;
  control_type_ = 0u;
  control_value_ = 0u;
  serial_number_ = 0u;
  control_result_ = 0u;
  time_stamp_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RemoteControlResultRsp::~RemoteControlResultRsp() {
  // @@protoc_insertion_point(destructor:zna.protocol.RemoteControlResultRsp)
  SharedDtor();
}

void RemoteControlResultRsp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RemoteControlResultRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RemoteControlResultRsp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RemoteControlResultRsp_descriptor_;
}

const RemoteControlResultRsp& RemoteControlResultRsp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

RemoteControlResultRsp* RemoteControlResultRsp::default_instance_ = NULL;

RemoteControlResultRsp* RemoteControlResultRsp::New() const {
  return new RemoteControlResultRsp;
}

void RemoteControlResultRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RemoteControlResultRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(control_type_, time_stamp_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RemoteControlResultRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.RemoteControlResultRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 control_type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &control_type_)));
          set_has_control_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_control_value;
        break;
      }

      // required uint32 control_value = 2;
      case 2: {
        if (tag == 16) {
         parse_control_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &control_value_)));
          set_has_control_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_serial_number;
        break;
      }

      // required uint32 serial_number = 3;
      case 3: {
        if (tag == 24) {
         parse_serial_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serial_number_)));
          set_has_serial_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_control_result;
        break;
      }

      // required uint32 control_result = 4;
      case 4: {
        if (tag == 32) {
         parse_control_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &control_result_)));
          set_has_control_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_time_stamp;
        break;
      }

      // required uint32 time_stamp = 5;
      case 5: {
        if (tag == 40) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.RemoteControlResultRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.RemoteControlResultRsp)
  return false;
#undef DO_
}

void RemoteControlResultRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.RemoteControlResultRsp)
  // required uint32 control_type = 1;
  if (has_control_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->control_type(), output);
  }

  // required uint32 control_value = 2;
  if (has_control_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->control_value(), output);
  }

  // required uint32 serial_number = 3;
  if (has_serial_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->serial_number(), output);
  }

  // required uint32 control_result = 4;
  if (has_control_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->control_result(), output);
  }

  // required uint32 time_stamp = 5;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->time_stamp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.RemoteControlResultRsp)
}

::google::protobuf::uint8* RemoteControlResultRsp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.RemoteControlResultRsp)
  // required uint32 control_type = 1;
  if (has_control_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->control_type(), target);
  }

  // required uint32 control_value = 2;
  if (has_control_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->control_value(), target);
  }

  // required uint32 serial_number = 3;
  if (has_serial_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->serial_number(), target);
  }

  // required uint32 control_result = 4;
  if (has_control_result()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->control_result(), target);
  }

  // required uint32 time_stamp = 5;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->time_stamp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.RemoteControlResultRsp)
  return target;
}

int RemoteControlResultRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 control_type = 1;
    if (has_control_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->control_type());
    }

    // required uint32 control_value = 2;
    if (has_control_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->control_value());
    }

    // required uint32 serial_number = 3;
    if (has_serial_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serial_number());
    }

    // required uint32 control_result = 4;
    if (has_control_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->control_result());
    }

    // required uint32 time_stamp = 5;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RemoteControlResultRsp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RemoteControlResultRsp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RemoteControlResultRsp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RemoteControlResultRsp::MergeFrom(const RemoteControlResultRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_control_type()) {
      set_control_type(from.control_type());
    }
    if (from.has_control_value()) {
      set_control_value(from.control_value());
    }
    if (from.has_serial_number()) {
      set_serial_number(from.serial_number());
    }
    if (from.has_control_result()) {
      set_control_result(from.control_result());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RemoteControlResultRsp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RemoteControlResultRsp::CopyFrom(const RemoteControlResultRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoteControlResultRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void RemoteControlResultRsp::Swap(RemoteControlResultRsp* other) {
  if (other != this) {
    std::swap(control_type_, other->control_type_);
    std::swap(control_value_, other->control_value_);
    std::swap(serial_number_, other->serial_number_);
    std::swap(control_result_, other->control_result_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RemoteControlResultRsp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RemoteControlResultRsp_descriptor_;
  metadata.reflection = RemoteControlResultRsp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RemoteControlReq::kControlTypeFieldNumber;
const int RemoteControlReq::kControlValueFieldNumber;
const int RemoteControlReq::kSerialNumberFieldNumber;
const int RemoteControlReq::kTimeStampFieldNumber;
const int RemoteControlReq::kSignalDataFieldNumber;
#endif  // !_MSC_VER

RemoteControlReq::RemoteControlReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.RemoteControlReq)
}

void RemoteControlReq::InitAsDefaultInstance() {
}

RemoteControlReq::RemoteControlReq(const RemoteControlReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.RemoteControlReq)
}

void RemoteControlReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  control_type_ = 0u;
  control_value_ = 0u;
  serial_number_ = 0u;
  time_stamp_ = 0u;
  signal_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RemoteControlReq::~RemoteControlReq() {
  // @@protoc_insertion_point(destructor:zna.protocol.RemoteControlReq)
  SharedDtor();
}

void RemoteControlReq::SharedDtor() {
  if (signal_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete signal_data_;
  }
  if (this != default_instance_) {
  }
}

void RemoteControlReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RemoteControlReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RemoteControlReq_descriptor_;
}

const RemoteControlReq& RemoteControlReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

RemoteControlReq* RemoteControlReq::default_instance_ = NULL;

RemoteControlReq* RemoteControlReq::New() const {
  return new RemoteControlReq;
}

void RemoteControlReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RemoteControlReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(control_type_, time_stamp_);
    if (has_signal_data()) {
      if (signal_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        signal_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RemoteControlReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.RemoteControlReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 control_type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &control_type_)));
          set_has_control_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_control_value;
        break;
      }

      // required uint32 control_value = 2;
      case 2: {
        if (tag == 16) {
         parse_control_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &control_value_)));
          set_has_control_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_serial_number;
        break;
      }

      // required uint32 serial_number = 3;
      case 3: {
        if (tag == 24) {
         parse_serial_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serial_number_)));
          set_has_serial_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_time_stamp;
        break;
      }

      // required uint32 time_stamp = 4;
      case 4: {
        if (tag == 32) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_signal_data;
        break;
      }

      // optional string signal_data = 5;
      case 5: {
        if (tag == 42) {
         parse_signal_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_signal_data()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->signal_data().data(), this->signal_data().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "signal_data");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.RemoteControlReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.RemoteControlReq)
  return false;
#undef DO_
}

void RemoteControlReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.RemoteControlReq)
  // required uint32 control_type = 1;
  if (has_control_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->control_type(), output);
  }

  // required uint32 control_value = 2;
  if (has_control_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->control_value(), output);
  }

  // required uint32 serial_number = 3;
  if (has_serial_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->serial_number(), output);
  }

  // required uint32 time_stamp = 4;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->time_stamp(), output);
  }

  // optional string signal_data = 5;
  if (has_signal_data()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->signal_data().data(), this->signal_data().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "signal_data");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->signal_data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.RemoteControlReq)
}

::google::protobuf::uint8* RemoteControlReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.RemoteControlReq)
  // required uint32 control_type = 1;
  if (has_control_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->control_type(), target);
  }

  // required uint32 control_value = 2;
  if (has_control_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->control_value(), target);
  }

  // required uint32 serial_number = 3;
  if (has_serial_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->serial_number(), target);
  }

  // required uint32 time_stamp = 4;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->time_stamp(), target);
  }

  // optional string signal_data = 5;
  if (has_signal_data()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->signal_data().data(), this->signal_data().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "signal_data");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->signal_data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.RemoteControlReq)
  return target;
}

int RemoteControlReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 control_type = 1;
    if (has_control_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->control_type());
    }

    // required uint32 control_value = 2;
    if (has_control_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->control_value());
    }

    // required uint32 serial_number = 3;
    if (has_serial_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serial_number());
    }

    // required uint32 time_stamp = 4;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

    // optional string signal_data = 5;
    if (has_signal_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->signal_data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RemoteControlReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RemoteControlReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RemoteControlReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RemoteControlReq::MergeFrom(const RemoteControlReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_control_type()) {
      set_control_type(from.control_type());
    }
    if (from.has_control_value()) {
      set_control_value(from.control_value());
    }
    if (from.has_serial_number()) {
      set_serial_number(from.serial_number());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_signal_data()) {
      set_signal_data(from.signal_data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RemoteControlReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RemoteControlReq::CopyFrom(const RemoteControlReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RemoteControlReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void RemoteControlReq::Swap(RemoteControlReq* other) {
  if (other != this) {
    std::swap(control_type_, other->control_type_);
    std::swap(control_value_, other->control_value_);
    std::swap(serial_number_, other->serial_number_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(signal_data_, other->signal_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RemoteControlReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RemoteControlReq_descriptor_;
  metadata.reflection = RemoteControlReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FlowCountRsp::kDataAllowanceFieldNumber;
const int FlowCountRsp::kDataUsageFieldNumber;
const int FlowCountRsp::kDataAvailableFieldNumber;
#endif  // !_MSC_VER

FlowCountRsp::FlowCountRsp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.FlowCountRsp)
}

void FlowCountRsp::InitAsDefaultInstance() {
}

FlowCountRsp::FlowCountRsp(const FlowCountRsp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.FlowCountRsp)
}

void FlowCountRsp::SharedCtor() {
  _cached_size_ = 0;
  dataallowance_ = 0u;
  datausage_ = 0u;
  dataavailable_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FlowCountRsp::~FlowCountRsp() {
  // @@protoc_insertion_point(destructor:zna.protocol.FlowCountRsp)
  SharedDtor();
}

void FlowCountRsp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FlowCountRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FlowCountRsp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FlowCountRsp_descriptor_;
}

const FlowCountRsp& FlowCountRsp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

FlowCountRsp* FlowCountRsp::default_instance_ = NULL;

FlowCountRsp* FlowCountRsp::New() const {
  return new FlowCountRsp;
}

void FlowCountRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<FlowCountRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(dataallowance_, dataavailable_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FlowCountRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.FlowCountRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 dataAllowance = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dataallowance_)));
          set_has_dataallowance();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_dataUsage;
        break;
      }

      // required uint32 dataUsage = 2;
      case 2: {
        if (tag == 16) {
         parse_dataUsage:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &datausage_)));
          set_has_datausage();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_dataAvailable;
        break;
      }

      // required uint32 dataAvailable = 3;
      case 3: {
        if (tag == 24) {
         parse_dataAvailable:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dataavailable_)));
          set_has_dataavailable();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.FlowCountRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.FlowCountRsp)
  return false;
#undef DO_
}

void FlowCountRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.FlowCountRsp)
  // required uint32 dataAllowance = 1;
  if (has_dataallowance()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->dataallowance(), output);
  }

  // required uint32 dataUsage = 2;
  if (has_datausage()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->datausage(), output);
  }

  // required uint32 dataAvailable = 3;
  if (has_dataavailable()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->dataavailable(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.FlowCountRsp)
}

::google::protobuf::uint8* FlowCountRsp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.FlowCountRsp)
  // required uint32 dataAllowance = 1;
  if (has_dataallowance()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->dataallowance(), target);
  }

  // required uint32 dataUsage = 2;
  if (has_datausage()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->datausage(), target);
  }

  // required uint32 dataAvailable = 3;
  if (has_dataavailable()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->dataavailable(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.FlowCountRsp)
  return target;
}

int FlowCountRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 dataAllowance = 1;
    if (has_dataallowance()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dataallowance());
    }

    // required uint32 dataUsage = 2;
    if (has_datausage()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->datausage());
    }

    // required uint32 dataAvailable = 3;
    if (has_dataavailable()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dataavailable());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FlowCountRsp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FlowCountRsp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FlowCountRsp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FlowCountRsp::MergeFrom(const FlowCountRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_dataallowance()) {
      set_dataallowance(from.dataallowance());
    }
    if (from.has_datausage()) {
      set_datausage(from.datausage());
    }
    if (from.has_dataavailable()) {
      set_dataavailable(from.dataavailable());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FlowCountRsp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FlowCountRsp::CopyFrom(const FlowCountRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlowCountRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void FlowCountRsp::Swap(FlowCountRsp* other) {
  if (other != this) {
    std::swap(dataallowance_, other->dataallowance_);
    std::swap(datausage_, other->datausage_);
    std::swap(dataavailable_, other->dataavailable_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FlowCountRsp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FlowCountRsp_descriptor_;
  metadata.reflection = FlowCountRsp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FlowCountLimitReq::kLimitValFieldNumber;
#endif  // !_MSC_VER

FlowCountLimitReq::FlowCountLimitReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.FlowCountLimitReq)
}

void FlowCountLimitReq::InitAsDefaultInstance() {
}

FlowCountLimitReq::FlowCountLimitReq(const FlowCountLimitReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.FlowCountLimitReq)
}

void FlowCountLimitReq::SharedCtor() {
  _cached_size_ = 0;
  limitval_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FlowCountLimitReq::~FlowCountLimitReq() {
  // @@protoc_insertion_point(destructor:zna.protocol.FlowCountLimitReq)
  SharedDtor();
}

void FlowCountLimitReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FlowCountLimitReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FlowCountLimitReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FlowCountLimitReq_descriptor_;
}

const FlowCountLimitReq& FlowCountLimitReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

FlowCountLimitReq* FlowCountLimitReq::default_instance_ = NULL;

FlowCountLimitReq* FlowCountLimitReq::New() const {
  return new FlowCountLimitReq;
}

void FlowCountLimitReq::Clear() {
  limitval_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FlowCountLimitReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.FlowCountLimitReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 limitVal = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &limitval_)));
          set_has_limitval();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.FlowCountLimitReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.FlowCountLimitReq)
  return false;
#undef DO_
}

void FlowCountLimitReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.FlowCountLimitReq)
  // required uint32 limitVal = 1;
  if (has_limitval()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->limitval(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.FlowCountLimitReq)
}

::google::protobuf::uint8* FlowCountLimitReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.FlowCountLimitReq)
  // required uint32 limitVal = 1;
  if (has_limitval()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->limitval(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.FlowCountLimitReq)
  return target;
}

int FlowCountLimitReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 limitVal = 1;
    if (has_limitval()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->limitval());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FlowCountLimitReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FlowCountLimitReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FlowCountLimitReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FlowCountLimitReq::MergeFrom(const FlowCountLimitReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_limitval()) {
      set_limitval(from.limitval());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FlowCountLimitReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FlowCountLimitReq::CopyFrom(const FlowCountLimitReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FlowCountLimitReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void FlowCountLimitReq::Swap(FlowCountLimitReq* other) {
  if (other != this) {
    std::swap(limitval_, other->limitval_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FlowCountLimitReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FlowCountLimitReq_descriptor_;
  metadata.reflection = FlowCountLimitReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int OtaUpgradeReq::kUpgradeinfoFieldNumber;
const int OtaUpgradeReq::kSerialNumberFieldNumber;
const int OtaUpgradeReq::kTimeStampFieldNumber;
#endif  // !_MSC_VER

OtaUpgradeReq::OtaUpgradeReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.OtaUpgradeReq)
}

void OtaUpgradeReq::InitAsDefaultInstance() {
}

OtaUpgradeReq::OtaUpgradeReq(const OtaUpgradeReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.OtaUpgradeReq)
}

void OtaUpgradeReq::SharedCtor() {
  _cached_size_ = 0;
  serial_number_ = 0u;
  time_stamp_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OtaUpgradeReq::~OtaUpgradeReq() {
  // @@protoc_insertion_point(destructor:zna.protocol.OtaUpgradeReq)
  SharedDtor();
}

void OtaUpgradeReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void OtaUpgradeReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OtaUpgradeReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OtaUpgradeReq_descriptor_;
}

const OtaUpgradeReq& OtaUpgradeReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

OtaUpgradeReq* OtaUpgradeReq::default_instance_ = NULL;

OtaUpgradeReq* OtaUpgradeReq::New() const {
  return new OtaUpgradeReq;
}

void OtaUpgradeReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<OtaUpgradeReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(serial_number_, time_stamp_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  upgradeinfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool OtaUpgradeReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.OtaUpgradeReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .zna.protocol.UpgradeInfo upgradeinfo = 1;
      case 1: {
        if (tag == 10) {
         parse_upgradeinfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_upgradeinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_upgradeinfo;
        if (input->ExpectTag(16)) goto parse_serial_number;
        break;
      }

      // required uint32 serial_number = 2;
      case 2: {
        if (tag == 16) {
         parse_serial_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serial_number_)));
          set_has_serial_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_time_stamp;
        break;
      }

      // required uint32 time_stamp = 3;
      case 3: {
        if (tag == 24) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.OtaUpgradeReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.OtaUpgradeReq)
  return false;
#undef DO_
}

void OtaUpgradeReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.OtaUpgradeReq)
  // repeated .zna.protocol.UpgradeInfo upgradeinfo = 1;
  for (int i = 0; i < this->upgradeinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->upgradeinfo(i), output);
  }

  // required uint32 serial_number = 2;
  if (has_serial_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->serial_number(), output);
  }

  // required uint32 time_stamp = 3;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->time_stamp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.OtaUpgradeReq)
}

::google::protobuf::uint8* OtaUpgradeReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.OtaUpgradeReq)
  // repeated .zna.protocol.UpgradeInfo upgradeinfo = 1;
  for (int i = 0; i < this->upgradeinfo_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->upgradeinfo(i), target);
  }

  // required uint32 serial_number = 2;
  if (has_serial_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->serial_number(), target);
  }

  // required uint32 time_stamp = 3;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->time_stamp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.OtaUpgradeReq)
  return target;
}

int OtaUpgradeReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required uint32 serial_number = 2;
    if (has_serial_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serial_number());
    }

    // required uint32 time_stamp = 3;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

  }
  // repeated .zna.protocol.UpgradeInfo upgradeinfo = 1;
  total_size += 1 * this->upgradeinfo_size();
  for (int i = 0; i < this->upgradeinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->upgradeinfo(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OtaUpgradeReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const OtaUpgradeReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const OtaUpgradeReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void OtaUpgradeReq::MergeFrom(const OtaUpgradeReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  upgradeinfo_.MergeFrom(from.upgradeinfo_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_serial_number()) {
      set_serial_number(from.serial_number());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void OtaUpgradeReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OtaUpgradeReq::CopyFrom(const OtaUpgradeReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OtaUpgradeReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->upgradeinfo())) return false;
  return true;
}

void OtaUpgradeReq::Swap(OtaUpgradeReq* other) {
  if (other != this) {
    upgradeinfo_.Swap(&other->upgradeinfo_);
    std::swap(serial_number_, other->serial_number_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata OtaUpgradeReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OtaUpgradeReq_descriptor_;
  metadata.reflection = OtaUpgradeReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int OtaUpgradeRsp::kErrcodeFieldNumber;
const int OtaUpgradeRsp::kTimeStampFieldNumber;
const int OtaUpgradeRsp::kSerialNumberFieldNumber;
#endif  // !_MSC_VER

OtaUpgradeRsp::OtaUpgradeRsp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.OtaUpgradeRsp)
}

void OtaUpgradeRsp::InitAsDefaultInstance() {
}

OtaUpgradeRsp::OtaUpgradeRsp(const OtaUpgradeRsp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.OtaUpgradeRsp)
}

void OtaUpgradeRsp::SharedCtor() {
  _cached_size_ = 0;
  errcode_ = 0u;
  time_stamp_ = 0u;
  serial_number_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OtaUpgradeRsp::~OtaUpgradeRsp() {
  // @@protoc_insertion_point(destructor:zna.protocol.OtaUpgradeRsp)
  SharedDtor();
}

void OtaUpgradeRsp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void OtaUpgradeRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OtaUpgradeRsp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OtaUpgradeRsp_descriptor_;
}

const OtaUpgradeRsp& OtaUpgradeRsp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

OtaUpgradeRsp* OtaUpgradeRsp::default_instance_ = NULL;

OtaUpgradeRsp* OtaUpgradeRsp::New() const {
  return new OtaUpgradeRsp;
}

void OtaUpgradeRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<OtaUpgradeRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(errcode_, serial_number_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool OtaUpgradeRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.OtaUpgradeRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 errcode = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &errcode_)));
          set_has_errcode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_time_stamp;
        break;
      }

      // required uint32 time_stamp = 2;
      case 2: {
        if (tag == 16) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_serial_number;
        break;
      }

      // required uint32 serial_number = 3;
      case 3: {
        if (tag == 24) {
         parse_serial_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serial_number_)));
          set_has_serial_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.OtaUpgradeRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.OtaUpgradeRsp)
  return false;
#undef DO_
}

void OtaUpgradeRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.OtaUpgradeRsp)
  // required uint32 errcode = 1;
  if (has_errcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->errcode(), output);
  }

  // required uint32 time_stamp = 2;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->time_stamp(), output);
  }

  // required uint32 serial_number = 3;
  if (has_serial_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->serial_number(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.OtaUpgradeRsp)
}

::google::protobuf::uint8* OtaUpgradeRsp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.OtaUpgradeRsp)
  // required uint32 errcode = 1;
  if (has_errcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->errcode(), target);
  }

  // required uint32 time_stamp = 2;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->time_stamp(), target);
  }

  // required uint32 serial_number = 3;
  if (has_serial_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->serial_number(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.OtaUpgradeRsp)
  return target;
}

int OtaUpgradeRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 errcode = 1;
    if (has_errcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->errcode());
    }

    // required uint32 time_stamp = 2;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

    // required uint32 serial_number = 3;
    if (has_serial_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serial_number());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OtaUpgradeRsp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const OtaUpgradeRsp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const OtaUpgradeRsp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void OtaUpgradeRsp::MergeFrom(const OtaUpgradeRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_errcode()) {
      set_errcode(from.errcode());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_serial_number()) {
      set_serial_number(from.serial_number());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void OtaUpgradeRsp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OtaUpgradeRsp::CopyFrom(const OtaUpgradeRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OtaUpgradeRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void OtaUpgradeRsp::Swap(OtaUpgradeRsp* other) {
  if (other != this) {
    std::swap(errcode_, other->errcode_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(serial_number_, other->serial_number_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata OtaUpgradeRsp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OtaUpgradeRsp_descriptor_;
  metadata.reflection = OtaUpgradeRsp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CancelOtaUpgradeRsp::kErrcodeFieldNumber;
#endif  // !_MSC_VER

CancelOtaUpgradeRsp::CancelOtaUpgradeRsp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.CancelOtaUpgradeRsp)
}

void CancelOtaUpgradeRsp::InitAsDefaultInstance() {
}

CancelOtaUpgradeRsp::CancelOtaUpgradeRsp(const CancelOtaUpgradeRsp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.CancelOtaUpgradeRsp)
}

void CancelOtaUpgradeRsp::SharedCtor() {
  _cached_size_ = 0;
  errcode_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CancelOtaUpgradeRsp::~CancelOtaUpgradeRsp() {
  // @@protoc_insertion_point(destructor:zna.protocol.CancelOtaUpgradeRsp)
  SharedDtor();
}

void CancelOtaUpgradeRsp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CancelOtaUpgradeRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CancelOtaUpgradeRsp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CancelOtaUpgradeRsp_descriptor_;
}

const CancelOtaUpgradeRsp& CancelOtaUpgradeRsp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

CancelOtaUpgradeRsp* CancelOtaUpgradeRsp::default_instance_ = NULL;

CancelOtaUpgradeRsp* CancelOtaUpgradeRsp::New() const {
  return new CancelOtaUpgradeRsp;
}

void CancelOtaUpgradeRsp::Clear() {
  errcode_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CancelOtaUpgradeRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.CancelOtaUpgradeRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 errcode = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &errcode_)));
          set_has_errcode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.CancelOtaUpgradeRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.CancelOtaUpgradeRsp)
  return false;
#undef DO_
}

void CancelOtaUpgradeRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.CancelOtaUpgradeRsp)
  // required uint32 errcode = 1;
  if (has_errcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->errcode(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.CancelOtaUpgradeRsp)
}

::google::protobuf::uint8* CancelOtaUpgradeRsp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.CancelOtaUpgradeRsp)
  // required uint32 errcode = 1;
  if (has_errcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->errcode(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.CancelOtaUpgradeRsp)
  return target;
}

int CancelOtaUpgradeRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 errcode = 1;
    if (has_errcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->errcode());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CancelOtaUpgradeRsp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CancelOtaUpgradeRsp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CancelOtaUpgradeRsp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CancelOtaUpgradeRsp::MergeFrom(const CancelOtaUpgradeRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_errcode()) {
      set_errcode(from.errcode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CancelOtaUpgradeRsp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CancelOtaUpgradeRsp::CopyFrom(const CancelOtaUpgradeRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CancelOtaUpgradeRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CancelOtaUpgradeRsp::Swap(CancelOtaUpgradeRsp* other) {
  if (other != this) {
    std::swap(errcode_, other->errcode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CancelOtaUpgradeRsp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CancelOtaUpgradeRsp_descriptor_;
  metadata.reflection = CancelOtaUpgradeRsp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int OtaUpgradeProgressReq::kUpgradeProgressCodeFieldNumber;
const int OtaUpgradeProgressReq::kErrcodeFieldNumber;
#endif  // !_MSC_VER

OtaUpgradeProgressReq::OtaUpgradeProgressReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.OtaUpgradeProgressReq)
}

void OtaUpgradeProgressReq::InitAsDefaultInstance() {
}

OtaUpgradeProgressReq::OtaUpgradeProgressReq(const OtaUpgradeProgressReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.OtaUpgradeProgressReq)
}

void OtaUpgradeProgressReq::SharedCtor() {
  _cached_size_ = 0;
  upgradeprogresscode_ = 0;
  errcode_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OtaUpgradeProgressReq::~OtaUpgradeProgressReq() {
  // @@protoc_insertion_point(destructor:zna.protocol.OtaUpgradeProgressReq)
  SharedDtor();
}

void OtaUpgradeProgressReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void OtaUpgradeProgressReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OtaUpgradeProgressReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OtaUpgradeProgressReq_descriptor_;
}

const OtaUpgradeProgressReq& OtaUpgradeProgressReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

OtaUpgradeProgressReq* OtaUpgradeProgressReq::default_instance_ = NULL;

OtaUpgradeProgressReq* OtaUpgradeProgressReq::New() const {
  return new OtaUpgradeProgressReq;
}

void OtaUpgradeProgressReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<OtaUpgradeProgressReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(upgradeprogresscode_, errcode_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool OtaUpgradeProgressReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.OtaUpgradeProgressReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .zna.protocol.UpgradeProgressCodeType UpgradeProgressCode = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::zna::protocol::UpgradeProgressCodeType_IsValid(value)) {
            set_upgradeprogresscode(static_cast< ::zna::protocol::UpgradeProgressCodeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_errcode;
        break;
      }

      // optional uint32 errcode = 2;
      case 2: {
        if (tag == 16) {
         parse_errcode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &errcode_)));
          set_has_errcode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.OtaUpgradeProgressReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.OtaUpgradeProgressReq)
  return false;
#undef DO_
}

void OtaUpgradeProgressReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.OtaUpgradeProgressReq)
  // required .zna.protocol.UpgradeProgressCodeType UpgradeProgressCode = 1;
  if (has_upgradeprogresscode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->upgradeprogresscode(), output);
  }

  // optional uint32 errcode = 2;
  if (has_errcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->errcode(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.OtaUpgradeProgressReq)
}

::google::protobuf::uint8* OtaUpgradeProgressReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.OtaUpgradeProgressReq)
  // required .zna.protocol.UpgradeProgressCodeType UpgradeProgressCode = 1;
  if (has_upgradeprogresscode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->upgradeprogresscode(), target);
  }

  // optional uint32 errcode = 2;
  if (has_errcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->errcode(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.OtaUpgradeProgressReq)
  return target;
}

int OtaUpgradeProgressReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .zna.protocol.UpgradeProgressCodeType UpgradeProgressCode = 1;
    if (has_upgradeprogresscode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->upgradeprogresscode());
    }

    // optional uint32 errcode = 2;
    if (has_errcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->errcode());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OtaUpgradeProgressReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const OtaUpgradeProgressReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const OtaUpgradeProgressReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void OtaUpgradeProgressReq::MergeFrom(const OtaUpgradeProgressReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_upgradeprogresscode()) {
      set_upgradeprogresscode(from.upgradeprogresscode());
    }
    if (from.has_errcode()) {
      set_errcode(from.errcode());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void OtaUpgradeProgressReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OtaUpgradeProgressReq::CopyFrom(const OtaUpgradeProgressReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OtaUpgradeProgressReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void OtaUpgradeProgressReq::Swap(OtaUpgradeProgressReq* other) {
  if (other != this) {
    std::swap(upgradeprogresscode_, other->upgradeprogresscode_);
    std::swap(errcode_, other->errcode_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata OtaUpgradeProgressReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OtaUpgradeProgressReq_descriptor_;
  metadata.reflection = OtaUpgradeProgressReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CertCom::kSerialNumberFieldNumber;
const int CertCom::kCurCertIdFieldNumber;
const int CertCom::kDataStatusFieldNumber;
const int CertCom::kCmdIdFieldNumber;
const int CertCom::kDcmNoFieldNumber;
const int CertCom::kErrcodeFieldNumber;
const int CertCom::kDataInfoFieldNumber;
const int CertCom::kSignDataFieldNumber;
#endif  // !_MSC_VER

CertCom::CertCom()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.CertCom)
}

void CertCom::InitAsDefaultInstance() {
}

CertCom::CertCom(const CertCom& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.CertCom)
}

void CertCom::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  serial_number_ = 0u;
  cur_cert_id_ = 0u;
  data_status_ = 0u;
  cmd_id_ = 0u;
  dcm_no_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  errcode_ = 0u;
  data_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sign_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CertCom::~CertCom() {
  // @@protoc_insertion_point(destructor:zna.protocol.CertCom)
  SharedDtor();
}

void CertCom::SharedDtor() {
  if (dcm_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dcm_no_;
  }
  if (data_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_info_;
  }
  if (sign_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sign_data_;
  }
  if (this != default_instance_) {
  }
}

void CertCom::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CertCom::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CertCom_descriptor_;
}

const CertCom& CertCom::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

CertCom* CertCom::default_instance_ = NULL;

CertCom* CertCom::New() const {
  return new CertCom;
}

void CertCom::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CertCom*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(serial_number_, cmd_id_);
    if (has_dcm_no()) {
      if (dcm_no_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        dcm_no_->clear();
      }
    }
    errcode_ = 0u;
    if (has_data_info()) {
      if (data_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_info_->clear();
      }
    }
    if (has_sign_data()) {
      if (sign_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        sign_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CertCom::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.CertCom)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 serial_number = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serial_number_)));
          set_has_serial_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_cur_cert_id;
        break;
      }

      // required uint32 cur_cert_id = 2;
      case 2: {
        if (tag == 16) {
         parse_cur_cert_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cur_cert_id_)));
          set_has_cur_cert_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_data_status;
        break;
      }

      // required uint32 data_status = 3;
      case 3: {
        if (tag == 24) {
         parse_data_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &data_status_)));
          set_has_data_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_cmd_id;
        break;
      }

      // required uint32 cmd_id = 4;
      case 4: {
        if (tag == 32) {
         parse_cmd_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cmd_id_)));
          set_has_cmd_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_dcm_no;
        break;
      }

      // required string dcm_no = 5;
      case 5: {
        if (tag == 42) {
         parse_dcm_no:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_dcm_no()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->dcm_no().data(), this->dcm_no().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "dcm_no");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_errcode;
        break;
      }

      // optional uint32 errcode = 6;
      case 6: {
        if (tag == 48) {
         parse_errcode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &errcode_)));
          set_has_errcode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_data_info;
        break;
      }

      // required bytes data_info = 7;
      case 7: {
        if (tag == 58) {
         parse_data_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_sign_data;
        break;
      }

      // optional bytes sign_data = 8;
      case 8: {
        if (tag == 66) {
         parse_sign_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_sign_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.CertCom)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.CertCom)
  return false;
#undef DO_
}

void CertCom::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.CertCom)
  // required uint32 serial_number = 1;
  if (has_serial_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->serial_number(), output);
  }

  // required uint32 cur_cert_id = 2;
  if (has_cur_cert_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->cur_cert_id(), output);
  }

  // required uint32 data_status = 3;
  if (has_data_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->data_status(), output);
  }

  // required uint32 cmd_id = 4;
  if (has_cmd_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->cmd_id(), output);
  }

  // required string dcm_no = 5;
  if (has_dcm_no()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->dcm_no().data(), this->dcm_no().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "dcm_no");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->dcm_no(), output);
  }

  // optional uint32 errcode = 6;
  if (has_errcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->errcode(), output);
  }

  // required bytes data_info = 7;
  if (has_data_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      7, this->data_info(), output);
  }

  // optional bytes sign_data = 8;
  if (has_sign_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      8, this->sign_data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.CertCom)
}

::google::protobuf::uint8* CertCom::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.CertCom)
  // required uint32 serial_number = 1;
  if (has_serial_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->serial_number(), target);
  }

  // required uint32 cur_cert_id = 2;
  if (has_cur_cert_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->cur_cert_id(), target);
  }

  // required uint32 data_status = 3;
  if (has_data_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->data_status(), target);
  }

  // required uint32 cmd_id = 4;
  if (has_cmd_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->cmd_id(), target);
  }

  // required string dcm_no = 5;
  if (has_dcm_no()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->dcm_no().data(), this->dcm_no().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "dcm_no");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->dcm_no(), target);
  }

  // optional uint32 errcode = 6;
  if (has_errcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->errcode(), target);
  }

  // required bytes data_info = 7;
  if (has_data_info()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        7, this->data_info(), target);
  }

  // optional bytes sign_data = 8;
  if (has_sign_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        8, this->sign_data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.CertCom)
  return target;
}

int CertCom::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 serial_number = 1;
    if (has_serial_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serial_number());
    }

    // required uint32 cur_cert_id = 2;
    if (has_cur_cert_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cur_cert_id());
    }

    // required uint32 data_status = 3;
    if (has_data_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->data_status());
    }

    // required uint32 cmd_id = 4;
    if (has_cmd_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cmd_id());
    }

    // required string dcm_no = 5;
    if (has_dcm_no()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->dcm_no());
    }

    // optional uint32 errcode = 6;
    if (has_errcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->errcode());
    }

    // required bytes data_info = 7;
    if (has_data_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data_info());
    }

    // optional bytes sign_data = 8;
    if (has_sign_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->sign_data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CertCom::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CertCom* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CertCom*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CertCom::MergeFrom(const CertCom& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serial_number()) {
      set_serial_number(from.serial_number());
    }
    if (from.has_cur_cert_id()) {
      set_cur_cert_id(from.cur_cert_id());
    }
    if (from.has_data_status()) {
      set_data_status(from.data_status());
    }
    if (from.has_cmd_id()) {
      set_cmd_id(from.cmd_id());
    }
    if (from.has_dcm_no()) {
      set_dcm_no(from.dcm_no());
    }
    if (from.has_errcode()) {
      set_errcode(from.errcode());
    }
    if (from.has_data_info()) {
      set_data_info(from.data_info());
    }
    if (from.has_sign_data()) {
      set_sign_data(from.sign_data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CertCom::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CertCom::CopyFrom(const CertCom& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertCom::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000005f) != 0x0000005f) return false;

  return true;
}

void CertCom::Swap(CertCom* other) {
  if (other != this) {
    std::swap(serial_number_, other->serial_number_);
    std::swap(cur_cert_id_, other->cur_cert_id_);
    std::swap(data_status_, other->data_status_);
    std::swap(cmd_id_, other->cmd_id_);
    std::swap(dcm_no_, other->dcm_no_);
    std::swap(errcode_, other->errcode_);
    std::swap(data_info_, other->data_info_);
    std::swap(sign_data_, other->sign_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CertCom::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CertCom_descriptor_;
  metadata.reflection = CertCom_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TCUCertApply_Req::kTimeStampFieldNumber;
const int TCUCertApply_Req::kVinFieldNumber;
const int TCUCertApply_Req::kCertStatusFieldNumber;
const int TCUCertApply_Req::kDurationFieldNumber;
const int TCUCertApply_Req::kP10CsrFieldNumber;
const int TCUCertApply_Req::kCstSignDataFieldNumber;
const int TCUCertApply_Req::kCertFormatFieldNumber;
const int TCUCertApply_Req::kSignTypeFieldNumber;
#endif  // !_MSC_VER

TCUCertApply_Req::TCUCertApply_Req()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.TCUCertApply_Req)
}

void TCUCertApply_Req::InitAsDefaultInstance() {
}

TCUCertApply_Req::TCUCertApply_Req(const TCUCertApply_Req& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.TCUCertApply_Req)
}

void TCUCertApply_Req::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  time_stamp_ = 0u;
  vin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  cert_status_ = 0u;
  duration_ = 0u;
  p10_csr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  cst_sign_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  cert_format_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  sign_type_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TCUCertApply_Req::~TCUCertApply_Req() {
  // @@protoc_insertion_point(destructor:zna.protocol.TCUCertApply_Req)
  SharedDtor();
}

void TCUCertApply_Req::SharedDtor() {
  if (vin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vin_;
  }
  if (p10_csr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete p10_csr_;
  }
  if (cst_sign_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cst_sign_data_;
  }
  if (cert_format_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cert_format_;
  }
  if (this != default_instance_) {
  }
}

void TCUCertApply_Req::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TCUCertApply_Req::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TCUCertApply_Req_descriptor_;
}

const TCUCertApply_Req& TCUCertApply_Req::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

TCUCertApply_Req* TCUCertApply_Req::default_instance_ = NULL;

TCUCertApply_Req* TCUCertApply_Req::New() const {
  return new TCUCertApply_Req;
}

void TCUCertApply_Req::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TCUCertApply_Req*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(time_stamp_, cert_status_);
    ZR_(duration_, sign_type_);
    if (has_vin()) {
      if (vin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        vin_->clear();
      }
    }
    if (has_p10_csr()) {
      if (p10_csr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        p10_csr_->clear();
      }
    }
    if (has_cst_sign_data()) {
      if (cst_sign_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        cst_sign_data_->clear();
      }
    }
    if (has_cert_format()) {
      if (cert_format_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        cert_format_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TCUCertApply_Req::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.TCUCertApply_Req)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 time_stamp = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_vin;
        break;
      }

      // required string vin = 2;
      case 2: {
        if (tag == 18) {
         parse_vin:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vin()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->vin().data(), this->vin().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "vin");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_cert_status;
        break;
      }

      // required uint32 cert_status = 3;
      case 3: {
        if (tag == 24) {
         parse_cert_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cert_status_)));
          set_has_cert_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_duration;
        break;
      }

      // required uint32 duration = 4;
      case 4: {
        if (tag == 32) {
         parse_duration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &duration_)));
          set_has_duration();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_p10_csr;
        break;
      }

      // required bytes p10_csr = 5;
      case 5: {
        if (tag == 42) {
         parse_p10_csr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_p10_csr()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_cst_sign_data;
        break;
      }

      // optional bytes cst_sign_data = 6;
      case 6: {
        if (tag == 50) {
         parse_cst_sign_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_cst_sign_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_cert_format;
        break;
      }

      // optional string cert_format = 7;
      case 7: {
        if (tag == 58) {
         parse_cert_format:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_cert_format()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->cert_format().data(), this->cert_format().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "cert_format");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_sign_type;
        break;
      }

      // optional uint32 sign_type = 8;
      case 8: {
        if (tag == 64) {
         parse_sign_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sign_type_)));
          set_has_sign_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.TCUCertApply_Req)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.TCUCertApply_Req)
  return false;
#undef DO_
}

void TCUCertApply_Req::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.TCUCertApply_Req)
  // required uint32 time_stamp = 1;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->time_stamp(), output);
  }

  // required string vin = 2;
  if (has_vin()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->vin().data(), this->vin().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "vin");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->vin(), output);
  }

  // required uint32 cert_status = 3;
  if (has_cert_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->cert_status(), output);
  }

  // required uint32 duration = 4;
  if (has_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->duration(), output);
  }

  // required bytes p10_csr = 5;
  if (has_p10_csr()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->p10_csr(), output);
  }

  // optional bytes cst_sign_data = 6;
  if (has_cst_sign_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->cst_sign_data(), output);
  }

  // optional string cert_format = 7;
  if (has_cert_format()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->cert_format().data(), this->cert_format().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "cert_format");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->cert_format(), output);
  }

  // optional uint32 sign_type = 8;
  if (has_sign_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->sign_type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.TCUCertApply_Req)
}

::google::protobuf::uint8* TCUCertApply_Req::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.TCUCertApply_Req)
  // required uint32 time_stamp = 1;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->time_stamp(), target);
  }

  // required string vin = 2;
  if (has_vin()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->vin().data(), this->vin().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "vin");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->vin(), target);
  }

  // required uint32 cert_status = 3;
  if (has_cert_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->cert_status(), target);
  }

  // required uint32 duration = 4;
  if (has_duration()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->duration(), target);
  }

  // required bytes p10_csr = 5;
  if (has_p10_csr()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->p10_csr(), target);
  }

  // optional bytes cst_sign_data = 6;
  if (has_cst_sign_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->cst_sign_data(), target);
  }

  // optional string cert_format = 7;
  if (has_cert_format()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->cert_format().data(), this->cert_format().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "cert_format");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->cert_format(), target);
  }

  // optional uint32 sign_type = 8;
  if (has_sign_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->sign_type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.TCUCertApply_Req)
  return target;
}

int TCUCertApply_Req::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 time_stamp = 1;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

    // required string vin = 2;
    if (has_vin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->vin());
    }

    // required uint32 cert_status = 3;
    if (has_cert_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cert_status());
    }

    // required uint32 duration = 4;
    if (has_duration()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->duration());
    }

    // required bytes p10_csr = 5;
    if (has_p10_csr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->p10_csr());
    }

    // optional bytes cst_sign_data = 6;
    if (has_cst_sign_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->cst_sign_data());
    }

    // optional string cert_format = 7;
    if (has_cert_format()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->cert_format());
    }

    // optional uint32 sign_type = 8;
    if (has_sign_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sign_type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TCUCertApply_Req::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TCUCertApply_Req* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TCUCertApply_Req*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TCUCertApply_Req::MergeFrom(const TCUCertApply_Req& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_vin()) {
      set_vin(from.vin());
    }
    if (from.has_cert_status()) {
      set_cert_status(from.cert_status());
    }
    if (from.has_duration()) {
      set_duration(from.duration());
    }
    if (from.has_p10_csr()) {
      set_p10_csr(from.p10_csr());
    }
    if (from.has_cst_sign_data()) {
      set_cst_sign_data(from.cst_sign_data());
    }
    if (from.has_cert_format()) {
      set_cert_format(from.cert_format());
    }
    if (from.has_sign_type()) {
      set_sign_type(from.sign_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TCUCertApply_Req::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TCUCertApply_Req::CopyFrom(const TCUCertApply_Req& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TCUCertApply_Req::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;

  return true;
}

void TCUCertApply_Req::Swap(TCUCertApply_Req* other) {
  if (other != this) {
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(vin_, other->vin_);
    std::swap(cert_status_, other->cert_status_);
    std::swap(duration_, other->duration_);
    std::swap(p10_csr_, other->p10_csr_);
    std::swap(cst_sign_data_, other->cst_sign_data_);
    std::swap(cert_format_, other->cert_format_);
    std::swap(sign_type_, other->sign_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TCUCertApply_Req::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TCUCertApply_Req_descriptor_;
  metadata.reflection = TCUCertApply_Req_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TCUCertApply_Rsp::kTimeStampFieldNumber;
const int TCUCertApply_Rsp::kRecvStatusFieldNumber;
#endif  // !_MSC_VER

TCUCertApply_Rsp::TCUCertApply_Rsp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.TCUCertApply_Rsp)
}

void TCUCertApply_Rsp::InitAsDefaultInstance() {
}

TCUCertApply_Rsp::TCUCertApply_Rsp(const TCUCertApply_Rsp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.TCUCertApply_Rsp)
}

void TCUCertApply_Rsp::SharedCtor() {
  _cached_size_ = 0;
  time_stamp_ = 0u;
  recv_status_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TCUCertApply_Rsp::~TCUCertApply_Rsp() {
  // @@protoc_insertion_point(destructor:zna.protocol.TCUCertApply_Rsp)
  SharedDtor();
}

void TCUCertApply_Rsp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TCUCertApply_Rsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TCUCertApply_Rsp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TCUCertApply_Rsp_descriptor_;
}

const TCUCertApply_Rsp& TCUCertApply_Rsp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

TCUCertApply_Rsp* TCUCertApply_Rsp::default_instance_ = NULL;

TCUCertApply_Rsp* TCUCertApply_Rsp::New() const {
  return new TCUCertApply_Rsp;
}

void TCUCertApply_Rsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TCUCertApply_Rsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(time_stamp_, recv_status_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TCUCertApply_Rsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.TCUCertApply_Rsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 time_stamp = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_recv_status;
        break;
      }

      // optional uint32 recv_status = 2;
      case 2: {
        if (tag == 16) {
         parse_recv_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &recv_status_)));
          set_has_recv_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.TCUCertApply_Rsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.TCUCertApply_Rsp)
  return false;
#undef DO_
}

void TCUCertApply_Rsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.TCUCertApply_Rsp)
  // required uint32 time_stamp = 1;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->time_stamp(), output);
  }

  // optional uint32 recv_status = 2;
  if (has_recv_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->recv_status(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.TCUCertApply_Rsp)
}

::google::protobuf::uint8* TCUCertApply_Rsp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.TCUCertApply_Rsp)
  // required uint32 time_stamp = 1;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->time_stamp(), target);
  }

  // optional uint32 recv_status = 2;
  if (has_recv_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->recv_status(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.TCUCertApply_Rsp)
  return target;
}

int TCUCertApply_Rsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 time_stamp = 1;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

    // optional uint32 recv_status = 2;
    if (has_recv_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->recv_status());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TCUCertApply_Rsp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TCUCertApply_Rsp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TCUCertApply_Rsp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TCUCertApply_Rsp::MergeFrom(const TCUCertApply_Rsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_recv_status()) {
      set_recv_status(from.recv_status());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TCUCertApply_Rsp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TCUCertApply_Rsp::CopyFrom(const TCUCertApply_Rsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TCUCertApply_Rsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void TCUCertApply_Rsp::Swap(TCUCertApply_Rsp* other) {
  if (other != this) {
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(recv_status_, other->recv_status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TCUCertApply_Rsp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TCUCertApply_Rsp_descriptor_;
  metadata.reflection = TCUCertApply_Rsp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CertIssue_Req::kTimeStampFieldNumber;
const int CertIssue_Req::kCertApplyStatusFieldNumber;
const int CertIssue_Req::kApplyCertIdFieldNumber;
const int CertIssue_Req::kCertDataFieldNumber;
#endif  // !_MSC_VER

CertIssue_Req::CertIssue_Req()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.CertIssue_Req)
}

void CertIssue_Req::InitAsDefaultInstance() {
}

CertIssue_Req::CertIssue_Req(const CertIssue_Req& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.CertIssue_Req)
}

void CertIssue_Req::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  time_stamp_ = 0u;
  cert_apply_status_ = 0u;
  apply_cert_id_ = 0u;
  cert_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CertIssue_Req::~CertIssue_Req() {
  // @@protoc_insertion_point(destructor:zna.protocol.CertIssue_Req)
  SharedDtor();
}

void CertIssue_Req::SharedDtor() {
  if (cert_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete cert_data_;
  }
  if (this != default_instance_) {
  }
}

void CertIssue_Req::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CertIssue_Req::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CertIssue_Req_descriptor_;
}

const CertIssue_Req& CertIssue_Req::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

CertIssue_Req* CertIssue_Req::default_instance_ = NULL;

CertIssue_Req* CertIssue_Req::New() const {
  return new CertIssue_Req;
}

void CertIssue_Req::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CertIssue_Req*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(time_stamp_, cert_apply_status_);
    apply_cert_id_ = 0u;
    if (has_cert_data()) {
      if (cert_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        cert_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CertIssue_Req::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.CertIssue_Req)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 time_stamp = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_cert_apply_status;
        break;
      }

      // required uint32 cert_apply_status = 2;
      case 2: {
        if (tag == 16) {
         parse_cert_apply_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cert_apply_status_)));
          set_has_cert_apply_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_apply_cert_id;
        break;
      }

      // optional uint32 apply_cert_id = 3;
      case 3: {
        if (tag == 24) {
         parse_apply_cert_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &apply_cert_id_)));
          set_has_apply_cert_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_cert_data;
        break;
      }

      // optional bytes cert_data = 4;
      case 4: {
        if (tag == 34) {
         parse_cert_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_cert_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.CertIssue_Req)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.CertIssue_Req)
  return false;
#undef DO_
}

void CertIssue_Req::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.CertIssue_Req)
  // required uint32 time_stamp = 1;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->time_stamp(), output);
  }

  // required uint32 cert_apply_status = 2;
  if (has_cert_apply_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->cert_apply_status(), output);
  }

  // optional uint32 apply_cert_id = 3;
  if (has_apply_cert_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->apply_cert_id(), output);
  }

  // optional bytes cert_data = 4;
  if (has_cert_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->cert_data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.CertIssue_Req)
}

::google::protobuf::uint8* CertIssue_Req::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.CertIssue_Req)
  // required uint32 time_stamp = 1;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->time_stamp(), target);
  }

  // required uint32 cert_apply_status = 2;
  if (has_cert_apply_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->cert_apply_status(), target);
  }

  // optional uint32 apply_cert_id = 3;
  if (has_apply_cert_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->apply_cert_id(), target);
  }

  // optional bytes cert_data = 4;
  if (has_cert_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->cert_data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.CertIssue_Req)
  return target;
}

int CertIssue_Req::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 time_stamp = 1;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

    // required uint32 cert_apply_status = 2;
    if (has_cert_apply_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cert_apply_status());
    }

    // optional uint32 apply_cert_id = 3;
    if (has_apply_cert_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->apply_cert_id());
    }

    // optional bytes cert_data = 4;
    if (has_cert_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->cert_data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CertIssue_Req::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CertIssue_Req* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CertIssue_Req*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CertIssue_Req::MergeFrom(const CertIssue_Req& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_cert_apply_status()) {
      set_cert_apply_status(from.cert_apply_status());
    }
    if (from.has_apply_cert_id()) {
      set_apply_cert_id(from.apply_cert_id());
    }
    if (from.has_cert_data()) {
      set_cert_data(from.cert_data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CertIssue_Req::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CertIssue_Req::CopyFrom(const CertIssue_Req& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertIssue_Req::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CertIssue_Req::Swap(CertIssue_Req* other) {
  if (other != this) {
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(cert_apply_status_, other->cert_apply_status_);
    std::swap(apply_cert_id_, other->apply_cert_id_);
    std::swap(cert_data_, other->cert_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CertIssue_Req::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CertIssue_Req_descriptor_;
  metadata.reflection = CertIssue_Req_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CertIssue_Rsp::kTimeStampFieldNumber;
const int CertIssue_Rsp::kCertRecvStatusFieldNumber;
const int CertIssue_Rsp::kApplyCertIdFieldNumber;
#endif  // !_MSC_VER

CertIssue_Rsp::CertIssue_Rsp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.CertIssue_Rsp)
}

void CertIssue_Rsp::InitAsDefaultInstance() {
}

CertIssue_Rsp::CertIssue_Rsp(const CertIssue_Rsp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.CertIssue_Rsp)
}

void CertIssue_Rsp::SharedCtor() {
  _cached_size_ = 0;
  time_stamp_ = 0u;
  cert_recv_status_ = 0u;
  apply_cert_id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CertIssue_Rsp::~CertIssue_Rsp() {
  // @@protoc_insertion_point(destructor:zna.protocol.CertIssue_Rsp)
  SharedDtor();
}

void CertIssue_Rsp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CertIssue_Rsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CertIssue_Rsp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CertIssue_Rsp_descriptor_;
}

const CertIssue_Rsp& CertIssue_Rsp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

CertIssue_Rsp* CertIssue_Rsp::default_instance_ = NULL;

CertIssue_Rsp* CertIssue_Rsp::New() const {
  return new CertIssue_Rsp;
}

void CertIssue_Rsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<CertIssue_Rsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(time_stamp_, apply_cert_id_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CertIssue_Rsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.CertIssue_Rsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 time_stamp = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_cert_recv_status;
        break;
      }

      // required uint32 cert_recv_status = 2;
      case 2: {
        if (tag == 16) {
         parse_cert_recv_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cert_recv_status_)));
          set_has_cert_recv_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_apply_cert_id;
        break;
      }

      // optional uint32 apply_cert_id = 3;
      case 3: {
        if (tag == 24) {
         parse_apply_cert_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &apply_cert_id_)));
          set_has_apply_cert_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.CertIssue_Rsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.CertIssue_Rsp)
  return false;
#undef DO_
}

void CertIssue_Rsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.CertIssue_Rsp)
  // required uint32 time_stamp = 1;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->time_stamp(), output);
  }

  // required uint32 cert_recv_status = 2;
  if (has_cert_recv_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->cert_recv_status(), output);
  }

  // optional uint32 apply_cert_id = 3;
  if (has_apply_cert_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->apply_cert_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.CertIssue_Rsp)
}

::google::protobuf::uint8* CertIssue_Rsp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.CertIssue_Rsp)
  // required uint32 time_stamp = 1;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->time_stamp(), target);
  }

  // required uint32 cert_recv_status = 2;
  if (has_cert_recv_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->cert_recv_status(), target);
  }

  // optional uint32 apply_cert_id = 3;
  if (has_apply_cert_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->apply_cert_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.CertIssue_Rsp)
  return target;
}

int CertIssue_Rsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 time_stamp = 1;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

    // required uint32 cert_recv_status = 2;
    if (has_cert_recv_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cert_recv_status());
    }

    // optional uint32 apply_cert_id = 3;
    if (has_apply_cert_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->apply_cert_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CertIssue_Rsp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CertIssue_Rsp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CertIssue_Rsp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CertIssue_Rsp::MergeFrom(const CertIssue_Rsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_cert_recv_status()) {
      set_cert_recv_status(from.cert_recv_status());
    }
    if (from.has_apply_cert_id()) {
      set_apply_cert_id(from.apply_cert_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CertIssue_Rsp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CertIssue_Rsp::CopyFrom(const CertIssue_Rsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertIssue_Rsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void CertIssue_Rsp::Swap(CertIssue_Rsp* other) {
  if (other != this) {
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(cert_recv_status_, other->cert_recv_status_);
    std::swap(apply_cert_id_, other->apply_cert_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CertIssue_Rsp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CertIssue_Rsp_descriptor_;
  metadata.reflection = CertIssue_Rsp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RSALoginReq::kTcuDeviceSnFieldNumber;
const int RSALoginReq::kImsiFieldNumber;
const int RSALoginReq::kImeiFieldNumber;
const int RSALoginReq::kSoftwareVersionFieldNumber;
const int RSALoginReq::kHardwareVersionFieldNumber;
const int RSALoginReq::kTimeStampFieldNumber;
const int RSALoginReq::kG4VersionFieldNumber;
const int RSALoginReq::kVehicleTypeFieldNumber;
#endif  // !_MSC_VER

RSALoginReq::RSALoginReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.RSALoginReq)
}

void RSALoginReq::InitAsDefaultInstance() {
}

RSALoginReq::RSALoginReq(const RSALoginReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.RSALoginReq)
}

void RSALoginReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  tcu_device_sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  imsi_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  software_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hardware_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  time_stamp_ = 0u;
  g4_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  vehicle_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RSALoginReq::~RSALoginReq() {
  // @@protoc_insertion_point(destructor:zna.protocol.RSALoginReq)
  SharedDtor();
}

void RSALoginReq::SharedDtor() {
  if (tcu_device_sn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tcu_device_sn_;
  }
  if (imsi_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imsi_;
  }
  if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete imei_;
  }
  if (software_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete software_version_;
  }
  if (hardware_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hardware_version_;
  }
  if (g4_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete g4_version_;
  }
  if (vehicle_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vehicle_type_;
  }
  if (this != default_instance_) {
  }
}

void RSALoginReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RSALoginReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RSALoginReq_descriptor_;
}

const RSALoginReq& RSALoginReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

RSALoginReq* RSALoginReq::default_instance_ = NULL;

RSALoginReq* RSALoginReq::New() const {
  return new RSALoginReq;
}

void RSALoginReq::Clear() {
  if (_has_bits_[0 / 32] & 255) {
    if (has_tcu_device_sn()) {
      if (tcu_device_sn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        tcu_device_sn_->clear();
      }
    }
    if (has_imsi()) {
      if (imsi_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        imsi_->clear();
      }
    }
    if (has_imei()) {
      if (imei_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        imei_->clear();
      }
    }
    if (has_software_version()) {
      if (software_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        software_version_->clear();
      }
    }
    if (has_hardware_version()) {
      if (hardware_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        hardware_version_->clear();
      }
    }
    time_stamp_ = 0u;
    if (has_g4_version()) {
      if (g4_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        g4_version_->clear();
      }
    }
    if (has_vehicle_type()) {
      if (vehicle_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        vehicle_type_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RSALoginReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.RSALoginReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string tcu_device_sn = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_tcu_device_sn()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->tcu_device_sn().data(), this->tcu_device_sn().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "tcu_device_sn");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_imsi;
        break;
      }

      // required string imsi = 2;
      case 2: {
        if (tag == 18) {
         parse_imsi:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_imsi()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->imsi().data(), this->imsi().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "imsi");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_imei;
        break;
      }

      // required string imei = 3;
      case 3: {
        if (tag == 26) {
         parse_imei:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_imei()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->imei().data(), this->imei().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "imei");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_software_version;
        break;
      }

      // required string software_version = 4;
      case 4: {
        if (tag == 34) {
         parse_software_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_software_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->software_version().data(), this->software_version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "software_version");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_hardware_version;
        break;
      }

      // required string hardware_version = 5;
      case 5: {
        if (tag == 42) {
         parse_hardware_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hardware_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->hardware_version().data(), this->hardware_version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "hardware_version");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_time_stamp;
        break;
      }

      // required uint32 time_stamp = 6;
      case 6: {
        if (tag == 48) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_g4_version;
        break;
      }

      // optional string g4_version = 7;
      case 7: {
        if (tag == 58) {
         parse_g4_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_g4_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->g4_version().data(), this->g4_version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "g4_version");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_vehicle_type;
        break;
      }

      // optional string vehicle_type = 8;
      case 8: {
        if (tag == 66) {
         parse_vehicle_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vehicle_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->vehicle_type().data(), this->vehicle_type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "vehicle_type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.RSALoginReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.RSALoginReq)
  return false;
#undef DO_
}

void RSALoginReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.RSALoginReq)
  // required string tcu_device_sn = 1;
  if (has_tcu_device_sn()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->tcu_device_sn().data(), this->tcu_device_sn().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "tcu_device_sn");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->tcu_device_sn(), output);
  }

  // required string imsi = 2;
  if (has_imsi()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->imsi().data(), this->imsi().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "imsi");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->imsi(), output);
  }

  // required string imei = 3;
  if (has_imei()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->imei().data(), this->imei().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "imei");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->imei(), output);
  }

  // required string software_version = 4;
  if (has_software_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->software_version().data(), this->software_version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "software_version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->software_version(), output);
  }

  // required string hardware_version = 5;
  if (has_hardware_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hardware_version().data(), this->hardware_version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hardware_version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->hardware_version(), output);
  }

  // required uint32 time_stamp = 6;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->time_stamp(), output);
  }

  // optional string g4_version = 7;
  if (has_g4_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->g4_version().data(), this->g4_version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "g4_version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->g4_version(), output);
  }

  // optional string vehicle_type = 8;
  if (has_vehicle_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->vehicle_type().data(), this->vehicle_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "vehicle_type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      8, this->vehicle_type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.RSALoginReq)
}

::google::protobuf::uint8* RSALoginReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.RSALoginReq)
  // required string tcu_device_sn = 1;
  if (has_tcu_device_sn()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->tcu_device_sn().data(), this->tcu_device_sn().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "tcu_device_sn");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->tcu_device_sn(), target);
  }

  // required string imsi = 2;
  if (has_imsi()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->imsi().data(), this->imsi().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "imsi");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->imsi(), target);
  }

  // required string imei = 3;
  if (has_imei()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->imei().data(), this->imei().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "imei");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->imei(), target);
  }

  // required string software_version = 4;
  if (has_software_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->software_version().data(), this->software_version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "software_version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->software_version(), target);
  }

  // required string hardware_version = 5;
  if (has_hardware_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hardware_version().data(), this->hardware_version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "hardware_version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->hardware_version(), target);
  }

  // required uint32 time_stamp = 6;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(6, this->time_stamp(), target);
  }

  // optional string g4_version = 7;
  if (has_g4_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->g4_version().data(), this->g4_version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "g4_version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->g4_version(), target);
  }

  // optional string vehicle_type = 8;
  if (has_vehicle_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->vehicle_type().data(), this->vehicle_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "vehicle_type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        8, this->vehicle_type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.RSALoginReq)
  return target;
}

int RSALoginReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string tcu_device_sn = 1;
    if (has_tcu_device_sn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->tcu_device_sn());
    }

    // required string imsi = 2;
    if (has_imsi()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->imsi());
    }

    // required string imei = 3;
    if (has_imei()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->imei());
    }

    // required string software_version = 4;
    if (has_software_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->software_version());
    }

    // required string hardware_version = 5;
    if (has_hardware_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hardware_version());
    }

    // required uint32 time_stamp = 6;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

    // optional string g4_version = 7;
    if (has_g4_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->g4_version());
    }

    // optional string vehicle_type = 8;
    if (has_vehicle_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->vehicle_type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RSALoginReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RSALoginReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RSALoginReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RSALoginReq::MergeFrom(const RSALoginReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tcu_device_sn()) {
      set_tcu_device_sn(from.tcu_device_sn());
    }
    if (from.has_imsi()) {
      set_imsi(from.imsi());
    }
    if (from.has_imei()) {
      set_imei(from.imei());
    }
    if (from.has_software_version()) {
      set_software_version(from.software_version());
    }
    if (from.has_hardware_version()) {
      set_hardware_version(from.hardware_version());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_g4_version()) {
      set_g4_version(from.g4_version());
    }
    if (from.has_vehicle_type()) {
      set_vehicle_type(from.vehicle_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RSALoginReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RSALoginReq::CopyFrom(const RSALoginReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RSALoginReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void RSALoginReq::Swap(RSALoginReq* other) {
  if (other != this) {
    std::swap(tcu_device_sn_, other->tcu_device_sn_);
    std::swap(imsi_, other->imsi_);
    std::swap(imei_, other->imei_);
    std::swap(software_version_, other->software_version_);
    std::swap(hardware_version_, other->hardware_version_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(g4_version_, other->g4_version_);
    std::swap(vehicle_type_, other->vehicle_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RSALoginReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RSALoginReq_descriptor_;
  metadata.reflection = RSALoginReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SendRSARsp::kErrcodeFieldNumber;
const int SendRSARsp::kNLenFieldNumber;
const int SendRSARsp::kNStringFieldNumber;
const int SendRSARsp::kE1LenFieldNumber;
const int SendRSARsp::kE1StringFieldNumber;
#endif  // !_MSC_VER

SendRSARsp::SendRSARsp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.SendRSARsp)
}

void SendRSARsp::InitAsDefaultInstance() {
}

SendRSARsp::SendRSARsp(const SendRSARsp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.SendRSARsp)
}

void SendRSARsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  errcode_ = 0u;
  n_len_ = 0u;
  n_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  e1_len_ = 0u;
  e1_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SendRSARsp::~SendRSARsp() {
  // @@protoc_insertion_point(destructor:zna.protocol.SendRSARsp)
  SharedDtor();
}

void SendRSARsp::SharedDtor() {
  if (n_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete n_string_;
  }
  if (e1_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete e1_string_;
  }
  if (this != default_instance_) {
  }
}

void SendRSARsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SendRSARsp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SendRSARsp_descriptor_;
}

const SendRSARsp& SendRSARsp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

SendRSARsp* SendRSARsp::default_instance_ = NULL;

SendRSARsp* SendRSARsp::New() const {
  return new SendRSARsp;
}

void SendRSARsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SendRSARsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(errcode_, n_len_);
    if (has_n_string()) {
      if (n_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        n_string_->clear();
      }
    }
    e1_len_ = 0u;
    if (has_e1_string()) {
      if (e1_string_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        e1_string_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SendRSARsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.SendRSARsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 errcode = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &errcode_)));
          set_has_errcode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_N_len;
        break;
      }

      // optional uint32 N_len = 2;
      case 2: {
        if (tag == 16) {
         parse_N_len:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &n_len_)));
          set_has_n_len();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_N_string;
        break;
      }

      // optional bytes N_string = 3;
      case 3: {
        if (tag == 26) {
         parse_N_string:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_n_string()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_E1_len;
        break;
      }

      // optional uint32 E1_len = 4;
      case 4: {
        if (tag == 32) {
         parse_E1_len:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &e1_len_)));
          set_has_e1_len();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_E1_string;
        break;
      }

      // optional bytes E1_string = 5;
      case 5: {
        if (tag == 42) {
         parse_E1_string:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_e1_string()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.SendRSARsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.SendRSARsp)
  return false;
#undef DO_
}

void SendRSARsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.SendRSARsp)
  // required uint32 errcode = 1;
  if (has_errcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->errcode(), output);
  }

  // optional uint32 N_len = 2;
  if (has_n_len()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->n_len(), output);
  }

  // optional bytes N_string = 3;
  if (has_n_string()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->n_string(), output);
  }

  // optional uint32 E1_len = 4;
  if (has_e1_len()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->e1_len(), output);
  }

  // optional bytes E1_string = 5;
  if (has_e1_string()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->e1_string(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.SendRSARsp)
}

::google::protobuf::uint8* SendRSARsp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.SendRSARsp)
  // required uint32 errcode = 1;
  if (has_errcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->errcode(), target);
  }

  // optional uint32 N_len = 2;
  if (has_n_len()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->n_len(), target);
  }

  // optional bytes N_string = 3;
  if (has_n_string()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->n_string(), target);
  }

  // optional uint32 E1_len = 4;
  if (has_e1_len()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->e1_len(), target);
  }

  // optional bytes E1_string = 5;
  if (has_e1_string()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->e1_string(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.SendRSARsp)
  return target;
}

int SendRSARsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 errcode = 1;
    if (has_errcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->errcode());
    }

    // optional uint32 N_len = 2;
    if (has_n_len()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->n_len());
    }

    // optional bytes N_string = 3;
    if (has_n_string()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->n_string());
    }

    // optional uint32 E1_len = 4;
    if (has_e1_len()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->e1_len());
    }

    // optional bytes E1_string = 5;
    if (has_e1_string()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->e1_string());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SendRSARsp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SendRSARsp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SendRSARsp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SendRSARsp::MergeFrom(const SendRSARsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_errcode()) {
      set_errcode(from.errcode());
    }
    if (from.has_n_len()) {
      set_n_len(from.n_len());
    }
    if (from.has_n_string()) {
      set_n_string(from.n_string());
    }
    if (from.has_e1_len()) {
      set_e1_len(from.e1_len());
    }
    if (from.has_e1_string()) {
      set_e1_string(from.e1_string());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SendRSARsp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SendRSARsp::CopyFrom(const SendRSARsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendRSARsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SendRSARsp::Swap(SendRSARsp* other) {
  if (other != this) {
    std::swap(errcode_, other->errcode_);
    std::swap(n_len_, other->n_len_);
    std::swap(n_string_, other->n_string_);
    std::swap(e1_len_, other->e1_len_);
    std::swap(e1_string_, other->e1_string_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SendRSARsp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SendRSARsp_descriptor_;
  metadata.reflection = SendRSARsp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SendRC4Req::kDaDeviceSnFieldNumber;
const int SendRC4Req::kVinFieldNumber;
const int SendRC4Req::kIccidFieldNumber;
const int SendRC4Req::kSerialNumberFieldNumber;
const int SendRC4Req::kKeyLenFieldNumber;
const int SendRC4Req::kKeyFieldNumber;
const int SendRC4Req::kUpgradingFieldNumber;
const int SendRC4Req::kBcmRegStatusFieldNumber;
#endif  // !_MSC_VER

SendRC4Req::SendRC4Req()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.SendRC4Req)
}

void SendRC4Req::InitAsDefaultInstance() {
}

SendRC4Req::SendRC4Req(const SendRC4Req& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.SendRC4Req)
}

void SendRC4Req::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  da_device_sn_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  vin_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  iccid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  serial_number_ = 0u;
  key_len_ = 0u;
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  upgrading_ = false;
  bcm_reg_status_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SendRC4Req::~SendRC4Req() {
  // @@protoc_insertion_point(destructor:zna.protocol.SendRC4Req)
  SharedDtor();
}

void SendRC4Req::SharedDtor() {
  if (da_device_sn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete da_device_sn_;
  }
  if (vin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vin_;
  }
  if (iccid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete iccid_;
  }
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (this != default_instance_) {
  }
}

void SendRC4Req::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SendRC4Req::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SendRC4Req_descriptor_;
}

const SendRC4Req& SendRC4Req::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

SendRC4Req* SendRC4Req::default_instance_ = NULL;

SendRC4Req* SendRC4Req::New() const {
  return new SendRC4Req;
}

void SendRC4Req::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SendRC4Req*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(serial_number_, key_len_);
    ZR_(upgrading_, bcm_reg_status_);
    if (has_da_device_sn()) {
      if (da_device_sn_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        da_device_sn_->clear();
      }
    }
    if (has_vin()) {
      if (vin_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        vin_->clear();
      }
    }
    if (has_iccid()) {
      if (iccid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        iccid_->clear();
      }
    }
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        key_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SendRC4Req::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.SendRC4Req)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string da_device_sn = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_da_device_sn()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->da_device_sn().data(), this->da_device_sn().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "da_device_sn");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_vin;
        break;
      }

      // required string vin = 2;
      case 2: {
        if (tag == 18) {
         parse_vin:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vin()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->vin().data(), this->vin().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "vin");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_iccid;
        break;
      }

      // required string iccid = 3;
      case 3: {
        if (tag == 26) {
         parse_iccid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_iccid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->iccid().data(), this->iccid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "iccid");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_serial_number;
        break;
      }

      // required uint32 serial_number = 4;
      case 4: {
        if (tag == 32) {
         parse_serial_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serial_number_)));
          set_has_serial_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_key_len;
        break;
      }

      // required uint32 key_len = 5;
      case 5: {
        if (tag == 40) {
         parse_key_len:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &key_len_)));
          set_has_key_len();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_key;
        break;
      }

      // required bytes key = 6;
      case 6: {
        if (tag == 50) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_key()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_upgrading;
        break;
      }

      // optional bool upgrading = 7;
      case 7: {
        if (tag == 56) {
         parse_upgrading:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &upgrading_)));
          set_has_upgrading();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_bcm_reg_status;
        break;
      }

      // optional bool bcm_reg_status = 8;
      case 8: {
        if (tag == 64) {
         parse_bcm_reg_status:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &bcm_reg_status_)));
          set_has_bcm_reg_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.SendRC4Req)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.SendRC4Req)
  return false;
#undef DO_
}

void SendRC4Req::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.SendRC4Req)
  // required string da_device_sn = 1;
  if (has_da_device_sn()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->da_device_sn().data(), this->da_device_sn().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "da_device_sn");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->da_device_sn(), output);
  }

  // required string vin = 2;
  if (has_vin()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->vin().data(), this->vin().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "vin");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->vin(), output);
  }

  // required string iccid = 3;
  if (has_iccid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->iccid().data(), this->iccid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "iccid");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->iccid(), output);
  }

  // required uint32 serial_number = 4;
  if (has_serial_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->serial_number(), output);
  }

  // required uint32 key_len = 5;
  if (has_key_len()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->key_len(), output);
  }

  // required bytes key = 6;
  if (has_key()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->key(), output);
  }

  // optional bool upgrading = 7;
  if (has_upgrading()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->upgrading(), output);
  }

  // optional bool bcm_reg_status = 8;
  if (has_bcm_reg_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->bcm_reg_status(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.SendRC4Req)
}

::google::protobuf::uint8* SendRC4Req::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.SendRC4Req)
  // required string da_device_sn = 1;
  if (has_da_device_sn()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->da_device_sn().data(), this->da_device_sn().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "da_device_sn");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->da_device_sn(), target);
  }

  // required string vin = 2;
  if (has_vin()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->vin().data(), this->vin().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "vin");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->vin(), target);
  }

  // required string iccid = 3;
  if (has_iccid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->iccid().data(), this->iccid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "iccid");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->iccid(), target);
  }

  // required uint32 serial_number = 4;
  if (has_serial_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->serial_number(), target);
  }

  // required uint32 key_len = 5;
  if (has_key_len()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->key_len(), target);
  }

  // required bytes key = 6;
  if (has_key()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->key(), target);
  }

  // optional bool upgrading = 7;
  if (has_upgrading()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->upgrading(), target);
  }

  // optional bool bcm_reg_status = 8;
  if (has_bcm_reg_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->bcm_reg_status(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.SendRC4Req)
  return target;
}

int SendRC4Req::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string da_device_sn = 1;
    if (has_da_device_sn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->da_device_sn());
    }

    // required string vin = 2;
    if (has_vin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->vin());
    }

    // required string iccid = 3;
    if (has_iccid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->iccid());
    }

    // required uint32 serial_number = 4;
    if (has_serial_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serial_number());
    }

    // required uint32 key_len = 5;
    if (has_key_len()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->key_len());
    }

    // required bytes key = 6;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->key());
    }

    // optional bool upgrading = 7;
    if (has_upgrading()) {
      total_size += 1 + 1;
    }

    // optional bool bcm_reg_status = 8;
    if (has_bcm_reg_status()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SendRC4Req::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SendRC4Req* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SendRC4Req*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SendRC4Req::MergeFrom(const SendRC4Req& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_da_device_sn()) {
      set_da_device_sn(from.da_device_sn());
    }
    if (from.has_vin()) {
      set_vin(from.vin());
    }
    if (from.has_iccid()) {
      set_iccid(from.iccid());
    }
    if (from.has_serial_number()) {
      set_serial_number(from.serial_number());
    }
    if (from.has_key_len()) {
      set_key_len(from.key_len());
    }
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_upgrading()) {
      set_upgrading(from.upgrading());
    }
    if (from.has_bcm_reg_status()) {
      set_bcm_reg_status(from.bcm_reg_status());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SendRC4Req::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SendRC4Req::CopyFrom(const SendRC4Req& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendRC4Req::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;

  return true;
}

void SendRC4Req::Swap(SendRC4Req* other) {
  if (other != this) {
    std::swap(da_device_sn_, other->da_device_sn_);
    std::swap(vin_, other->vin_);
    std::swap(iccid_, other->iccid_);
    std::swap(serial_number_, other->serial_number_);
    std::swap(key_len_, other->key_len_);
    std::swap(key_, other->key_);
    std::swap(upgrading_, other->upgrading_);
    std::swap(bcm_reg_status_, other->bcm_reg_status_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SendRC4Req::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SendRC4Req_descriptor_;
  metadata.reflection = SendRC4Req_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SendRC4Resp::kErrcodeFieldNumber;
const int SendRC4Resp::kSerialNumberFieldNumber;
const int SendRC4Resp::kTimeStampFieldNumber;
const int SendRC4Resp::kUpgradeinfoFieldNumber;
#endif  // !_MSC_VER

SendRC4Resp::SendRC4Resp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.SendRC4Resp)
}

void SendRC4Resp::InitAsDefaultInstance() {
}

SendRC4Resp::SendRC4Resp(const SendRC4Resp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.SendRC4Resp)
}

void SendRC4Resp::SharedCtor() {
  _cached_size_ = 0;
  errcode_ = 0u;
  serial_number_ = 0u;
  time_stamp_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SendRC4Resp::~SendRC4Resp() {
  // @@protoc_insertion_point(destructor:zna.protocol.SendRC4Resp)
  SharedDtor();
}

void SendRC4Resp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SendRC4Resp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SendRC4Resp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SendRC4Resp_descriptor_;
}

const SendRC4Resp& SendRC4Resp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

SendRC4Resp* SendRC4Resp::default_instance_ = NULL;

SendRC4Resp* SendRC4Resp::New() const {
  return new SendRC4Resp;
}

void SendRC4Resp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<SendRC4Resp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(errcode_, serial_number_);
    time_stamp_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  upgradeinfo_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SendRC4Resp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.SendRC4Resp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 errcode = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &errcode_)));
          set_has_errcode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_serial_number;
        break;
      }

      // required uint32 serial_number = 2;
      case 2: {
        if (tag == 16) {
         parse_serial_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serial_number_)));
          set_has_serial_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_time_stamp;
        break;
      }

      // required uint32 time_stamp = 3;
      case 3: {
        if (tag == 24) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_upgradeinfo;
        break;
      }

      // repeated .zna.protocol.UpgradeInfo upgradeinfo = 4;
      case 4: {
        if (tag == 34) {
         parse_upgradeinfo:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_upgradeinfo()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_upgradeinfo;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.SendRC4Resp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.SendRC4Resp)
  return false;
#undef DO_
}

void SendRC4Resp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.SendRC4Resp)
  // required uint32 errcode = 1;
  if (has_errcode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->errcode(), output);
  }

  // required uint32 serial_number = 2;
  if (has_serial_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->serial_number(), output);
  }

  // required uint32 time_stamp = 3;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->time_stamp(), output);
  }

  // repeated .zna.protocol.UpgradeInfo upgradeinfo = 4;
  for (int i = 0; i < this->upgradeinfo_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->upgradeinfo(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.SendRC4Resp)
}

::google::protobuf::uint8* SendRC4Resp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.SendRC4Resp)
  // required uint32 errcode = 1;
  if (has_errcode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->errcode(), target);
  }

  // required uint32 serial_number = 2;
  if (has_serial_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->serial_number(), target);
  }

  // required uint32 time_stamp = 3;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->time_stamp(), target);
  }

  // repeated .zna.protocol.UpgradeInfo upgradeinfo = 4;
  for (int i = 0; i < this->upgradeinfo_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->upgradeinfo(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.SendRC4Resp)
  return target;
}

int SendRC4Resp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 errcode = 1;
    if (has_errcode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->errcode());
    }

    // required uint32 serial_number = 2;
    if (has_serial_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serial_number());
    }

    // required uint32 time_stamp = 3;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

  }
  // repeated .zna.protocol.UpgradeInfo upgradeinfo = 4;
  total_size += 1 * this->upgradeinfo_size();
  for (int i = 0; i < this->upgradeinfo_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->upgradeinfo(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SendRC4Resp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SendRC4Resp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SendRC4Resp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SendRC4Resp::MergeFrom(const SendRC4Resp& from) {
  GOOGLE_CHECK_NE(&from, this);
  upgradeinfo_.MergeFrom(from.upgradeinfo_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_errcode()) {
      set_errcode(from.errcode());
    }
    if (from.has_serial_number()) {
      set_serial_number(from.serial_number());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SendRC4Resp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SendRC4Resp::CopyFrom(const SendRC4Resp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendRC4Resp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->upgradeinfo())) return false;
  return true;
}

void SendRC4Resp::Swap(SendRC4Resp* other) {
  if (other != this) {
    std::swap(errcode_, other->errcode_);
    std::swap(serial_number_, other->serial_number_);
    std::swap(time_stamp_, other->time_stamp_);
    upgradeinfo_.Swap(&other->upgradeinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SendRC4Resp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SendRC4Resp_descriptor_;
  metadata.reflection = SendRC4Resp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WakeUpDVRRsp::kSerialNumberFieldNumber;
const int WakeUpDVRRsp::kControlResultFieldNumber;
#endif  // !_MSC_VER

WakeUpDVRRsp::WakeUpDVRRsp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.WakeUpDVRRsp)
}

void WakeUpDVRRsp::InitAsDefaultInstance() {
}

WakeUpDVRRsp::WakeUpDVRRsp(const WakeUpDVRRsp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.WakeUpDVRRsp)
}

void WakeUpDVRRsp::SharedCtor() {
  _cached_size_ = 0;
  serial_number_ = 0u;
  control_result_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WakeUpDVRRsp::~WakeUpDVRRsp() {
  // @@protoc_insertion_point(destructor:zna.protocol.WakeUpDVRRsp)
  SharedDtor();
}

void WakeUpDVRRsp::SharedDtor() {
  if (this != default_instance_) {
  }
}

void WakeUpDVRRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WakeUpDVRRsp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WakeUpDVRRsp_descriptor_;
}

const WakeUpDVRRsp& WakeUpDVRRsp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

WakeUpDVRRsp* WakeUpDVRRsp::default_instance_ = NULL;

WakeUpDVRRsp* WakeUpDVRRsp::New() const {
  return new WakeUpDVRRsp;
}

void WakeUpDVRRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<WakeUpDVRRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(serial_number_, control_result_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WakeUpDVRRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.WakeUpDVRRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 serial_number = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serial_number_)));
          set_has_serial_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_control_result;
        break;
      }

      // required uint32 control_result = 2;
      case 2: {
        if (tag == 16) {
         parse_control_result:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &control_result_)));
          set_has_control_result();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.WakeUpDVRRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.WakeUpDVRRsp)
  return false;
#undef DO_
}

void WakeUpDVRRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.WakeUpDVRRsp)
  // required uint32 serial_number = 1;
  if (has_serial_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->serial_number(), output);
  }

  // required uint32 control_result = 2;
  if (has_control_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->control_result(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.WakeUpDVRRsp)
}

::google::protobuf::uint8* WakeUpDVRRsp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.WakeUpDVRRsp)
  // required uint32 serial_number = 1;
  if (has_serial_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->serial_number(), target);
  }

  // required uint32 control_result = 2;
  if (has_control_result()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->control_result(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.WakeUpDVRRsp)
  return target;
}

int WakeUpDVRRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 serial_number = 1;
    if (has_serial_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serial_number());
    }

    // required uint32 control_result = 2;
    if (has_control_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->control_result());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WakeUpDVRRsp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WakeUpDVRRsp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WakeUpDVRRsp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WakeUpDVRRsp::MergeFrom(const WakeUpDVRRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serial_number()) {
      set_serial_number(from.serial_number());
    }
    if (from.has_control_result()) {
      set_control_result(from.control_result());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WakeUpDVRRsp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WakeUpDVRRsp::CopyFrom(const WakeUpDVRRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WakeUpDVRRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void WakeUpDVRRsp::Swap(WakeUpDVRRsp* other) {
  if (other != this) {
    std::swap(serial_number_, other->serial_number_);
    std::swap(control_result_, other->control_result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WakeUpDVRRsp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WakeUpDVRRsp_descriptor_;
  metadata.reflection = WakeUpDVRRsp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WakeUpDVRReq::kSerialNumberFieldNumber;
const int WakeUpDVRReq::kTimeStampFieldNumber;
#endif  // !_MSC_VER

WakeUpDVRReq::WakeUpDVRReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.WakeUpDVRReq)
}

void WakeUpDVRReq::InitAsDefaultInstance() {
}

WakeUpDVRReq::WakeUpDVRReq(const WakeUpDVRReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.WakeUpDVRReq)
}

void WakeUpDVRReq::SharedCtor() {
  _cached_size_ = 0;
  serial_number_ = 0u;
  time_stamp_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WakeUpDVRReq::~WakeUpDVRReq() {
  // @@protoc_insertion_point(destructor:zna.protocol.WakeUpDVRReq)
  SharedDtor();
}

void WakeUpDVRReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void WakeUpDVRReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WakeUpDVRReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WakeUpDVRReq_descriptor_;
}

const WakeUpDVRReq& WakeUpDVRReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

WakeUpDVRReq* WakeUpDVRReq::default_instance_ = NULL;

WakeUpDVRReq* WakeUpDVRReq::New() const {
  return new WakeUpDVRReq;
}

void WakeUpDVRReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<WakeUpDVRReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(serial_number_, time_stamp_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WakeUpDVRReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.WakeUpDVRReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 serial_number = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serial_number_)));
          set_has_serial_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_time_stamp;
        break;
      }

      // required uint32 time_stamp = 2;
      case 2: {
        if (tag == 16) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.WakeUpDVRReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.WakeUpDVRReq)
  return false;
#undef DO_
}

void WakeUpDVRReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.WakeUpDVRReq)
  // required uint32 serial_number = 1;
  if (has_serial_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->serial_number(), output);
  }

  // required uint32 time_stamp = 2;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->time_stamp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.WakeUpDVRReq)
}

::google::protobuf::uint8* WakeUpDVRReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.WakeUpDVRReq)
  // required uint32 serial_number = 1;
  if (has_serial_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->serial_number(), target);
  }

  // required uint32 time_stamp = 2;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->time_stamp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.WakeUpDVRReq)
  return target;
}

int WakeUpDVRReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 serial_number = 1;
    if (has_serial_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serial_number());
    }

    // required uint32 time_stamp = 2;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WakeUpDVRReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WakeUpDVRReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WakeUpDVRReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WakeUpDVRReq::MergeFrom(const WakeUpDVRReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serial_number()) {
      set_serial_number(from.serial_number());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WakeUpDVRReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WakeUpDVRReq::CopyFrom(const WakeUpDVRReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WakeUpDVRReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void WakeUpDVRReq::Swap(WakeUpDVRReq* other) {
  if (other != this) {
    std::swap(serial_number_, other->serial_number_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WakeUpDVRReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WakeUpDVRReq_descriptor_;
  metadata.reflection = WakeUpDVRReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RmtDiagRsp::kResultFieldNumber;
const int RmtDiagRsp::kSerialNumberFieldNumber;
const int RmtDiagRsp::kTimeStampFieldNumber;
const int RmtDiagRsp::kDiagAVMFieldNumber;
const int RmtDiagRsp::kDiagSONARFieldNumber;
const int RmtDiagRsp::kDiagBSWFieldNumber;
const int RmtDiagRsp::kDiagECMFieldNumber;
const int RmtDiagRsp::kDiagTCMFieldNumber;
const int RmtDiagRsp::kDiagUSMFieldNumber;
const int RmtDiagRsp::kDiagBCMFieldNumber;
const int RmtDiagRsp::kDiagFEBCAMERAFieldNumber;
const int RmtDiagRsp::kDiagFEBRADARFieldNumber;
const int RmtDiagRsp::kDiagDVRFieldNumber;
const int RmtDiagRsp::kDiagVDCFieldNumber;
const int RmtDiagRsp::kDiagEPSFieldNumber;
const int RmtDiagRsp::kDiagGWFieldNumber;
const int RmtDiagRsp::kDiagTPMSFieldNumber;
const int RmtDiagRsp::kDiagMETERFieldNumber;
const int RmtDiagRsp::kDiagTCUFieldNumber;
const int RmtDiagRsp::kDiagACUFieldNumber;
const int RmtDiagRsp::kDiagDAFieldNumber;
#endif  // !_MSC_VER

RmtDiagRsp::RmtDiagRsp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.RmtDiagRsp)
}

void RmtDiagRsp::InitAsDefaultInstance() {
}

RmtDiagRsp::RmtDiagRsp(const RmtDiagRsp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.RmtDiagRsp)
}

void RmtDiagRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  result_ = 0;
  serial_number_ = 0u;
  time_stamp_ = 0u;
  diag_avm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  diag_sonar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  diag_bsw_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  diag_ecm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  diag_tcm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  diag_usm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  diag_bcm_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  diag_feb_camera_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  diag_feb_radar_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  diag_dvr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  diag_vdc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  diag_eps_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  diag_gw_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  diag_tpms_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  diag_meter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  diag_tcu_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  diag_acu_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  diag_da_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RmtDiagRsp::~RmtDiagRsp() {
  // @@protoc_insertion_point(destructor:zna.protocol.RmtDiagRsp)
  SharedDtor();
}

void RmtDiagRsp::SharedDtor() {
  if (diag_avm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_avm_;
  }
  if (diag_sonar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_sonar_;
  }
  if (diag_bsw_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_bsw_;
  }
  if (diag_ecm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_ecm_;
  }
  if (diag_tcm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_tcm_;
  }
  if (diag_usm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_usm_;
  }
  if (diag_bcm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_bcm_;
  }
  if (diag_feb_camera_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_feb_camera_;
  }
  if (diag_feb_radar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_feb_radar_;
  }
  if (diag_dvr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_dvr_;
  }
  if (diag_vdc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_vdc_;
  }
  if (diag_eps_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_eps_;
  }
  if (diag_gw_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_gw_;
  }
  if (diag_tpms_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_tpms_;
  }
  if (diag_meter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_meter_;
  }
  if (diag_tcu_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_tcu_;
  }
  if (diag_acu_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_acu_;
  }
  if (diag_da_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete diag_da_;
  }
  if (this != default_instance_) {
  }
}

void RmtDiagRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RmtDiagRsp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RmtDiagRsp_descriptor_;
}

const RmtDiagRsp& RmtDiagRsp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

RmtDiagRsp* RmtDiagRsp::default_instance_ = NULL;

RmtDiagRsp* RmtDiagRsp::New() const {
  return new RmtDiagRsp;
}

void RmtDiagRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RmtDiagRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(result_, serial_number_);
    time_stamp_ = 0u;
    if (has_diag_avm()) {
      if (diag_avm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        diag_avm_->clear();
      }
    }
    if (has_diag_sonar()) {
      if (diag_sonar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        diag_sonar_->clear();
      }
    }
    if (has_diag_bsw()) {
      if (diag_bsw_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        diag_bsw_->clear();
      }
    }
    if (has_diag_ecm()) {
      if (diag_ecm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        diag_ecm_->clear();
      }
    }
    if (has_diag_tcm()) {
      if (diag_tcm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        diag_tcm_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & 65280) {
    if (has_diag_usm()) {
      if (diag_usm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        diag_usm_->clear();
      }
    }
    if (has_diag_bcm()) {
      if (diag_bcm_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        diag_bcm_->clear();
      }
    }
    if (has_diag_feb_camera()) {
      if (diag_feb_camera_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        diag_feb_camera_->clear();
      }
    }
    if (has_diag_feb_radar()) {
      if (diag_feb_radar_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        diag_feb_radar_->clear();
      }
    }
    if (has_diag_dvr()) {
      if (diag_dvr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        diag_dvr_->clear();
      }
    }
    if (has_diag_vdc()) {
      if (diag_vdc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        diag_vdc_->clear();
      }
    }
    if (has_diag_eps()) {
      if (diag_eps_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        diag_eps_->clear();
      }
    }
    if (has_diag_gw()) {
      if (diag_gw_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        diag_gw_->clear();
      }
    }
  }
  if (_has_bits_[16 / 32] & 2031616) {
    if (has_diag_tpms()) {
      if (diag_tpms_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        diag_tpms_->clear();
      }
    }
    if (has_diag_meter()) {
      if (diag_meter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        diag_meter_->clear();
      }
    }
    if (has_diag_tcu()) {
      if (diag_tcu_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        diag_tcu_->clear();
      }
    }
    if (has_diag_acu()) {
      if (diag_acu_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        diag_acu_->clear();
      }
    }
    if (has_diag_da()) {
      if (diag_da_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        diag_da_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RmtDiagRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.RmtDiagRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .zna.protocol.RmtDiagRspCode result = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::zna::protocol::RmtDiagRspCode_IsValid(value)) {
            set_result(static_cast< ::zna::protocol::RmtDiagRspCode >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_serial_number;
        break;
      }

      // required uint32 serial_number = 2;
      case 2: {
        if (tag == 16) {
         parse_serial_number:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serial_number_)));
          set_has_serial_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_time_stamp;
        break;
      }

      // required uint32 time_stamp = 3;
      case 3: {
        if (tag == 24) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_Diag_AVM;
        break;
      }

      // optional bytes Diag_AVM = 4;
      case 4: {
        if (tag == 34) {
         parse_Diag_AVM:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_diag_avm()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_Diag_SONAR;
        break;
      }

      // optional bytes Diag_SONAR = 5;
      case 5: {
        if (tag == 42) {
         parse_Diag_SONAR:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_diag_sonar()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_Diag_BSW;
        break;
      }

      // optional bytes Diag_BSW = 6;
      case 6: {
        if (tag == 50) {
         parse_Diag_BSW:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_diag_bsw()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_Diag_ECM;
        break;
      }

      // optional bytes Diag_ECM = 7;
      case 7: {
        if (tag == 58) {
         parse_Diag_ECM:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_diag_ecm()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_Diag_TCM;
        break;
      }

      // optional bytes Diag_TCM = 8;
      case 8: {
        if (tag == 66) {
         parse_Diag_TCM:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_diag_tcm()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_Diag_USM;
        break;
      }

      // optional bytes Diag_USM = 9;
      case 9: {
        if (tag == 74) {
         parse_Diag_USM:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_diag_usm()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_Diag_BCM;
        break;
      }

      // optional bytes Diag_BCM = 10;
      case 10: {
        if (tag == 82) {
         parse_Diag_BCM:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_diag_bcm()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_Diag_FEB_CAMERA;
        break;
      }

      // optional bytes Diag_FEB_CAMERA = 11;
      case 11: {
        if (tag == 90) {
         parse_Diag_FEB_CAMERA:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_diag_feb_camera()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_Diag_FEB_RADAR;
        break;
      }

      // optional bytes Diag_FEB_RADAR = 12;
      case 12: {
        if (tag == 98) {
         parse_Diag_FEB_RADAR:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_diag_feb_radar()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_Diag_DVR;
        break;
      }

      // optional bytes Diag_DVR = 13;
      case 13: {
        if (tag == 106) {
         parse_Diag_DVR:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_diag_dvr()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_Diag_VDC;
        break;
      }

      // optional bytes Diag_VDC = 14;
      case 14: {
        if (tag == 114) {
         parse_Diag_VDC:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_diag_vdc()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(122)) goto parse_Diag_EPS;
        break;
      }

      // optional bytes Diag_EPS = 15;
      case 15: {
        if (tag == 122) {
         parse_Diag_EPS:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_diag_eps()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(130)) goto parse_Diag_GW;
        break;
      }

      // optional bytes Diag_GW = 16;
      case 16: {
        if (tag == 130) {
         parse_Diag_GW:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_diag_gw()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(138)) goto parse_Diag_TPMS;
        break;
      }

      // optional bytes Diag_TPMS = 17;
      case 17: {
        if (tag == 138) {
         parse_Diag_TPMS:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_diag_tpms()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(146)) goto parse_Diag_METER;
        break;
      }

      // optional bytes Diag_METER = 18;
      case 18: {
        if (tag == 146) {
         parse_Diag_METER:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_diag_meter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(154)) goto parse_Diag_TCU;
        break;
      }

      // optional bytes Diag_TCU = 19;
      case 19: {
        if (tag == 154) {
         parse_Diag_TCU:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_diag_tcu()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(162)) goto parse_Diag_ACU;
        break;
      }

      // optional bytes Diag_ACU = 20;
      case 20: {
        if (tag == 162) {
         parse_Diag_ACU:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_diag_acu()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(170)) goto parse_Diag_DA;
        break;
      }

      // optional bytes Diag_DA = 21;
      case 21: {
        if (tag == 170) {
         parse_Diag_DA:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_diag_da()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.RmtDiagRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.RmtDiagRsp)
  return false;
#undef DO_
}

void RmtDiagRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.RmtDiagRsp)
  // required .zna.protocol.RmtDiagRspCode result = 1;
  if (has_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->result(), output);
  }

  // required uint32 serial_number = 2;
  if (has_serial_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->serial_number(), output);
  }

  // required uint32 time_stamp = 3;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->time_stamp(), output);
  }

  // optional bytes Diag_AVM = 4;
  if (has_diag_avm()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->diag_avm(), output);
  }

  // optional bytes Diag_SONAR = 5;
  if (has_diag_sonar()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->diag_sonar(), output);
  }

  // optional bytes Diag_BSW = 6;
  if (has_diag_bsw()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->diag_bsw(), output);
  }

  // optional bytes Diag_ECM = 7;
  if (has_diag_ecm()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      7, this->diag_ecm(), output);
  }

  // optional bytes Diag_TCM = 8;
  if (has_diag_tcm()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      8, this->diag_tcm(), output);
  }

  // optional bytes Diag_USM = 9;
  if (has_diag_usm()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      9, this->diag_usm(), output);
  }

  // optional bytes Diag_BCM = 10;
  if (has_diag_bcm()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      10, this->diag_bcm(), output);
  }

  // optional bytes Diag_FEB_CAMERA = 11;
  if (has_diag_feb_camera()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      11, this->diag_feb_camera(), output);
  }

  // optional bytes Diag_FEB_RADAR = 12;
  if (has_diag_feb_radar()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      12, this->diag_feb_radar(), output);
  }

  // optional bytes Diag_DVR = 13;
  if (has_diag_dvr()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      13, this->diag_dvr(), output);
  }

  // optional bytes Diag_VDC = 14;
  if (has_diag_vdc()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      14, this->diag_vdc(), output);
  }

  // optional bytes Diag_EPS = 15;
  if (has_diag_eps()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      15, this->diag_eps(), output);
  }

  // optional bytes Diag_GW = 16;
  if (has_diag_gw()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      16, this->diag_gw(), output);
  }

  // optional bytes Diag_TPMS = 17;
  if (has_diag_tpms()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      17, this->diag_tpms(), output);
  }

  // optional bytes Diag_METER = 18;
  if (has_diag_meter()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      18, this->diag_meter(), output);
  }

  // optional bytes Diag_TCU = 19;
  if (has_diag_tcu()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      19, this->diag_tcu(), output);
  }

  // optional bytes Diag_ACU = 20;
  if (has_diag_acu()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->diag_acu(), output);
  }

  // optional bytes Diag_DA = 21;
  if (has_diag_da()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      21, this->diag_da(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.RmtDiagRsp)
}

::google::protobuf::uint8* RmtDiagRsp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.RmtDiagRsp)
  // required .zna.protocol.RmtDiagRspCode result = 1;
  if (has_result()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->result(), target);
  }

  // required uint32 serial_number = 2;
  if (has_serial_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->serial_number(), target);
  }

  // required uint32 time_stamp = 3;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->time_stamp(), target);
  }

  // optional bytes Diag_AVM = 4;
  if (has_diag_avm()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->diag_avm(), target);
  }

  // optional bytes Diag_SONAR = 5;
  if (has_diag_sonar()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->diag_sonar(), target);
  }

  // optional bytes Diag_BSW = 6;
  if (has_diag_bsw()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->diag_bsw(), target);
  }

  // optional bytes Diag_ECM = 7;
  if (has_diag_ecm()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        7, this->diag_ecm(), target);
  }

  // optional bytes Diag_TCM = 8;
  if (has_diag_tcm()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        8, this->diag_tcm(), target);
  }

  // optional bytes Diag_USM = 9;
  if (has_diag_usm()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        9, this->diag_usm(), target);
  }

  // optional bytes Diag_BCM = 10;
  if (has_diag_bcm()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        10, this->diag_bcm(), target);
  }

  // optional bytes Diag_FEB_CAMERA = 11;
  if (has_diag_feb_camera()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        11, this->diag_feb_camera(), target);
  }

  // optional bytes Diag_FEB_RADAR = 12;
  if (has_diag_feb_radar()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        12, this->diag_feb_radar(), target);
  }

  // optional bytes Diag_DVR = 13;
  if (has_diag_dvr()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        13, this->diag_dvr(), target);
  }

  // optional bytes Diag_VDC = 14;
  if (has_diag_vdc()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        14, this->diag_vdc(), target);
  }

  // optional bytes Diag_EPS = 15;
  if (has_diag_eps()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        15, this->diag_eps(), target);
  }

  // optional bytes Diag_GW = 16;
  if (has_diag_gw()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        16, this->diag_gw(), target);
  }

  // optional bytes Diag_TPMS = 17;
  if (has_diag_tpms()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        17, this->diag_tpms(), target);
  }

  // optional bytes Diag_METER = 18;
  if (has_diag_meter()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        18, this->diag_meter(), target);
  }

  // optional bytes Diag_TCU = 19;
  if (has_diag_tcu()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        19, this->diag_tcu(), target);
  }

  // optional bytes Diag_ACU = 20;
  if (has_diag_acu()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        20, this->diag_acu(), target);
  }

  // optional bytes Diag_DA = 21;
  if (has_diag_da()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        21, this->diag_da(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.RmtDiagRsp)
  return target;
}

int RmtDiagRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .zna.protocol.RmtDiagRspCode result = 1;
    if (has_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->result());
    }

    // required uint32 serial_number = 2;
    if (has_serial_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serial_number());
    }

    // required uint32 time_stamp = 3;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

    // optional bytes Diag_AVM = 4;
    if (has_diag_avm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->diag_avm());
    }

    // optional bytes Diag_SONAR = 5;
    if (has_diag_sonar()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->diag_sonar());
    }

    // optional bytes Diag_BSW = 6;
    if (has_diag_bsw()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->diag_bsw());
    }

    // optional bytes Diag_ECM = 7;
    if (has_diag_ecm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->diag_ecm());
    }

    // optional bytes Diag_TCM = 8;
    if (has_diag_tcm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->diag_tcm());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bytes Diag_USM = 9;
    if (has_diag_usm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->diag_usm());
    }

    // optional bytes Diag_BCM = 10;
    if (has_diag_bcm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->diag_bcm());
    }

    // optional bytes Diag_FEB_CAMERA = 11;
    if (has_diag_feb_camera()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->diag_feb_camera());
    }

    // optional bytes Diag_FEB_RADAR = 12;
    if (has_diag_feb_radar()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->diag_feb_radar());
    }

    // optional bytes Diag_DVR = 13;
    if (has_diag_dvr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->diag_dvr());
    }

    // optional bytes Diag_VDC = 14;
    if (has_diag_vdc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->diag_vdc());
    }

    // optional bytes Diag_EPS = 15;
    if (has_diag_eps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->diag_eps());
    }

    // optional bytes Diag_GW = 16;
    if (has_diag_gw()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->diag_gw());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional bytes Diag_TPMS = 17;
    if (has_diag_tpms()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->diag_tpms());
    }

    // optional bytes Diag_METER = 18;
    if (has_diag_meter()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->diag_meter());
    }

    // optional bytes Diag_TCU = 19;
    if (has_diag_tcu()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->diag_tcu());
    }

    // optional bytes Diag_ACU = 20;
    if (has_diag_acu()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->diag_acu());
    }

    // optional bytes Diag_DA = 21;
    if (has_diag_da()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->diag_da());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RmtDiagRsp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RmtDiagRsp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RmtDiagRsp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RmtDiagRsp::MergeFrom(const RmtDiagRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_result()) {
      set_result(from.result());
    }
    if (from.has_serial_number()) {
      set_serial_number(from.serial_number());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_diag_avm()) {
      set_diag_avm(from.diag_avm());
    }
    if (from.has_diag_sonar()) {
      set_diag_sonar(from.diag_sonar());
    }
    if (from.has_diag_bsw()) {
      set_diag_bsw(from.diag_bsw());
    }
    if (from.has_diag_ecm()) {
      set_diag_ecm(from.diag_ecm());
    }
    if (from.has_diag_tcm()) {
      set_diag_tcm(from.diag_tcm());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_diag_usm()) {
      set_diag_usm(from.diag_usm());
    }
    if (from.has_diag_bcm()) {
      set_diag_bcm(from.diag_bcm());
    }
    if (from.has_diag_feb_camera()) {
      set_diag_feb_camera(from.diag_feb_camera());
    }
    if (from.has_diag_feb_radar()) {
      set_diag_feb_radar(from.diag_feb_radar());
    }
    if (from.has_diag_dvr()) {
      set_diag_dvr(from.diag_dvr());
    }
    if (from.has_diag_vdc()) {
      set_diag_vdc(from.diag_vdc());
    }
    if (from.has_diag_eps()) {
      set_diag_eps(from.diag_eps());
    }
    if (from.has_diag_gw()) {
      set_diag_gw(from.diag_gw());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_diag_tpms()) {
      set_diag_tpms(from.diag_tpms());
    }
    if (from.has_diag_meter()) {
      set_diag_meter(from.diag_meter());
    }
    if (from.has_diag_tcu()) {
      set_diag_tcu(from.diag_tcu());
    }
    if (from.has_diag_acu()) {
      set_diag_acu(from.diag_acu());
    }
    if (from.has_diag_da()) {
      set_diag_da(from.diag_da());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RmtDiagRsp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RmtDiagRsp::CopyFrom(const RmtDiagRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RmtDiagRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void RmtDiagRsp::Swap(RmtDiagRsp* other) {
  if (other != this) {
    std::swap(result_, other->result_);
    std::swap(serial_number_, other->serial_number_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(diag_avm_, other->diag_avm_);
    std::swap(diag_sonar_, other->diag_sonar_);
    std::swap(diag_bsw_, other->diag_bsw_);
    std::swap(diag_ecm_, other->diag_ecm_);
    std::swap(diag_tcm_, other->diag_tcm_);
    std::swap(diag_usm_, other->diag_usm_);
    std::swap(diag_bcm_, other->diag_bcm_);
    std::swap(diag_feb_camera_, other->diag_feb_camera_);
    std::swap(diag_feb_radar_, other->diag_feb_radar_);
    std::swap(diag_dvr_, other->diag_dvr_);
    std::swap(diag_vdc_, other->diag_vdc_);
    std::swap(diag_eps_, other->diag_eps_);
    std::swap(diag_gw_, other->diag_gw_);
    std::swap(diag_tpms_, other->diag_tpms_);
    std::swap(diag_meter_, other->diag_meter_);
    std::swap(diag_tcu_, other->diag_tcu_);
    std::swap(diag_acu_, other->diag_acu_);
    std::swap(diag_da_, other->diag_da_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RmtDiagRsp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RmtDiagRsp_descriptor_;
  metadata.reflection = RmtDiagRsp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RmtDiagReq::kSerialNumberFieldNumber;
const int RmtDiagReq::kTimeStampFieldNumber;
#endif  // !_MSC_VER

RmtDiagReq::RmtDiagReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.RmtDiagReq)
}

void RmtDiagReq::InitAsDefaultInstance() {
}

RmtDiagReq::RmtDiagReq(const RmtDiagReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.RmtDiagReq)
}

void RmtDiagReq::SharedCtor() {
  _cached_size_ = 0;
  serial_number_ = 0u;
  time_stamp_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RmtDiagReq::~RmtDiagReq() {
  // @@protoc_insertion_point(destructor:zna.protocol.RmtDiagReq)
  SharedDtor();
}

void RmtDiagReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RmtDiagReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RmtDiagReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RmtDiagReq_descriptor_;
}

const RmtDiagReq& RmtDiagReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

RmtDiagReq* RmtDiagReq::default_instance_ = NULL;

RmtDiagReq* RmtDiagReq::New() const {
  return new RmtDiagReq;
}

void RmtDiagReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<RmtDiagReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(serial_number_, time_stamp_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RmtDiagReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.RmtDiagReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 serial_number = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serial_number_)));
          set_has_serial_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_time_stamp;
        break;
      }

      // required uint32 time_stamp = 2;
      case 2: {
        if (tag == 16) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.RmtDiagReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.RmtDiagReq)
  return false;
#undef DO_
}

void RmtDiagReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.RmtDiagReq)
  // required uint32 serial_number = 1;
  if (has_serial_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->serial_number(), output);
  }

  // required uint32 time_stamp = 2;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->time_stamp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.RmtDiagReq)
}

::google::protobuf::uint8* RmtDiagReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.RmtDiagReq)
  // required uint32 serial_number = 1;
  if (has_serial_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->serial_number(), target);
  }

  // required uint32 time_stamp = 2;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->time_stamp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.RmtDiagReq)
  return target;
}

int RmtDiagReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 serial_number = 1;
    if (has_serial_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serial_number());
    }

    // required uint32 time_stamp = 2;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RmtDiagReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RmtDiagReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RmtDiagReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RmtDiagReq::MergeFrom(const RmtDiagReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serial_number()) {
      set_serial_number(from.serial_number());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RmtDiagReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RmtDiagReq::CopyFrom(const RmtDiagReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RmtDiagReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void RmtDiagReq::Swap(RmtDiagReq* other) {
  if (other != this) {
    std::swap(serial_number_, other->serial_number_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RmtDiagReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RmtDiagReq_descriptor_;
  metadata.reflection = RmtDiagReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Fault_List_info::kFaultListOneFieldNumber;
#endif  // !_MSC_VER

Fault_List_info::Fault_List_info()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.Fault_List_info)
}

void Fault_List_info::InitAsDefaultInstance() {
}

Fault_List_info::Fault_List_info(const Fault_List_info& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.Fault_List_info)
}

void Fault_List_info::SharedCtor() {
  _cached_size_ = 0;
  fault_list_one_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Fault_List_info::~Fault_List_info() {
  // @@protoc_insertion_point(destructor:zna.protocol.Fault_List_info)
  SharedDtor();
}

void Fault_List_info::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Fault_List_info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Fault_List_info::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Fault_List_info_descriptor_;
}

const Fault_List_info& Fault_List_info::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

Fault_List_info* Fault_List_info::default_instance_ = NULL;

Fault_List_info* Fault_List_info::New() const {
  return new Fault_List_info;
}

void Fault_List_info::Clear() {
  fault_list_one_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Fault_List_info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.Fault_List_info)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 Fault_List_one = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fault_list_one_)));
          set_has_fault_list_one();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.Fault_List_info)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.Fault_List_info)
  return false;
#undef DO_
}

void Fault_List_info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.Fault_List_info)
  // optional uint32 Fault_List_one = 1;
  if (has_fault_list_one()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->fault_list_one(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.Fault_List_info)
}

::google::protobuf::uint8* Fault_List_info::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.Fault_List_info)
  // optional uint32 Fault_List_one = 1;
  if (has_fault_list_one()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->fault_list_one(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.Fault_List_info)
  return target;
}

int Fault_List_info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 Fault_List_one = 1;
    if (has_fault_list_one()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fault_list_one());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Fault_List_info::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Fault_List_info* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Fault_List_info*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Fault_List_info::MergeFrom(const Fault_List_info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_fault_list_one()) {
      set_fault_list_one(from.fault_list_one());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Fault_List_info::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Fault_List_info::CopyFrom(const Fault_List_info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Fault_List_info::IsInitialized() const {

  return true;
}

void Fault_List_info::Swap(Fault_List_info* other) {
  if (other != this) {
    std::swap(fault_list_one_, other->fault_list_one_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Fault_List_info::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Fault_List_info_descriptor_;
  metadata.reflection = Fault_List_info_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FourGExtendCmdRsp::kSerialNumberFieldNumber;
const int FourGExtendCmdRsp::kTimeStampFieldNumber;
const int FourGExtendCmdRsp::kCommanderIdFieldNumber;
const int FourGExtendCmdRsp::kResultInfoFieldNumber;
#endif  // !_MSC_VER

FourGExtendCmdRsp::FourGExtendCmdRsp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.FourGExtendCmdRsp)
}

void FourGExtendCmdRsp::InitAsDefaultInstance() {
}

FourGExtendCmdRsp::FourGExtendCmdRsp(const FourGExtendCmdRsp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.FourGExtendCmdRsp)
}

void FourGExtendCmdRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  serial_number_ = 0u;
  time_stamp_ = 0u;
  commander_id_ = 0u;
  result_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FourGExtendCmdRsp::~FourGExtendCmdRsp() {
  // @@protoc_insertion_point(destructor:zna.protocol.FourGExtendCmdRsp)
  SharedDtor();
}

void FourGExtendCmdRsp::SharedDtor() {
  if (result_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete result_info_;
  }
  if (this != default_instance_) {
  }
}

void FourGExtendCmdRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FourGExtendCmdRsp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FourGExtendCmdRsp_descriptor_;
}

const FourGExtendCmdRsp& FourGExtendCmdRsp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

FourGExtendCmdRsp* FourGExtendCmdRsp::default_instance_ = NULL;

FourGExtendCmdRsp* FourGExtendCmdRsp::New() const {
  return new FourGExtendCmdRsp;
}

void FourGExtendCmdRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<FourGExtendCmdRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(serial_number_, time_stamp_);
    commander_id_ = 0u;
    if (has_result_info()) {
      if (result_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        result_info_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FourGExtendCmdRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.FourGExtendCmdRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 serial_number = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serial_number_)));
          set_has_serial_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_time_stamp;
        break;
      }

      // required uint32 time_stamp = 2;
      case 2: {
        if (tag == 16) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_commander_id;
        break;
      }

      // required uint32 commander_id = 3;
      case 3: {
        if (tag == 24) {
         parse_commander_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &commander_id_)));
          set_has_commander_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_result_info;
        break;
      }

      // required bytes result_info = 4;
      case 4: {
        if (tag == 34) {
         parse_result_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_result_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.FourGExtendCmdRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.FourGExtendCmdRsp)
  return false;
#undef DO_
}

void FourGExtendCmdRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.FourGExtendCmdRsp)
  // required uint32 serial_number = 1;
  if (has_serial_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->serial_number(), output);
  }

  // required uint32 time_stamp = 2;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->time_stamp(), output);
  }

  // required uint32 commander_id = 3;
  if (has_commander_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->commander_id(), output);
  }

  // required bytes result_info = 4;
  if (has_result_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->result_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.FourGExtendCmdRsp)
}

::google::protobuf::uint8* FourGExtendCmdRsp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.FourGExtendCmdRsp)
  // required uint32 serial_number = 1;
  if (has_serial_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->serial_number(), target);
  }

  // required uint32 time_stamp = 2;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->time_stamp(), target);
  }

  // required uint32 commander_id = 3;
  if (has_commander_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->commander_id(), target);
  }

  // required bytes result_info = 4;
  if (has_result_info()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->result_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.FourGExtendCmdRsp)
  return target;
}

int FourGExtendCmdRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 serial_number = 1;
    if (has_serial_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serial_number());
    }

    // required uint32 time_stamp = 2;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

    // required uint32 commander_id = 3;
    if (has_commander_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->commander_id());
    }

    // required bytes result_info = 4;
    if (has_result_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->result_info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FourGExtendCmdRsp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FourGExtendCmdRsp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FourGExtendCmdRsp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FourGExtendCmdRsp::MergeFrom(const FourGExtendCmdRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serial_number()) {
      set_serial_number(from.serial_number());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_commander_id()) {
      set_commander_id(from.commander_id());
    }
    if (from.has_result_info()) {
      set_result_info(from.result_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FourGExtendCmdRsp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FourGExtendCmdRsp::CopyFrom(const FourGExtendCmdRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FourGExtendCmdRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void FourGExtendCmdRsp::Swap(FourGExtendCmdRsp* other) {
  if (other != this) {
    std::swap(serial_number_, other->serial_number_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(commander_id_, other->commander_id_);
    std::swap(result_info_, other->result_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FourGExtendCmdRsp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FourGExtendCmdRsp_descriptor_;
  metadata.reflection = FourGExtendCmdRsp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FourGExtendCmdReq::kSerialNumberFieldNumber;
const int FourGExtendCmdReq::kTimeStampFieldNumber;
const int FourGExtendCmdReq::kCommanderIdFieldNumber;
const int FourGExtendCmdReq::kResultInfoFieldNumber;
#endif  // !_MSC_VER

FourGExtendCmdReq::FourGExtendCmdReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.FourGExtendCmdReq)
}

void FourGExtendCmdReq::InitAsDefaultInstance() {
}

FourGExtendCmdReq::FourGExtendCmdReq(const FourGExtendCmdReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.FourGExtendCmdReq)
}

void FourGExtendCmdReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  serial_number_ = 0u;
  time_stamp_ = 0u;
  commander_id_ = 0u;
  result_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FourGExtendCmdReq::~FourGExtendCmdReq() {
  // @@protoc_insertion_point(destructor:zna.protocol.FourGExtendCmdReq)
  SharedDtor();
}

void FourGExtendCmdReq::SharedDtor() {
  if (result_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete result_info_;
  }
  if (this != default_instance_) {
  }
}

void FourGExtendCmdReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FourGExtendCmdReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FourGExtendCmdReq_descriptor_;
}

const FourGExtendCmdReq& FourGExtendCmdReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

FourGExtendCmdReq* FourGExtendCmdReq::default_instance_ = NULL;

FourGExtendCmdReq* FourGExtendCmdReq::New() const {
  return new FourGExtendCmdReq;
}

void FourGExtendCmdReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<FourGExtendCmdReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(serial_number_, time_stamp_);
    commander_id_ = 0u;
    if (has_result_info()) {
      if (result_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        result_info_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FourGExtendCmdReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.FourGExtendCmdReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 serial_number = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serial_number_)));
          set_has_serial_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_time_stamp;
        break;
      }

      // required uint32 time_stamp = 2;
      case 2: {
        if (tag == 16) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_commander_id;
        break;
      }

      // required uint32 commander_id = 3;
      case 3: {
        if (tag == 24) {
         parse_commander_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &commander_id_)));
          set_has_commander_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_result_info;
        break;
      }

      // required bytes result_info = 4;
      case 4: {
        if (tag == 34) {
         parse_result_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_result_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.FourGExtendCmdReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.FourGExtendCmdReq)
  return false;
#undef DO_
}

void FourGExtendCmdReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.FourGExtendCmdReq)
  // required uint32 serial_number = 1;
  if (has_serial_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->serial_number(), output);
  }

  // required uint32 time_stamp = 2;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->time_stamp(), output);
  }

  // required uint32 commander_id = 3;
  if (has_commander_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->commander_id(), output);
  }

  // required bytes result_info = 4;
  if (has_result_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->result_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.FourGExtendCmdReq)
}

::google::protobuf::uint8* FourGExtendCmdReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.FourGExtendCmdReq)
  // required uint32 serial_number = 1;
  if (has_serial_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->serial_number(), target);
  }

  // required uint32 time_stamp = 2;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->time_stamp(), target);
  }

  // required uint32 commander_id = 3;
  if (has_commander_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->commander_id(), target);
  }

  // required bytes result_info = 4;
  if (has_result_info()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->result_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.FourGExtendCmdReq)
  return target;
}

int FourGExtendCmdReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 serial_number = 1;
    if (has_serial_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serial_number());
    }

    // required uint32 time_stamp = 2;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

    // required uint32 commander_id = 3;
    if (has_commander_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->commander_id());
    }

    // required bytes result_info = 4;
    if (has_result_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->result_info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FourGExtendCmdReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FourGExtendCmdReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FourGExtendCmdReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FourGExtendCmdReq::MergeFrom(const FourGExtendCmdReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serial_number()) {
      set_serial_number(from.serial_number());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_commander_id()) {
      set_commander_id(from.commander_id());
    }
    if (from.has_result_info()) {
      set_result_info(from.result_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FourGExtendCmdReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FourGExtendCmdReq::CopyFrom(const FourGExtendCmdReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FourGExtendCmdReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void FourGExtendCmdReq::Swap(FourGExtendCmdReq* other) {
  if (other != this) {
    std::swap(serial_number_, other->serial_number_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(commander_id_, other->commander_id_);
    std::swap(result_info_, other->result_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FourGExtendCmdReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FourGExtendCmdReq_descriptor_;
  metadata.reflection = FourGExtendCmdReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TCUExtendCmdReq::kSerialNumberFieldNumber;
const int TCUExtendCmdReq::kTimeStampFieldNumber;
const int TCUExtendCmdReq::kCommanderIdFieldNumber;
const int TCUExtendCmdReq::kResultInfoFieldNumber;
#endif  // !_MSC_VER

TCUExtendCmdReq::TCUExtendCmdReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.TCUExtendCmdReq)
}

void TCUExtendCmdReq::InitAsDefaultInstance() {
}

TCUExtendCmdReq::TCUExtendCmdReq(const TCUExtendCmdReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.TCUExtendCmdReq)
}

void TCUExtendCmdReq::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  serial_number_ = 0u;
  time_stamp_ = 0u;
  commander_id_ = 0u;
  result_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TCUExtendCmdReq::~TCUExtendCmdReq() {
  // @@protoc_insertion_point(destructor:zna.protocol.TCUExtendCmdReq)
  SharedDtor();
}

void TCUExtendCmdReq::SharedDtor() {
  if (result_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete result_info_;
  }
  if (this != default_instance_) {
  }
}

void TCUExtendCmdReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TCUExtendCmdReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TCUExtendCmdReq_descriptor_;
}

const TCUExtendCmdReq& TCUExtendCmdReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

TCUExtendCmdReq* TCUExtendCmdReq::default_instance_ = NULL;

TCUExtendCmdReq* TCUExtendCmdReq::New() const {
  return new TCUExtendCmdReq;
}

void TCUExtendCmdReq::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TCUExtendCmdReq*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(serial_number_, time_stamp_);
    commander_id_ = 0u;
    if (has_result_info()) {
      if (result_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        result_info_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TCUExtendCmdReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.TCUExtendCmdReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 serial_number = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serial_number_)));
          set_has_serial_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_time_stamp;
        break;
      }

      // required uint32 time_stamp = 2;
      case 2: {
        if (tag == 16) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_commander_id;
        break;
      }

      // required uint32 commander_id = 3;
      case 3: {
        if (tag == 24) {
         parse_commander_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &commander_id_)));
          set_has_commander_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_result_info;
        break;
      }

      // required bytes result_info = 4;
      case 4: {
        if (tag == 34) {
         parse_result_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_result_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.TCUExtendCmdReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.TCUExtendCmdReq)
  return false;
#undef DO_
}

void TCUExtendCmdReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.TCUExtendCmdReq)
  // required uint32 serial_number = 1;
  if (has_serial_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->serial_number(), output);
  }

  // required uint32 time_stamp = 2;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->time_stamp(), output);
  }

  // required uint32 commander_id = 3;
  if (has_commander_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->commander_id(), output);
  }

  // required bytes result_info = 4;
  if (has_result_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->result_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.TCUExtendCmdReq)
}

::google::protobuf::uint8* TCUExtendCmdReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.TCUExtendCmdReq)
  // required uint32 serial_number = 1;
  if (has_serial_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->serial_number(), target);
  }

  // required uint32 time_stamp = 2;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->time_stamp(), target);
  }

  // required uint32 commander_id = 3;
  if (has_commander_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->commander_id(), target);
  }

  // required bytes result_info = 4;
  if (has_result_info()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->result_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.TCUExtendCmdReq)
  return target;
}

int TCUExtendCmdReq::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 serial_number = 1;
    if (has_serial_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serial_number());
    }

    // required uint32 time_stamp = 2;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

    // required uint32 commander_id = 3;
    if (has_commander_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->commander_id());
    }

    // required bytes result_info = 4;
    if (has_result_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->result_info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TCUExtendCmdReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TCUExtendCmdReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TCUExtendCmdReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TCUExtendCmdReq::MergeFrom(const TCUExtendCmdReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serial_number()) {
      set_serial_number(from.serial_number());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_commander_id()) {
      set_commander_id(from.commander_id());
    }
    if (from.has_result_info()) {
      set_result_info(from.result_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TCUExtendCmdReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TCUExtendCmdReq::CopyFrom(const TCUExtendCmdReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TCUExtendCmdReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void TCUExtendCmdReq::Swap(TCUExtendCmdReq* other) {
  if (other != this) {
    std::swap(serial_number_, other->serial_number_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(commander_id_, other->commander_id_);
    std::swap(result_info_, other->result_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TCUExtendCmdReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TCUExtendCmdReq_descriptor_;
  metadata.reflection = TCUExtendCmdReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TCUExtendCmdRsp::kSerialNumberFieldNumber;
const int TCUExtendCmdRsp::kTimeStampFieldNumber;
const int TCUExtendCmdRsp::kCommanderIdFieldNumber;
const int TCUExtendCmdRsp::kResultInfoFieldNumber;
#endif  // !_MSC_VER

TCUExtendCmdRsp::TCUExtendCmdRsp()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.TCUExtendCmdRsp)
}

void TCUExtendCmdRsp::InitAsDefaultInstance() {
}

TCUExtendCmdRsp::TCUExtendCmdRsp(const TCUExtendCmdRsp& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.TCUExtendCmdRsp)
}

void TCUExtendCmdRsp::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  serial_number_ = 0u;
  time_stamp_ = 0u;
  commander_id_ = 0u;
  result_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TCUExtendCmdRsp::~TCUExtendCmdRsp() {
  // @@protoc_insertion_point(destructor:zna.protocol.TCUExtendCmdRsp)
  SharedDtor();
}

void TCUExtendCmdRsp::SharedDtor() {
  if (result_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete result_info_;
  }
  if (this != default_instance_) {
  }
}

void TCUExtendCmdRsp::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TCUExtendCmdRsp::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TCUExtendCmdRsp_descriptor_;
}

const TCUExtendCmdRsp& TCUExtendCmdRsp::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

TCUExtendCmdRsp* TCUExtendCmdRsp::default_instance_ = NULL;

TCUExtendCmdRsp* TCUExtendCmdRsp::New() const {
  return new TCUExtendCmdRsp;
}

void TCUExtendCmdRsp::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<TCUExtendCmdRsp*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(serial_number_, time_stamp_);
    commander_id_ = 0u;
    if (has_result_info()) {
      if (result_info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        result_info_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TCUExtendCmdRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.TCUExtendCmdRsp)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 serial_number = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &serial_number_)));
          set_has_serial_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_time_stamp;
        break;
      }

      // required uint32 time_stamp = 2;
      case 2: {
        if (tag == 16) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_commander_id;
        break;
      }

      // required uint32 commander_id = 3;
      case 3: {
        if (tag == 24) {
         parse_commander_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &commander_id_)));
          set_has_commander_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_result_info;
        break;
      }

      // required bytes result_info = 4;
      case 4: {
        if (tag == 34) {
         parse_result_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_result_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.TCUExtendCmdRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.TCUExtendCmdRsp)
  return false;
#undef DO_
}

void TCUExtendCmdRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.TCUExtendCmdRsp)
  // required uint32 serial_number = 1;
  if (has_serial_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->serial_number(), output);
  }

  // required uint32 time_stamp = 2;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->time_stamp(), output);
  }

  // required uint32 commander_id = 3;
  if (has_commander_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->commander_id(), output);
  }

  // required bytes result_info = 4;
  if (has_result_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->result_info(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.TCUExtendCmdRsp)
}

::google::protobuf::uint8* TCUExtendCmdRsp::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.TCUExtendCmdRsp)
  // required uint32 serial_number = 1;
  if (has_serial_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->serial_number(), target);
  }

  // required uint32 time_stamp = 2;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->time_stamp(), target);
  }

  // required uint32 commander_id = 3;
  if (has_commander_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->commander_id(), target);
  }

  // required bytes result_info = 4;
  if (has_result_info()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->result_info(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.TCUExtendCmdRsp)
  return target;
}

int TCUExtendCmdRsp::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 serial_number = 1;
    if (has_serial_number()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->serial_number());
    }

    // required uint32 time_stamp = 2;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time_stamp());
    }

    // required uint32 commander_id = 3;
    if (has_commander_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->commander_id());
    }

    // required bytes result_info = 4;
    if (has_result_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->result_info());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TCUExtendCmdRsp::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TCUExtendCmdRsp* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TCUExtendCmdRsp*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TCUExtendCmdRsp::MergeFrom(const TCUExtendCmdRsp& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_serial_number()) {
      set_serial_number(from.serial_number());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_commander_id()) {
      set_commander_id(from.commander_id());
    }
    if (from.has_result_info()) {
      set_result_info(from.result_info());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TCUExtendCmdRsp::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TCUExtendCmdRsp::CopyFrom(const TCUExtendCmdRsp& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TCUExtendCmdRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void TCUExtendCmdRsp::Swap(TCUExtendCmdRsp* other) {
  if (other != this) {
    std::swap(serial_number_, other->serial_number_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(commander_id_, other->commander_id_);
    std::swap(result_info_, other->result_info_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TCUExtendCmdRsp::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TCUExtendCmdRsp_descriptor_;
  metadata.reflection = TCUExtendCmdRsp_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FCM_Info::kFCMLKASysStateFieldNumber;
const int FCM_Info::kFCMACCSysFailureFieldNumber;
const int FCM_Info::kFCMAEBFailinfoFieldNumber;
#endif  // !_MSC_VER

FCM_Info::FCM_Info()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.FCM_Info)
}

void FCM_Info::InitAsDefaultInstance() {
}

FCM_Info::FCM_Info(const FCM_Info& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.FCM_Info)
}

void FCM_Info::SharedCtor() {
  _cached_size_ = 0;
  fcm_lka_sys_state_ = 0u;
  fcm_acc_sysfailure_ = 0u;
  fcm_aeb_failinfo_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FCM_Info::~FCM_Info() {
  // @@protoc_insertion_point(destructor:zna.protocol.FCM_Info)
  SharedDtor();
}

void FCM_Info::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FCM_Info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FCM_Info::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FCM_Info_descriptor_;
}

const FCM_Info& FCM_Info::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

FCM_Info* FCM_Info::default_instance_ = NULL;

FCM_Info* FCM_Info::New() const {
  return new FCM_Info;
}

void FCM_Info::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<FCM_Info*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(fcm_lka_sys_state_, fcm_aeb_failinfo_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FCM_Info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.FCM_Info)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 FCM_LKA_Sys_state = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fcm_lka_sys_state_)));
          set_has_fcm_lka_sys_state();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_FCM_ACC_SysFailure;
        break;
      }

      // optional uint32 FCM_ACC_SysFailure = 2;
      case 2: {
        if (tag == 16) {
         parse_FCM_ACC_SysFailure:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fcm_acc_sysfailure_)));
          set_has_fcm_acc_sysfailure();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_FCM_AEB_Failinfo;
        break;
      }

      // optional uint32 FCM_AEB_Failinfo = 3;
      case 3: {
        if (tag == 24) {
         parse_FCM_AEB_Failinfo:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fcm_aeb_failinfo_)));
          set_has_fcm_aeb_failinfo();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.FCM_Info)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.FCM_Info)
  return false;
#undef DO_
}

void FCM_Info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.FCM_Info)
  // optional uint32 FCM_LKA_Sys_state = 1;
  if (has_fcm_lka_sys_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->fcm_lka_sys_state(), output);
  }

  // optional uint32 FCM_ACC_SysFailure = 2;
  if (has_fcm_acc_sysfailure()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->fcm_acc_sysfailure(), output);
  }

  // optional uint32 FCM_AEB_Failinfo = 3;
  if (has_fcm_aeb_failinfo()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->fcm_aeb_failinfo(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.FCM_Info)
}

::google::protobuf::uint8* FCM_Info::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.FCM_Info)
  // optional uint32 FCM_LKA_Sys_state = 1;
  if (has_fcm_lka_sys_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->fcm_lka_sys_state(), target);
  }

  // optional uint32 FCM_ACC_SysFailure = 2;
  if (has_fcm_acc_sysfailure()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->fcm_acc_sysfailure(), target);
  }

  // optional uint32 FCM_AEB_Failinfo = 3;
  if (has_fcm_aeb_failinfo()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->fcm_aeb_failinfo(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.FCM_Info)
  return target;
}

int FCM_Info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 FCM_LKA_Sys_state = 1;
    if (has_fcm_lka_sys_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fcm_lka_sys_state());
    }

    // optional uint32 FCM_ACC_SysFailure = 2;
    if (has_fcm_acc_sysfailure()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fcm_acc_sysfailure());
    }

    // optional uint32 FCM_AEB_Failinfo = 3;
    if (has_fcm_aeb_failinfo()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fcm_aeb_failinfo());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FCM_Info::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FCM_Info* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FCM_Info*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FCM_Info::MergeFrom(const FCM_Info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_fcm_lka_sys_state()) {
      set_fcm_lka_sys_state(from.fcm_lka_sys_state());
    }
    if (from.has_fcm_acc_sysfailure()) {
      set_fcm_acc_sysfailure(from.fcm_acc_sysfailure());
    }
    if (from.has_fcm_aeb_failinfo()) {
      set_fcm_aeb_failinfo(from.fcm_aeb_failinfo());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FCM_Info::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FCM_Info::CopyFrom(const FCM_Info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FCM_Info::IsInitialized() const {

  return true;
}

void FCM_Info::Swap(FCM_Info* other) {
  if (other != this) {
    std::swap(fcm_lka_sys_state_, other->fcm_lka_sys_state_);
    std::swap(fcm_acc_sysfailure_, other->fcm_acc_sysfailure_);
    std::swap(fcm_aeb_failinfo_, other->fcm_aeb_failinfo_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FCM_Info::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FCM_Info_descriptor_;
  metadata.reflection = FCM_Info_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int EPS_Info::kEPSFaultStatesFieldNumber;
#endif  // !_MSC_VER

EPS_Info::EPS_Info()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.EPS_Info)
}

void EPS_Info::InitAsDefaultInstance() {
}

EPS_Info::EPS_Info(const EPS_Info& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.EPS_Info)
}

void EPS_Info::SharedCtor() {
  _cached_size_ = 0;
  eps_faultstates_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

EPS_Info::~EPS_Info() {
  // @@protoc_insertion_point(destructor:zna.protocol.EPS_Info)
  SharedDtor();
}

void EPS_Info::SharedDtor() {
  if (this != default_instance_) {
  }
}

void EPS_Info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* EPS_Info::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EPS_Info_descriptor_;
}

const EPS_Info& EPS_Info::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

EPS_Info* EPS_Info::default_instance_ = NULL;

EPS_Info* EPS_Info::New() const {
  return new EPS_Info;
}

void EPS_Info::Clear() {
  eps_faultstates_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool EPS_Info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.EPS_Info)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 EPS_FaultStates = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &eps_faultstates_)));
          set_has_eps_faultstates();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.EPS_Info)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.EPS_Info)
  return false;
#undef DO_
}

void EPS_Info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.EPS_Info)
  // optional uint32 EPS_FaultStates = 1;
  if (has_eps_faultstates()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->eps_faultstates(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.EPS_Info)
}

::google::protobuf::uint8* EPS_Info::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.EPS_Info)
  // optional uint32 EPS_FaultStates = 1;
  if (has_eps_faultstates()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->eps_faultstates(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.EPS_Info)
  return target;
}

int EPS_Info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 EPS_FaultStates = 1;
    if (has_eps_faultstates()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->eps_faultstates());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EPS_Info::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const EPS_Info* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const EPS_Info*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void EPS_Info::MergeFrom(const EPS_Info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_eps_faultstates()) {
      set_eps_faultstates(from.eps_faultstates());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void EPS_Info::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EPS_Info::CopyFrom(const EPS_Info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EPS_Info::IsInitialized() const {

  return true;
}

void EPS_Info::Swap(EPS_Info* other) {
  if (other != this) {
    std::swap(eps_faultstates_, other->eps_faultstates_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata EPS_Info::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = EPS_Info_descriptor_;
  metadata.reflection = EPS_Info_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ELD_Info::kELDFaultStsFieldNumber;
#endif  // !_MSC_VER

ELD_Info::ELD_Info()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.ELD_Info)
}

void ELD_Info::InitAsDefaultInstance() {
}

ELD_Info::ELD_Info(const ELD_Info& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.ELD_Info)
}

void ELD_Info::SharedCtor() {
  _cached_size_ = 0;
  eldfaultsts_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ELD_Info::~ELD_Info() {
  // @@protoc_insertion_point(destructor:zna.protocol.ELD_Info)
  SharedDtor();
}

void ELD_Info::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ELD_Info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ELD_Info::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ELD_Info_descriptor_;
}

const ELD_Info& ELD_Info::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

ELD_Info* ELD_Info::default_instance_ = NULL;

ELD_Info* ELD_Info::New() const {
  return new ELD_Info;
}

void ELD_Info::Clear() {
  eldfaultsts_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ELD_Info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.ELD_Info)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 ELDFaultSts = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &eldfaultsts_)));
          set_has_eldfaultsts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.ELD_Info)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.ELD_Info)
  return false;
#undef DO_
}

void ELD_Info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.ELD_Info)
  // optional uint32 ELDFaultSts = 1;
  if (has_eldfaultsts()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->eldfaultsts(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.ELD_Info)
}

::google::protobuf::uint8* ELD_Info::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.ELD_Info)
  // optional uint32 ELDFaultSts = 1;
  if (has_eldfaultsts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->eldfaultsts(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.ELD_Info)
  return target;
}

int ELD_Info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 ELDFaultSts = 1;
    if (has_eldfaultsts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->eldfaultsts());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ELD_Info::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ELD_Info* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ELD_Info*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ELD_Info::MergeFrom(const ELD_Info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_eldfaultsts()) {
      set_eldfaultsts(from.eldfaultsts());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ELD_Info::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ELD_Info::CopyFrom(const ELD_Info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ELD_Info::IsInitialized() const {

  return true;
}

void ELD_Info::Swap(ELD_Info* other) {
  if (other != this) {
    std::swap(eldfaultsts_, other->eldfaultsts_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ELD_Info::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ELD_Info_descriptor_;
  metadata.reflection = ELD_Info_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ECU_Info::kECMD48VFaultStatesFieldNumber;
#endif  // !_MSC_VER

ECU_Info::ECU_Info()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:zna.protocol.ECU_Info)
}

void ECU_Info::InitAsDefaultInstance() {
}

ECU_Info::ECU_Info(const ECU_Info& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:zna.protocol.ECU_Info)
}

void ECU_Info::SharedCtor() {
  _cached_size_ = 0;
  ecmd_48v_faultstates_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ECU_Info::~ECU_Info() {
  // @@protoc_insertion_point(destructor:zna.protocol.ECU_Info)
  SharedDtor();
}

void ECU_Info::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ECU_Info::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ECU_Info::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ECU_Info_descriptor_;
}

const ECU_Info& ECU_Info::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_zna_5fprotocol_5fmessage_2eproto();
  return *default_instance_;
}

ECU_Info* ECU_Info::default_instance_ = NULL;

ECU_Info* ECU_Info::New() const {
  return new ECU_Info;
}

void ECU_Info::Clear() {
  ecmd_48v_faultstates_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ECU_Info::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:zna.protocol.ECU_Info)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 ECMD_48V_FaultStates = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ecmd_48v_faultstates_)));
          set_has_ecmd_48v_faultstates();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:zna.protocol.ECU_Info)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:zna.protocol.ECU_Info)
  return false;
#undef DO_
}

void ECU_Info::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:zna.protocol.ECU_Info)
  // optional uint32 ECMD_48V_FaultStates = 1;
  if (has_ecmd_48v_faultstates()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ecmd_48v_faultstates(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:zna.protocol.ECU_Info)
}

::google::protobuf::uint8* ECU_Info::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:zna.protocol.ECU_Info)
  // optional uint32 ECMD_48V_FaultStates = 1;
  if (has_ecmd_48v_faultstates()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->ecmd_48v_faultstates(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:zna.protocol.ECU_Info)
  return target;
}

int ECU_Info::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional uint32 ECMD_48V_FaultStates = 1;
    if (has_ecmd_48v_faultstates()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ecmd_48v_faultstates());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ECU_Info::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ECU_Info* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ECU_Info*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ECU_Info::MergeFrom(const ECU_Info& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ecmd_48v_faultstates()) {
      set_ecmd_48v_faultstates(from.ecmd_48v_faultstates());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ECU_Info::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ECU_Info::CopyFrom(const ECU_Info& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ECU_Info::IsInitialized() const {

  return true;
}

void ECU_Info::Swap(ECU_Info* other) {
  if (other != this) {
    std::swap(ecmd_48v_faultstates_, other->ecmd_48v_faultstates_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ECU_Info::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ECU_Info_descriptor_;
  metadata.reflection = ECU_Info_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace zna

// @@protoc_insertion_point(global_scope)
